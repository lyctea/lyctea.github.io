<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aries 网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luoyec.cn/"/>
  <updated>2022-06-14T11:00:22.897Z</updated>
  <id>https://luoyec.cn/</id>
  
  <author>
    <name>luoyecong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化总结</title>
    <link href="https://luoyec.cn/2022/06/14/cl4e29qfu0084989ecw85zeo1/"/>
    <id>https://luoyec.cn/2022/06/14/cl4e29qfu0084989ecw85zeo1/</id>
    <published>2022-06-14T10:35:17.163Z</published>
    <updated>2022-06-14T11:00:22.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端性能优化总结"><a href="#前端性能优化总结" class="headerlink" title="前端性能优化总结"></a>前端性能优化总结</h1><ul><li>性能优化的指标和工具</li><li>渲染优化</li><li>资源压缩与合并</li><li>构建优化</li><li>传输加载优化</li></ul><h1 id="性能优化的指标和工具"><a href="#性能优化的指标和工具" class="headerlink" title="性能优化的指标和工具"></a>性能优化的指标和工具</h1><p>Created: April 24, 2022 6:07 PM</p><h2 id="性能指标，多块才算快"><a href="#性能指标，多块才算快" class="headerlink" title="性能指标，多块才算快"></a>性能指标，多块才算快</h2><h3 id="性能指标和优化目标"><a href="#性能指标和优化目标" class="headerlink" title="性能指标和优化目标"></a>性能指标和优化目标</h3><ul><li>【加载瀑布图】谷歌调试工具 NetWord，Waterfall；TTFB，http请求从发起到返回的时间；</li><li>【速度指数】Lighthouse测试网站评分，100满分；</li><li><p>【帧率FPS】查询网站帧率；</p><p>  <img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/592d81ef-2852-446f-893b-213fad813102/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105355Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=7b79821dd585d0600d83b3aefe67dbe6591cf0dd7e02a8a075ec4e7f2c422578&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p></li><li><p>【页面加载时间】异步请求完成时间在一秒钟内，无法完成加loading动画；</p></li><li>【首次渲染】懒加载、预加载优化；</li><li>【交互】交互动作反馈时间足够短；</li></ul><h3 id="RAIL测量模型"><a href="#RAIL测量模型" class="headerlink" title="RAIL测量模型"></a>RAIL测量模型</h3><h3 id="什么是RAIL"><a href="#什么是RAIL" class="headerlink" title="什么是RAIL"></a>什么是RAIL</h3><p><strong>Respose(响应)</strong>：网站给用户的响应体验<br><strong>Animation(动画)</strong>:  网站加的动效给用户的体验<br><strong>Idle(空闲)</strong>: 网站响应时，页面卡顿，主线程繁忙的情况下，要考虑如何加大主线程空闲的时间<br><strong>Load(加载):</strong> 资源加载时，白屏等待时间</p><h3 id="RAIL评估标准"><a href="#RAIL评估标准" class="headerlink" title="RAIL评估标准"></a>RAIL评估标准</h3><p><strong>Respose(响应)</strong>：处理事件应在50ms内完成<br><strong>Animation(动画)</strong>：每10ms产生一帧<br><strong>Idle(空闲)</strong>：尽可能增加空闲时间<br><strong>Load(加载)</strong>：在5s内完成内容加载并可以交互</p><h2 id="利用测量工具和APIs"><a href="#利用测量工具和APIs" class="headerlink" title="利用测量工具和APIs"></a>利用测量工具和APIs</h2><ol><li><p><strong>Chrome DevTools 开发调试、性能评测</strong></p><ol><li>Audit(Lighthouse)</li><li>Throttling调整网络吞吐</li><li>Performance性能分析</li><li>Network网络加载分析</li></ol></li><li><p><strong>Lighthouse 网站整体质量评估</strong></p><ol><li><code>**npm install -g lighthouse lighthouse [https://www.baidu.com](https://www.baidu.com/)**</code></li><li><strong>Chrome DevTools 中使用 lighthouse</strong></li></ol></li><li><p><strong>WebPageTest多测试地点、全面性能报告</strong></p><p> <a href="https://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest - Website Performance and Optimization Test</a></p><ul><li>waterfall chart 请求瀑布图</li><li>first view 首次访问，<strong>First Byte、Start Render</strong></li><li>repeat view 访问</li><li>如何本地部署<strong>WebpageTest</strong>，docker镜像部署</li></ul></li></ol><h2 id="优化问题，重新测量（迭代-）"><a href="#优化问题，重新测量（迭代-）" class="headerlink" title="优化问题，重新测量（迭代 ）"></a>优化问题，重新测量（迭代 ）</h2><h1 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h1><p>Created: April 24, 2022 6:07 PM</p><p><a href="https://zhuanlan.zhihu.com/p/336765062" target="_blank" rel="noopener">问我Chrome浏览器的渲染原理（6000字长文）</a></p><h2 id="浏览器渲染原理，关键渲染路径"><a href="#浏览器渲染原理，关键渲染路径" class="headerlink" title="浏览器渲染原理，关键渲染路径"></a>浏览器渲染原理，关键渲染路径</h2><p><strong>浏览器的渲染流程</strong></p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6d78e3da-fdb5-45d4-a7c1-ee89b523fe79/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105540Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=c5b60b81a4945e80240b01354367c96239dbf07891bf1e68856a09262a2f75df&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><ol><li>js引起页面变化</li><li>样式修改</li><li>布局，绘制到页面上</li><li>绘制</li><li>合成，多个图层组合</li></ol><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/9b3d40e6-988e-4123-95b6-06017bd56ed5/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105605Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=be6ad7bd5e32a16500c150cd66a40c7f02e1a0b1aaa5dde248c1b6128a4e8f44&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><h1 id="资源压缩与合并"><a href="#资源压缩与合并" class="headerlink" title="资源压缩与合并"></a>资源压缩与合并</h1><ul><li>减少http请求数量</li><li>减少请求资源的大小<ul><li>html压缩，<code>html-minifier</code> <code>npm</code>工具</li><li>css压缩</li><li>js文件合并</li><li>图片压缩</li><li>字体优化</li></ul></li></ul><h1 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h1><p>Created: April 26, 2022 5:59 PM</p><h1 id="webpack4优化"><a href="#webpack4优化" class="headerlink" title="webpack4优化"></a>webpack4优化</h1><h2 id="webpack4的模式"><a href="#webpack4的模式" class="headerlink" title="webpack4的模式"></a>webpack4的模式</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于开发的配置文件，配置热更新、跨域配置、端口设置等</span></span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line"><span class="comment">// 用于生产的配置文件，配置 js 压缩、代码拆分等</span></span><br><span class="line"><span class="string">"build"</span>: <span class="string">"webpack --mode production"</span></span><br></pre></td></tr></table></figure><h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h2><ul><li>上下文未用到的代码；</li><li>基于ESM，es6的模块化；</li><li><p>可能会有副作用，不希望被shaking的文件</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"slideEffects"</span>: [</span><br><span class="line"><span class="string">"*.css"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>注意babel配置的影响</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel预设</span></span><br><span class="line"><span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"modules"</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure></li></ul><h2 id="JS压缩"><a href="#JS压缩" class="headerlink" title="JS压缩"></a>JS压缩</h2><ul><li>webpack4后引入 <code>uglifyjs-webpack-plugin</code></li><li>支持ES6替换为 <code>terser-webpack-glugin</code> （效率更好，生产默认，支持es6）</li><li>减小js文件体积</li></ul><h2 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h2><ul><li>生产模式自动启用，代码体积减小</li><li>提高执行效率</li><li>注意babel配置的影响，仅支持esm</li></ul><h2 id="babel7优化配置"><a href="#babel7优化配置" class="headerlink" title="babel7优化配置"></a>babel7优化配置</h2><ul><li><p>在需要的地方引入polyfill</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"targets"</span>: &#123;</span><br><span class="line">          <span class="string">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="comment">// 需要的地方引入polyfill</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>辅助函数的按需引入, <code>@babel/plugin-transform-runtime</code></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置目标浏览器，</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"targets"</span>: &#123;</span><br><span class="line">          <span class="string">"chrome"</span>: [<span class="string">"&gt;0.25%"</span>] <span class="comment">// 大于使用率0.25的浏览器</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="提高构建速度"><a href="#提高构建速度" class="headerlink" title="提高构建速度"></a>提高构建速度</h2><ul><li><p>noParse，告诉webpack哪些库不进行解析</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery｜lodash/</span>, <span class="comment">//忽略对部分没采用模块化的文件的递归解析处理</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>DLLPlugin(动态链接库)<ul><li>避免打包时对不变的库重复构建</li><li>提高构建速度</li></ul></li></ul><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><ul><li><code>Terser</code>压缩JS</li><li><code>mini-css-extract-plugin</code>压缩css</li><li><code>HtmlWebpackPlugin-minify</code> 压缩HTML</li></ul><h1 id="基于webpack的资源持久化缓存"><a href="#基于webpack的资源持久化缓存" class="headerlink" title="基于webpack的资源持久化缓存"></a>基于webpack的资源持久化缓存</h1><p>缓存资源没有更新，或者更新不及时。访问旧缓存容易导致问题，解决方案是每个打包资源文件有唯一的hash值，做增量式的更新。</p><ul><li>增量式更新</li><li>只有变化的文件hash才会改变</li><li>充分利用浏览器缓存</li></ul><h1 id="检测与分析"><a href="#检测与分析" class="headerlink" title="检测与分析"></a>检测与分析</h1><ul><li><strong>Stats分析与可视化</strong></li></ul><p><a href="https://alexkuz.github.io/webpack-chart/" target="_blank" rel="noopener">Webpack Chart</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate stats.json for your project with this command:</span></span><br><span class="line">$ webpack --profile --json &gt; stats.json</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/66227af7-199e-4140-b3e7-26e03e594106/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105746Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=dbed23dc25126fe902afc4c0822c92413073cd82e5a182f669f1b65d7f7bc9e9&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><ul><li><strong>webpack-bundle-analyzer 进行体积分析</strong></li></ul><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/24683424-cfe8-418b-a3f4-3e05c3e2946b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105810Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=d372509905148c498ce6d63673ef29afb96f771000e9c197f31d6363ed099824&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><ul><li><strong>speed-measure-webpack-plugin速度分析</strong></li></ul><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/857dacb3-2957-4612-8b50-ef2548166ced/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105844Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=3cd8e526dce57fa459a3948ba76ad233a6c712aea19285203268cf20bdf43684&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><h1 id="React-按需加载"><a href="#React-按需加载" class="headerlink" title="React 按需加载"></a>React 按需加载</h1><ul><li><p><strong>React router基于webpack动态引入</strong></p><p>  <img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c152ced0-2561-4694-8ad8-94fae1628018/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105905Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=720497ef8cc68012b70a54999b547236066b0233537be7b8338121bcebc37fb7&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p></li><li><p><strong>使用Reloadable高级组件</strong></p><p>  fallback：在未加载器代替的组件</p><p>  <img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3eafedaf-a560-4687-92cb-5a35d980c528/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T105919Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=59798a581d891f0e6c116a30f76505e92325123d2a39da0a00d275438f965ce0&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p></li></ul><pre><code># 传输加载优化</code></pre><p>Created: April 27, 2022 10:21 AM</p><h1 id="Gzip压缩"><a href="#Gzip压缩" class="headerlink" title="Gzip压缩"></a>Gzip压缩</h1><ul><li>对传输资源进行体积压缩，高达90%</li><li><p>利用nginx启用 Gzip</p><p>  <img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled.png" alt="Untitled"></p></li></ul><h1 id="启用http-keep-alive"><a href="#启用http-keep-alive" class="headerlink" title="启用http keep-alive"></a>启用http keep-alive</h1><p>http 协议默认开启的 keep-alive</p><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%201.png" alt="Untitled"></p><h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><p><strong>Nginx配置：</strong></p><p>图片等静态资源，可以更长时间</p><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%202.png" alt="Untitled"></p><ul><li>Cache-Control/Expires</li><li>Last-Modified + If-Modified-Since</li><li>Etag + If-None-Match</li></ul><h1 id="Service-Workers作用"><a href="#Service-Workers作用" class="headerlink" title="Service Workers作用"></a>Service Workers作用</h1><ul><li>加速重复访问</li><li>离线支持</li></ul><h3 id="service-workers-配置"><a href="#service-workers-配置" class="headerlink" title="service workers 配置"></a>service workers 配置</h3><ul><li>create-react-app自带；</li><li>webpack引入两个插件实现</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>延长了首屏时间，但页面总加载时间减少；</li><li>兼容性问题；</li><li>只能在localhost或https下使用；</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%203.png" alt="Untitled"></p><h1 id="http-2-性能提升"><a href="#http-2-性能提升" class="headerlink" title="http/2 性能提升"></a>http/2 性能提升</h1><ul><li>二进制传输，1.1基于文本，h2是基于二进制编码，提高安全性，头部压缩</li><li>请求响应多路复用；</li><li>Server push，提前将资源推送到浏览器</li></ul><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><ol><li>先开启https</li></ol><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%204.png" alt="Untitled"></p><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%205.png" alt="Untitled"></p><ol><li>开启h2</li></ol><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%206.png" alt="Untitled"></p><h2 id="h2的多路复用"><a href="#h2的多路复用" class="headerlink" title="h2的多路复用"></a>h2的多路复用</h2><p><img src="%E4%BC%A0%E8%BE%93%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%201b32b3437a524e61902442a068c38a41/Untitled%207.png" alt="Untitled"></p><h1 id="SSR的好处"><a href="#SSR的好处" class="headerlink" title="SSR的好处"></a>SSR的好处</h1><ul><li>加速首屏加载速度</li><li>更好的SEO</li></ul><h2 id="基于Next-js实现服务端渲染"><a href="#基于Next-js实现服务端渲染" class="headerlink" title="基于Next.js实现服务端渲染"></a>基于Next.js实现服务端渲染</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端性能优化总结&quot;&gt;&lt;a href=&quot;#前端性能优化总结&quot; class=&quot;headerlink&quot; title=&quot;前端性能优化总结&quot;&gt;&lt;/a&gt;前端性能优化总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;性能优化的指标和工具&lt;/li&gt;
&lt;li&gt;渲染优化&lt;/li&gt;
&lt;li&gt;资源压缩与合
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="https://luoyec.cn/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>脚手架的实现原理</title>
    <link href="https://luoyec.cn/2022/06/14/cl4e29qh000a1989ejmxqlanl/"/>
    <id>https://luoyec.cn/2022/06/14/cl4e29qh000a1989ejmxqlanl/</id>
    <published>2022-06-14T10:20:31.515Z</published>
    <updated>2022-06-14T11:01:29.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端脚手架"><a href="#前端脚手架" class="headerlink" title="前端脚手架"></a>前端脚手架</h1><p>封面: %E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%203120586a0b114ce68032adcdd43c8f7b/450136-20211216163813527-887451633.jpeg<br>简介: 前端统一cli工具搭建</p><p><a href="https://www.bilibili.com/video/BV1KL4y1j7hj?spm_id_from=333.999.0.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1KL4y1j7hj?spm_id_from=333.999.0.0</a></p><p><a href="https://homework.imooc-lego.com/" target="_blank" rel="noopener">https://homework.imooc-lego.com/</a></p><p><a href="https://github.com/omni-door/cli/blob/master/docs/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/omni-door/cli/blob/master/docs/README.zh-CN.md</a></p><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><ul><li style="list-style: none"><input type="checkbox" checked> 脚手架的实现原理</li><li style="list-style: none"><input type="checkbox" checked> Lerra的常见用法<ul><li style="list-style: none"><input type="checkbox" checked> 多<code>package</code>项目管理痛点和解决方案，基于Lerna脚手架框架搭建；</li><li style="list-style: none"><input type="checkbox"> <code>yargs</code>的使用方法</li></ul></li><li style="list-style: none"><input type="checkbox" checked> 架构设计技巧和架构图绘制方法</li></ul><h3 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h3><ul><li style="list-style: none"><input type="checkbox"> 架构设计和技术方案设计全过程；</li><li style="list-style: none"><input type="checkbox"> 脚手架执行核心流程；<ul><li style="list-style: none"><input type="checkbox"> 脚手架模块拆分策略；</li><li style="list-style: none"><input type="checkbox"> <code>core</code>模块技术方案；</li></ul></li><li style="list-style: none"><input type="checkbox"> <code>commander</code>框架；<ul><li style="list-style: none"><input type="checkbox"> 脚手架命令注册；</li></ul></li><li style="list-style: none"><input type="checkbox"> 如何让 <code>Node</code>项目支持<code>ES Module</code> ；</li></ul><h3 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h3><ul><li style="list-style: none"><input type="checkbox"> 如何设计高性能脚手架；<ul><li style="list-style: none"><input type="checkbox"> 图解高性能脚手架架构和设计方法；</li><li style="list-style: none"><input type="checkbox"> <code>JavaScript</code>面向对象实战；</li><li style="list-style: none"><input type="checkbox"> 封装通用<code>package</code>和<code>Command</code>类</li></ul></li><li style="list-style: none"><input type="checkbox"> <code>node</code>多进程开发；<ul><li style="list-style: none"><input type="checkbox"> 基于缓存+<code>node</code>多进程实现动态命令行加载和执行；</li><li style="list-style: none"><input type="checkbox"> 业务逻辑和脚手架框架解耦；</li><li style="list-style: none"><input type="checkbox"> node多进程，child_process源码分析；</li></ul></li></ul><h3 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h3><ul><li style="list-style: none"><input type="checkbox"> 命令行交互方法</li><li style="list-style: none"><input type="checkbox"> 服务端框架egg.js的应用和API开发；</li><li style="list-style: none"><input type="checkbox"> <code>egg.js</code>集成云<code>mongodb</code></li></ul><h3 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h3><ul><li style="list-style: none"><input type="checkbox"> ejs模板渲染；<ul><li style="list-style: none"><input type="checkbox"> 项目模板安装和功能开发；</li></ul></li><li style="list-style: none"><input type="checkbox"> glob文件筛选；</li><li style="list-style: none"><input type="checkbox"> 项目标准安装和自定义安装；</li><li style="list-style: none"><input type="checkbox"> 组件库初始化和安装；</li></ul><h1 id="脚手架的实现原理"><a href="#脚手架的实现原理" class="headerlink" title="脚手架的实现原理"></a>脚手架的实现原理</h1><ol><li><p><strong>为什么全局安装 <code>@vue/cli</code> 后添加的命令为 <code>vue</code> ？</strong></p><p> 通过 <code>which vue</code> 可以查看命令的位置，实际位置：<code>/usr/local/bin/vue</code> ，是一个软连接，</p><p> 连接的位置：<code>lrwxr-xr-x 1 luoyec wheel 39 3 1 2021 vue -&gt; ../lib/node_modules/@vue/cli/bin/vue.js</code></p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// package.json 文件中 bin 决定了命令名为 vue</span><br><span class="line">"bin": &#123;</span><br><span class="line">    "vue": "bin/vue.js"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>全局安装<code>@vue/cli</code> 时发生了什么？</strong></p><ol><li>把依赖下载到指定的目录下，<code>/usr/local/lib/node_modules/@vue/cli</code></li><li>读取 <code>package.json</code> 中 <code>bin</code> 的配置，设置软连接</li></ol></li><li><p><strong>执行<code>vue</code>命令时发生了什么？为什么<code>vue</code>执行一个js文件，我们却可以通过<code>vue</code>命令执行它？</strong></p><ol><li>执行<code>vue</code>命令时，其实是执行软连接；</li><li><p>js文件无法直接执行，需要通过解释器(node)执行；</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node  环境变量中查询node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 node helloHorld.js</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>3. 通过 `ln -s  [path] [name]`  创建软连接；</code></pre><ol start="4"><li><strong>vue命令执行流程</strong></li></ol><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/84995361-2968-4067-87ca-5cc524b49bde/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T110044Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=83d1a9273d092305dd00bd6a43d7324b383e7e6290ab4368a4000beb2b5e3d4e&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="图4.1 vue 命令执行流程"></p><p>图4.1 vue 命令执行流程</p><h1 id="脚手架开发调试"><a href="#脚手架开发调试" class="headerlink" title="脚手架开发调试"></a>脚手架开发调试</h1><h3 id="发布一个简单的npm包"><a href="#发布一个简单的npm包" class="headerlink" title="发布一个简单的npm包"></a><strong>发布一个简单的npm包</strong></h3><ol><li><code>npm init -y</code></li><li><p>新建 <code>bin/index.js</code> </p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"kit-test"</span>: <span class="string">"bin/index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">#!/usr/bin / env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello fe architecture!'</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><code>npm login、npm publish</code></li><li><code>kit-test ⇒ hello fe architecture!</code></li></ol><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><ol><li><p><strong>调试单个包（注意文件夹命名）</strong></p><p> <code>lyctea-test</code> 包文件夹目录结构如下：</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── index.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></li></ol><pre><code>在`lyctea-test` 创建软连接 `npm link` ，此时会创建软链接会源文件所在目录<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/lyctea-test -&gt; ../lib/node_modules/lyctea-test/bin/index.js</span><br><span class="line"></span><br><span class="line"><span class="variable">$ll</span> -a ../lib/node_modules/lyctea-test                                                   </span><br><span class="line">../lib/node_modules/lyctea-test -&gt; /Users/luoyec/Documents/Code/Github/fe-architecture/lyctea-test</span><br></pre></td></tr></table></figure></code></pre><ol><li><p><strong>调试多个包</strong></p><ol><li>新建 <code>lyctea-test-lib</code> 目录</li><li><p>创建 <code>lib/index.js</code>文件，导出<code>sum</code>方法</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    sum(a, b) &#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>3. 创建`lyctea-test-lib` 的软连接，`npm link`4. 切换到`lyctea-test` 目录，创建软链接，`npm link lyctea-test-lib` ，此时 `lyctea-test` 可以方位到 `lib`库了    <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const lib = require(<span class="string">"lyctea-test-lib"</span>)</span><br><span class="line">console.log(lib.sum(<span class="number">1</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>5. 发布依赖包，移除软链接</code></pre><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><h3 id="原生脚手架开发痛点"><a href="#原生脚手架开发痛点" class="headerlink" title="原生脚手架开发痛点"></a>原生脚手架开发痛点</h3><ul><li>重复操作<ul><li>多<code>package</code>本地<code>link</code></li><li>多<code>package</code>本地依赖安卓</li><li>多<code>package</code>本地单元测试</li><li>多<code>package</code>本地代码提交</li><li>多<code>package</code>本地代码发布</li></ul></li><li>版本一致性<ul><li>发布时版本一致性，手工操作易出错</li><li>发布后相互依赖版本升级</li><li><code>package</code>越多，复杂性越高</li></ul></li></ul><h3 id="Lerna简介"><a href="#Lerna简介" class="headerlink" title="Lerna简介"></a>Lerna简介</h3><aside><br>💡 架构优化的主要目标往往都是以效能为核心。<br><br></aside><p><code>Lerna</code> 是一个优秀的基于<code>git+npm</code>的多<code>package</code>项目的管理工具；</p><p><strong>优势</strong></p><ul><li>大幅减少重复操作</li><li>提升操作的标准化</li></ul><p><strong>Lerna开发脚手架流程</strong></p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/9ae479d2-b95c-48b2-8d43-99a830b2c67f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220614%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20220614T110122Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=04076bdb3306cc99c044822df8dc1d2a0c1a21d7c7e05705a1b880b927e22d06&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端脚手架&quot;&gt;&lt;a href=&quot;#前端脚手架&quot; class=&quot;headerlink&quot; title=&quot;前端脚手架&quot;&gt;&lt;/a&gt;前端脚手架&lt;/h1&gt;&lt;p&gt;封面: %E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%20312058
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="https://luoyec.cn/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 原型、原型链</title>
    <link href="https://luoyec.cn/2019/03/07/cl4e29qcd001a989e0gqm4kbm/"/>
    <id>https://luoyec.cn/2019/03/07/cl4e29qcd001a989e0gqm4kbm/</id>
    <published>2019-03-07T08:43:57.726Z</published>
    <updated>2019-03-07T08:43:57.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-原型、原型链"><a href="#JavaScript-原型、原型链" class="headerlink" title="JavaScript 原型、原型链"></a>JavaScript 原型、原型链</h1><p>[<a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g0ubda0japj30rs0msjsd.jpg" alt="image-20190307163248964"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;  <span class="comment">// 所有的函数都能成为构造函数</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"say hello"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>原型链是有原型对象组成的</strong>，每个对象都有 <strong>proto</strong>属性，指向了创建该对象的构造函数的原型，<strong>proto</strong> 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限对象链。</p><ul><li><p><strong>属性查找机制</strong>：当查找对象属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则沿着原型链往上一级查找，直至最顶级的原型对象 <code>Object.prototype</code>，如果还是没有找到则输出 <code>undefined</code></p></li><li><p><strong>属性修改机制</strong>：只会修改实例本身的属性，如果不存在，则添加该属性，如果需要修改原型的属性时，则可以用 <code>b.prototype.x = 2</code>； 但这样会造成所有继承于该对象的实例的属性发生改变.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-原型、原型链&quot;&gt;&lt;a href=&quot;#JavaScript-原型、原型链&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 原型、原型链&quot;&gt;&lt;/a&gt;JavaScript 原型、原型链&lt;/h1&gt;&lt;p&gt;[&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="面试题" scheme="https://luoyec.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="原型" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>BFC 原理简介及应用</title>
    <link href="https://luoyec.cn/2019/03/05/cl4e29qbg0004989eds8jabxc/"/>
    <id>https://luoyec.cn/2019/03/05/cl4e29qbg0004989eds8jabxc/</id>
    <published>2019-03-05T06:19:16.937Z</published>
    <updated>2019-03-05T06:19:16.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFC-原理简介及应用"><a href="#BFC-原理简介及应用" class="headerlink" title="BFC 原理简介及应用"></a>BFC 原理简介及应用</h1><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><strong>块级格式化上下文</strong>，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><ul><li>触发条件<ul><li>根元素</li><li>position: absolute/fixed</li><li>display: inline-block/table</li><li>float 元素</li><li>overflow !== visible</li></ul></li><li>规则<ul><li>属于同一个 BFC 的两个相邻 Box 垂直排列</li><li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>BFC 中的子元素的 margin box 的左边，与包含块（BFC） border box 的左边接触，浮动元素也一样（子元素 absolute 除外）</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 高度时，浮动子元素也参与计算</li><li>文字层不会被浮动层覆盖，环绕于周围</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><iframe height="265" style="width: 100%;" scrolling="no" title="EMgEbj" src="//codepen.io/lyctea/embed/EMgEbj/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br><br>&gt; 规则：每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。（元素的 <code>margin</code> 的左边与父容器的 <code>border</code> 左边接触）<br><br>因此，虽然 <code>aside</code> 元素是浮动的，但是 <code>main</code> 的左边依然会与包含块的左边接触。<br><br>&gt; 规则：<code>BFC</code> 的区域不会与 <code>float box</code> 重叠<br><br>通过触发 <code>main</code> 来生成 <code>BFC</code>， 实现两栏布局。当触发main生成<code>BFC</code>后，这个新的<code>BFC</code>不会与浮动的 <code>aside</code> 重叠。因此会根据包含块的宽度，和 <code>aside</code> 的宽度，自动变窄。<br><br>### 清除内部浮动<br><br><iframe height="265" style="width: 100%;" scrolling="no" title="BbLrXG" src="//codepen.io/lyctea/embed/BbLrXG/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/lyctea/pen/BbLrXG/" target="_blank" rel="noopener">BbLrXG</a> by lyctea<br>  (<a href="https://codepen.io/lyctea" target="_blank" rel="noopener">@lyctea</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><blockquote><p>规则：计算 <code>BFC</code> 高度时，浮动元素也参与计算。</p></blockquote><h3 id="防止垂直-margin-重叠"><a href="#防止垂直-margin-重叠" class="headerlink" title="防止垂直 margin 重叠"></a>防止垂直 margin 重叠</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g0rsdyj3xij315u0t2dh9.jpg" alt="image-20190305120456347"></p><iframe height="265" style="width: 100%;" scrolling="no" title="BbLrXG" src="//codepen.io/lyctea/embed/BbLrXG/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/lyctea/pen/BbLrXG/" target="_blank" rel="noopener">BbLrXG</a> by lyctea<br>  (<a href="https://codepen.io/lyctea" target="_blank" rel="noopener">@lyctea</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><blockquote><p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></blockquote></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BFC-原理简介及应用&quot;&gt;&lt;a href=&quot;#BFC-原理简介及应用&quot; class=&quot;headerlink&quot; title=&quot;BFC 原理简介及应用&quot;&gt;&lt;/a&gt;BFC 原理简介及应用&lt;/h1&gt;&lt;h2 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;he
      
    
    </summary>
    
      <category term="HTML5" scheme="https://luoyec.cn/categories/HTML5/"/>
    
    
      <category term="BFC" scheme="https://luoyec.cn/tags/BFC/"/>
    
      <category term="面试题" scheme="https://luoyec.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Css" scheme="https://luoyec.cn/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>在 Express 中使用 log4js</title>
    <link href="https://luoyec.cn/2019/02/28/cl4e29qg2008h989ebgj13wvd/"/>
    <id>https://luoyec.cn/2019/02/28/cl4e29qg2008h989ebgj13wvd/</id>
    <published>2019-02-28T07:45:15.778Z</published>
    <updated>2019-02-28T07:45:15.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Express-中使用-log4js"><a href="#在-Express-中使用-log4js" class="headerlink" title="在 Express 中使用 log4js"></a>在 Express 中使用 log4js</h1><p><strong>在 config 中导出 log 配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import log4js from &quot;log4js&quot;;</span><br><span class="line"></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    file: &#123;</span><br><span class="line">      type: &quot;file&quot;,</span><br><span class="line">      filename: &quot;log/main.log&quot;,</span><br><span class="line">      maxLogSize: 200480,</span><br><span class="line">      backups: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    console: &#123;</span><br><span class="line">      type: &quot;stdout&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      appenders: [&quot;file&quot;, &quot;console&quot;],</span><br><span class="line">      level: &quot;all&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    production: &#123;</span><br><span class="line">      appenders: [&quot;file&quot;],</span><br><span class="line">      level: &quot;info&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    default: &#123;</span><br><span class="line">      appenders: [&quot;file&quot;],</span><br><span class="line">      level: &quot;info&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const logger =</span><br><span class="line">  process.env.NODE_ENV === &quot;development&quot;</span><br><span class="line">    ? log4js.getLogger(&quot;development&quot;)</span><br><span class="line">    : log4js.getLogger(&quot;production&quot;);</span><br><span class="line"></span><br><span class="line">export default logger;</span><br></pre></td></tr></table></figure><p><strong>express 中间件导入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import log4js from &quot;log4js&quot;;</span><br><span class="line">import logger from &quot;../config/log&quot;;</span><br><span class="line"></span><br><span class="line">export const loggerMiddleware = app =&gt; &#123;</span><br><span class="line">  app.use(log4js.connectLogger(logger));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>log4js 作为普通模块使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logger from &quot;./server/config/log&quot;;</span><br><span class="line">logger.info(&quot;24234234234&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在-Express-中使用-log4js&quot;&gt;&lt;a href=&quot;#在-Express-中使用-log4js&quot; class=&quot;headerlink&quot; title=&quot;在 Express 中使用 log4js&quot;&gt;&lt;/a&gt;在 Express 中使用 log4js&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://luoyec.cn/categories/Nodejs/"/>
    
    
      <category term="Express" scheme="https://luoyec.cn/tags/Express/"/>
    
      <category term="log4js" scheme="https://luoyec.cn/tags/log4js/"/>
    
      <category term="日志处理" scheme="https://luoyec.cn/tags/%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 调试 (Inspector)</title>
    <link href="https://luoyec.cn/2019/02/28/cl4e29qer0061989eifj7o3ca/"/>
    <id>https://luoyec.cn/2019/02/28/cl4e29qer0061989eifj7o3ca/</id>
    <published>2019-02-28T07:40:10.736Z</published>
    <updated>2019-02-28T07:40:10.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nodejs-调试-Inspector"><a href="#nodejs-调试-Inspector" class="headerlink" title="nodejs 调试 (Inspector)"></a>nodejs 调试 (Inspector)</h1><p>##Inspector</p><h3 id="Inspector-调试"><a href="#Inspector-调试" class="headerlink" title="Inspector 调试"></a>Inspector 调试</h3><p>（本质是断点调试）优势：</p><ul><li>查看当前上下文的变量</li><li>可观察当前函数调用堆栈</li><li>不侵入代码</li><li>可在暂停状态下执行指定代码</li></ul><h3 id="Inspector-的构成以及原理"><a href="#Inspector-的构成以及原理" class="headerlink" title="Inspector  的构成以及原理"></a>Inspector  的构成以及原理</h3><ul><li>WebSockets 服务(监听命令)</li><li>Inspector 协议</li><li>HTTP服务(获取元信息)</li></ul><p><strong>WebSockets</strong></p><p>其中 <code>ws://127.0.0.1:56374/680debbb-3009-4e86-8878-7992296e5cbf</code> 是 <code>WebSockets</code> 服务的地址和 <code>uuid</code></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0m4oa5l8ij311004adgz.jpg" alt="image-20190228143641634"></p><p><strong>源信息</strong></p><p><code>127.0.0.1:56374/json</code> </p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0m4rky14pj31940cqq66.jpg" alt="image-20190228143953223"></p><h2 id="激活调式"><a href="#激活调式" class="headerlink" title="激活调式"></a>激活调式</h2><p><strong>如何激活调试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$node --inpect app.js</span><br></pre></td></tr></table></figure><p><strong>激活调式后会发生什么？</strong></p><p><code>WebSockets</code> 服务(监听命令)</p><p><code>HTTP</code>服务(获取元信息)</p><p><strong>如何调试没有激活的Node.js程序</strong></p><p>在 <code>Linux</code> 和 <code>OSX</code> 上，可以监听到 <code>SIGUSR1</code> 发送的调试信息</p><h2 id="调试客户端"><a href="#调试客户端" class="headerlink" title="调试客户端"></a>调试客户端</h2><p><strong>是什么？</strong></p><p>连接到 <code>Node.js</code> <code>Inspector</code> 的工具</p><ul><li>Chrome DevTools 55+</li><li>VS Code</li><li>其他</li></ul><p><strong>Chrome</strong></p><ul><li>在元 信息中的 devtoolsFrontendUrl 字段，可以打开调试面板</li><li><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0m5labdfij30za0i00uw.jpg" alt="image-20190228150826302"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nodejs-调试-Inspector&quot;&gt;&lt;a href=&quot;#nodejs-调试-Inspector&quot; class=&quot;headerlink&quot; title=&quot;nodejs 调试 (Inspector)&quot;&gt;&lt;/a&gt;nodejs 调试 (Inspector)&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://luoyec.cn/categories/Nodejs/"/>
    
    
      <category term="Inspector" scheme="https://luoyec.cn/tags/Inspector/"/>
    
      <category term="debug" scheme="https://luoyec.cn/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Knex 在 Koa2 中的应用</title>
    <link href="https://luoyec.cn/2019/01/16/cl4e29qdh003p989e6vra3p9m/"/>
    <id>https://luoyec.cn/2019/01/16/cl4e29qdh003p989e6vra3p9m/</id>
    <published>2019-01-16T02:29:51.415Z</published>
    <updated>2019-01-16T02:29:51.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Knex-在-Koa2-中的应用"><a href="#Knex-在-Koa2-中的应用" class="headerlink" title="Knex 在 Koa2 中的应用"></a>Knex 在 Koa2 中的应用</h1><p><a href="https://knexjs.org/#Builder-withSchema" target="_blank" rel="noopener">Knexjs 文档</a></p><p><a href="https://github.com/johndatserakis/koa-vue-notes-api" target="_blank" rel="noopener">项目demo： koa-vue-notes-api</a></p><blockquote><p>Knex.js是为Postgres，MSSQL，MySQL，MariaDB，SQLite3，Oracle和Amazon Redshift设计的“包含电池”SQL查询构建器，其设计灵活，便于携带并且使用起来非常有趣。它具有传统的节点样式回调以及用于清洁异步流控制的承诺接口，流接口，全功能查询和模式构建器，事务支持（带保存点），连接池 以及不同查询客户和方言之间的标准化响应。  </p></blockquote><h2 id="准备工作，环境变量配置"><a href="#准备工作，环境变量配置" class="headerlink" title="准备工作，环境变量配置"></a>准备工作，环境变量配置</h2><p>利用 <code>dotenv</code> 模块将根目录下的 <code>.env</code> 文件配置注入到 <code>process.env</code> 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// .env</span><br><span class="line">DB_HOST = your_database_address</span><br><span class="line">DB_PORT = 3306</span><br><span class="line">DB_USER = root</span><br><span class="line">DB_PASSWORD = your_password</span><br><span class="line">DB_DATABASE = database_name</span><br><span class="line"></span><br><span class="line">NODE_ENV = development</span><br><span class="line">PORT = 4000</span><br></pre></td></tr></table></figure><p>在根目录创建 <code>knexfile.js</code>  作为<code>knex</code> 的配置文件，区分不同的开发环境，对配置进行差异化处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex init</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//knexfile.js</span><br><span class="line"></span><br><span class="line">//I only want migrations, rollbacks, and seeds to run when the NODE_ENV is specified</span><br><span class="line">//in the knex seed/migrate command. Knex will error out if it is not specified.</span><br><span class="line">if (!process.env.NODE_ENV) &#123; throw new Error(&apos;NODE_ENV not set&apos;); &#125;</span><br><span class="line"></span><br><span class="line">require(&apos;dotenv&apos;).config();</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  testing: &#123;</span><br><span class="line">    client: &apos;mysql&apos;,</span><br><span class="line">    debug: false,</span><br><span class="line">    connection: &#123;</span><br><span class="line">      host: process.env.DB_HOST,</span><br><span class="line">      port: process.env.DB_PORT,</span><br><span class="line">      user: process.env.DB_USER,</span><br><span class="line">      password: process.env.DB_PASSWORD,</span><br><span class="line">      database: process.env.DB_DATABASE + &apos;_testing&apos;,</span><br><span class="line">      charset: &apos;utf8mb4&apos;,</span><br><span class="line">      collate: &apos;utf8mb4_unicode_ci&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    migrations: &#123;</span><br><span class="line">      directory: &apos;./src/db/migrations&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    seeds: &#123;</span><br><span class="line">      directory: &apos;./src/db/seeds/dev&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  development: &#123;</span><br><span class="line">    client: &apos;mysql&apos;,</span><br><span class="line">    debug: false,</span><br><span class="line">    connection: &#123;</span><br><span class="line">      host: process.env.DB_HOST,</span><br><span class="line">      port: process.env.DB_PORT,</span><br><span class="line">      user: process.env.DB_USER,</span><br><span class="line">      password: process.env.DB_PASSWORD,</span><br><span class="line">      database: process.env.DB_DATABASE + &apos;_development&apos;,</span><br><span class="line">      charset: &apos;utf8mb4&apos;,</span><br><span class="line">      collate: &apos;utf8mb4_unicode_ci&apos;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    migrations: &#123;</span><br><span class="line">      directory: &apos;./src/db/migrations&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    seeds: &#123;</span><br><span class="line">      directory: &apos;./src/db/seeds/dev&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  production: &#123;</span><br><span class="line">    client: &apos;mysql&apos;,</span><br><span class="line">    debug: false,</span><br><span class="line">    connection: &#123;</span><br><span class="line">      host: process.env.DB_HOST,</span><br><span class="line">      port: process.env.DB_PORT,</span><br><span class="line">      user: process.env.DB_USER,</span><br><span class="line">      password: process.env.DB_PASSWORD,</span><br><span class="line">      database: process.env.DB_DATABASE + &apos;_production&apos;,</span><br><span class="line">      charset: &apos;utf8mb4&apos;,</span><br><span class="line">      collate: &apos;utf8mb4_unicode_ci&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    migrations: &#123;</span><br><span class="line">      directory: &apos;./src/db/migrations&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="引入配置，初始化-knex"><a href="#引入配置，初始化-knex" class="headerlink" title="引入配置，初始化 knex"></a>引入配置，初始化 <code>knex</code></h2><p>创建 <code>/db/db.js</code> 作为全局的 <code>db</code> 对象，数据的增删改查都通过 <code>db</code> 对象进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var environment = process.env.NODE_ENV || &apos;development&apos;; // 判断当前的开发环境</span><br><span class="line">var config = require(&apos;../../knexfile.js&apos;)[environment]; // 根据开发环境读取相应的配置</span><br><span class="line"></span><br><span class="line">module.exports = require(&apos;knex&apos;)(config); // 初始化 knex 并且导出改模块</span><br></pre></td></tr></table></figure><h2 id="migrations-和-seeds"><a href="#migrations-和-seeds" class="headerlink" title="migrations 和 seeds"></a>migrations 和 seeds</h2><h3 id="migrations"><a href="#migrations" class="headerlink" title="migrations"></a>migrations</h3><p><code>migrations</code> 允许你定义数据库的模块，所以使得数据库升级变得简单。<code>migrations CLI</code> 被包含在 <code>kenx</code> 中，请全局安装 <code>$ npm install knex -g</code></p><p><code>migrations</code>  依赖于 <code>knexfile</code>,请提前配置好， 创建 <code>/db/migrations</code> 目录。</p><p><strong>创建 migrate</strong> </p><p><code>knex migrate:make migration_name</code></p><p><strong>修改 <code>/db/migrations/migration_name.js</code></strong> </p><p>其中 <code>up</code> 方法在 <code>migrate run</code> 的时候被执行，用户创建表，<code>down</code> 方法在 <code>migrate rallback</code> 被执行，执行表销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//I only want migrations, rollbacks, and seeds to run when the NODE_ENV is specified</span><br><span class="line">//in the knex seed/migrate command. Knex will error out if it is not specified.</span><br><span class="line">if (!process.env.NODE_ENV) &#123;</span><br><span class="line">  throw new Error(&apos;NODE_ENV not set&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.up = function (knex, Promise) &#123;</span><br><span class="line">  return knex.schema.createTable(&apos;notes&apos;, function (table) &#123;</span><br><span class="line">    table.charset(&apos;utf8mb4&apos;);</span><br><span class="line">    table.collate(&apos;utf8mb4_unicode_ci&apos;);</span><br><span class="line">    </span><br><span class="line">    table.increments(&apos;id&apos;).primary();</span><br><span class="line">    table.integer(&apos;userId&apos;);</span><br><span class="line">    table.string(&apos;title&apos;);</span><br><span class="line">    table.text(&apos;content&apos;);</span><br><span class="line">    table.string(&apos;ipAddress&apos;);</span><br><span class="line">    </span><br><span class="line">    table.dateTime(&apos;updatedAt&apos;).defaultTo(knex.raw(&apos;NULL ON UPDATE CURRENT_TIMESTAMP&apos;));</span><br><span class="line">    table.dateTime(&apos;createdAt&apos;).notNullable().defaultTo(knex.raw(&apos;CURRENT_TIMESTAMP&apos;));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.down = function (knex, Promise) &#123;</span><br><span class="line">  //We never want to drop tables in production</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    return knex.schema.dropTableIfExists(&apos;notes&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始化数据库表</strong></p><p> 完成了 <code>migrate</code>，就可以进行创建表工作，执行 <code>migrate 的 up</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex migrate:latest</span><br></pre></td></tr></table></figure><p><strong>更新</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex migrate:make update migration_name</span><br></pre></td></tr></table></figure><p><strong>回滚</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex migrate:rollback</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 以上的命令都可以增加环境变量 例如 <code>NODE_ENV=development knex migrate:latest</code></p></blockquote><h3 id="seeds"><a href="#seeds" class="headerlink" title="seeds"></a>seeds</h3><p><code>seeds</code> 为种子，即数据的初始化，可以 <code>mock</code> 数据，插入到表中， 创建 <code>/db/seeds/dev</code> (对应不同环境<code>seeds</code>)</p><p><strong>创建 <code>seed</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex seed:make seed_users</span><br></pre></td></tr></table></figure><p><strong>编辑 <code>seed</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//I only want migrations, rollbacks, and seeds to run when the NODE_ENV is specified</span><br><span class="line">//in the knex seed/migrate command. Knex will error out if it is not specified.</span><br><span class="line">if (!process.env.NODE_ENV) &#123;</span><br><span class="line">  throw new Error(&apos;NODE_ENV not set&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//We don&apos;t want seeds to run in production</span><br><span class="line">if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">  throw new Error(&apos;Can\&apos;t run seeds in production&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const faker = require(&apos;faker&apos;);</span><br><span class="line">const bcrypt = require(&apos;bcrypt&apos;);</span><br><span class="line"></span><br><span class="line">exports.seed = async function (knex, Promise) &#123;</span><br><span class="line">  // 创建10条用户数据</span><br><span class="line">  let seedData = [];</span><br><span class="line">  </span><br><span class="line">  for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    let password = &apos;demopassword&apos;;</span><br><span class="line">    try &#123;</span><br><span class="line">      password = await bcrypt.hash(password, 12);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      throw new Error(&apos;PASSWORD_ENCRIPTION_ERROR&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (i === 0) &#123;</span><br><span class="line">      let testUser = &#123;</span><br><span class="line">        token: &apos;qwertyuiop&apos;,</span><br><span class="line">        firstName: &apos;DemoFirstName&apos;,</span><br><span class="line">        lastName: &apos;DemoLastName&apos;,</span><br><span class="line">        username: &apos;demousername&apos;,</span><br><span class="line">        email: &apos;demoemail@example.com&apos;,</span><br><span class="line">        password: password,</span><br><span class="line">      &#125;;</span><br><span class="line">      seedData.push(testUser);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let testUser = &#123;</span><br><span class="line">      token: faker.internet.password(),</span><br><span class="line">      firstName: faker.name.firstName(),</span><br><span class="line">      lastName: faker.name.lastName(),</span><br><span class="line">      username: faker.internet.userName(),</span><br><span class="line">      email: faker.internet.email(),</span><br><span class="line">      password: password,</span><br><span class="line">    &#125;;</span><br><span class="line">    seedData.push(testUser);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Deletes ALL existing entries</span><br><span class="line">  await knex(&apos;users&apos;).truncate();</span><br><span class="line">  //Insert users</span><br><span class="line">  await knex(&apos;users&apos;).insert(seedData);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>运行 <code>seed</code> 将数据插入到表中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex seed:run</span><br></pre></td></tr></table></figure><blockquote><p>⚠️  注意以上命令可以增加环境变量 ，例如 <code>NODE_ENV=development knex seed:run</code></p></blockquote><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>以上已经完成数据库的准备工作，一切正常则可使用 knex 操作数据库</p><p><strong>引入 <code>db</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import db from &apos;../db/db.js&apos;;</span><br></pre></td></tr></table></figure><p><strong>查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 检查数据库用户是否存在</span><br><span class="line">var [result] = await db(&apos;users&apos;).where(&#123;username: request.username&#125;).count(&apos;id as id&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 检查重复的email</span><br><span class="line">var [result] = await db(&apos;users&apos;).where(&#123;email: request.email&#125;).count(&apos;id as id&apos;);</span><br></pre></td></tr></table></figure><p><strong>增加</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [result] = await db(&apos;users&apos;).insert(request).returning(&apos;id&apos;);</span><br></pre></td></tr></table></figure><p><strong>修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await db(&apos;refresh_token&apos;).update(&#123;</span><br><span class="line">  isValid: false,</span><br><span class="line">  updateAt: dateFormat(new Date(), &apos;YYYY-MM-DD HH:mm:ss&apos;)</span><br><span class="line">&#125;).where(&#123;username: request.username&#125;);</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await db(&apos;notes&apos;).delete().where(&#123;id: this.id&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Knex-在-Koa2-中的应用&quot;&gt;&lt;a href=&quot;#Knex-在-Koa2-中的应用&quot; class=&quot;headerlink&quot; title=&quot;Knex 在 Koa2 中的应用&quot;&gt;&lt;/a&gt;Knex 在 Koa2 中的应用&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="nodejs" scheme="https://luoyec.cn/categories/nodejs/"/>
    
    
      <category term="knex" scheme="https://luoyec.cn/tags/knex/"/>
    
      <category term="node" scheme="https://luoyec.cn/tags/node/"/>
    
      <category term="数据库" scheme="https://luoyec.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>加盐密码哈希：如何正确使用</title>
    <link href="https://luoyec.cn/2019/01/14/cl4e29qfw008a989e1zdev25e/"/>
    <id>https://luoyec.cn/2019/01/14/cl4e29qfw008a989e1zdev25e/</id>
    <published>2019-01-14T06:30:09.730Z</published>
    <updated>2019-01-14T06:30:09.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加盐密码哈希：如何正确使用"><a href="#加盐密码哈希：如何正确使用" class="headerlink" title="加盐密码哈希：如何正确使用"></a>加盐密码哈希：如何正确使用</h1><p><a href="http://blog.jobbole.com/61872/" target="_blank" rel="noopener">参考：加盐密码哈希：如何正确使用</a></p><blockquote><p>⚠️ 不要自己写加密函数</p></blockquote><h2 id="为什么密码需要进行哈希？"><a href="#为什么密码需要进行哈希？" class="headerlink" title="为什么密码需要进行哈希？"></a>为什么密码需要进行哈希？</h2><p><code>hash(&quot;hello&quot;) = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code></p><p>哈希算法是一个单项函数，它可以将任意大小的数据转为定长的“指纹”，并且无法反向计算。数据源修改一点，哈希的结果也完全不同。</p><p><strong>基于哈希加密的账户系统，通常的认证流程</strong></p><ul><li>用户注册账号</li><li>密码经过哈希加密存储在数据库中，只要密码被写入磁盘，任何时候都不允许是明文</li><li>当用户登录时，从数据库去除已经加密的密码，和经过哈希的用户输入进行对比</li><li>如果哈希值相同或，用户获得登录权限，否则告知用户输入无效的登录信息</li><li>每当用有用户尝试登录，重复以上两步</li></ul><blockquote><p>✅ 保护密码的哈希函数和数据结构中的哈希函数是不同的，哈希表之类的哈希函数，目的是为了快速查找，而不是高安全性。只有加密的哈希函数才能保护密码安全，例如 <code>SHA256 SHA512 RipeMD WHIRLPOOL</code></p></blockquote><p><strong>如何破解哈希加密</strong></p><ul><li><p>字典攻击</p><p>字典攻击需要使用一个字典文件，它包含单词、短语、常用密码以及其他可能用作密码的字符串。其中每个词都是进过哈希后储存的，用它们和密码哈希比对，如果相同，这个词就是密码。</p></li><li><p>暴力攻击</p><p>暴力攻击会尝试每一个在给定长度下各种字符的组合。这种攻击会消耗大量的计算，也通常是破解哈希加密中效率最低的办法，但是它最终会找到正确的密码。    </p></li></ul><p>我们没有办法阻止字典攻击和暴击攻击，尽管可以降低它们的效率，但那也不是完全阻止。</p><h2 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h2><p>查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。</p><p>比如可以在密码中混入一段“随机”的字符串再进行哈希加密，这个被字符串被称作盐值。<strong>为了校验密码是否正确，我们需要储存盐值</strong>。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。</p><p>盐值并不需要保密，由于随机化了哈希值，查表法、反向查表法和彩虹表都不再有效。攻击者无法确知盐值，于是就不能预先计算出一个查询表或者彩虹表。这样每个用户的密码都混入不同的盐值后再进行哈希，因此反向查表法也变得难以实施。</p><p>⚠️<strong>实现加盐哈希的过程中通常会犯哪些错误</strong></p><ul><li>盐值重复<br>重复的盐值是无用功，因为不变的盐值每次hash的密码还是一样的，因此用户创建账户或每次修改密码时，都应该<strong>重新生成新的盐值进行加密</strong>。</li><li>短盐值<br>如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。<br>同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。<br>一个好的做法是使用和哈希函数输出的字符串等长的盐值。</li><li><p>两次哈希和组合哈希</p><p>人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。</p></li><li><p>哈希碰撞</p><p>即使在MD5这样脆弱的哈希函数中找到碰撞也需要耗费大量的计算，因此这样的碰撞“意外地”在实际中出现的可能性是很低的。</p></li></ul><h2 id="正确的使用哈希加密"><a href="#正确的使用哈希加密" class="headerlink" title="正确的使用哈希加密"></a>正确的使用哈希加密</h2><p><strong>基本要素：加盐哈希</strong></p><p>盐值应该使用<strong>基于加密的伪随机数生成器<code>（Cryptographically Secure Pseudo-Random Number Generator – CSPRNG）</code></strong>来生成。</p><p><code>CSPRNG</code> 专门被设计成用于加密，它能提供高度随机和无法预测的随机数。</p><blockquote><p>一个<strong>好的标准</strong>的是：盐值至少和哈希函数的输出一样长；盐值应该被储存和密码哈希一起储存在账户数据表中。</p></blockquote><p><strong>存储密码的步骤</strong></p><ul><li>使用 <code>CSPRNG</code> 生成一个长度足够的盐值</li><li>将盐值混入密码，并使用<strong>标准的</strong>加密哈希函数进行加密，如SHA25</li><li>把哈希值和盐值一起存入数据库中对应此用户的那条记录</li></ul><p><strong>校验密码的步骤</strong></p><ul><li>从数据库中取出用户的密码哈希值和盐值</li><li>将盐值混入用户输入的密码，并且使用相同的哈希函数进行加密</li><li>比较上一步中的结果和数据库中哈希值是否相同</li></ul><p><strong>在Web程序中，永远在服务器端进行哈希加密</strong></p><p>即使在web端进行了加密，也需要在服务端再次加密。</p><p>在web端加密需要注意：</p><ul><li>客户端加密不能代替HTTPS，如果浏览器和服务器之间的连接不是安全的。那么中间人可以修改js代码，删除加密函数，从而获取用户密码。</li><li><p>浏览器可以禁用js，你的程序应该检测JavaScript是否可用，如果答案为否，需要在服务端模拟客户端的加密。</p></li><li><p>客户端哈希同样需要加盐，很显然的办法就是向服务器请求用户的盐值，但是不要这么做。因为这给了坏蛋一个机会，能够在不知道密码的情况下检测用户名是否有效。既然你已经在服务端对密码进行了加盐哈希，那么在客户端把用户名（或邮箱）加上网站特有的字符串（如域名）作为盐值是可行的。</p></li></ul><h2 id="让密码更难破解"><a href="#让密码更难破解" class="headerlink" title="让密码更难破解"></a>让密码更难破解</h2><p><strong>慢哈希函数</strong></p><p>为了降低攻击者的效率，我们可以使用一种叫做<strong>密钥扩展</strong>的技术。这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。</p><p><strong>无法破解的哈希加密：密钥哈希和密码哈希设备</strong></p><p>只要攻击者可以检测对一个密码的猜测是否正确，那么他们就可以进行字典攻击或暴力攻击。因此下一步就是向哈希计算中增加一个<strong>密钥</strong>，只有知道这个密钥的人才能校验密码。有两种办法可以实现：将哈希值加密，比如使用AES算法；将密钥包含到哈希字符串中，比如使用密钥哈希算法<a href="http://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">HMAC</a>。</p><p><strong>当用户忘记密码的时候，怎样进行重置？</strong></p><p>大多数网站为那些忘记密码的用户发送电子邮件进行身份认证。首先，需要随机生成一个一次性的令牌，它直接关联到用户账户，然后将这个令牌混入到一个重置密码的连接中，发送到用户的电子邮箱。最后当用户点击这个包含有效令牌的链接时。提示他们可以重置新的密码。需要确保这个令牌只对一个账号有效，以防止攻击者获取到邮箱令牌后，用来重置其他用户的密码。</p><p>令牌必须在15分钟内使用，并且一旦被使用就立即失效。当用户重新请求令牌时，或用户登录成功时（说明他还记得密码），使原令牌失效也是一个好做法。如果一个令牌始终不过期，那么它一直可以用于入侵用户的帐号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加盐密码哈希：如何正确使用&quot;&gt;&lt;a href=&quot;#加盐密码哈希：如何正确使用&quot; class=&quot;headerlink&quot; title=&quot;加盐密码哈希：如何正确使用&quot;&gt;&lt;/a&gt;加盐密码哈希：如何正确使用&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.jobbo
      
    
    </summary>
    
      <category term="安全" scheme="https://luoyec.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="哈希" scheme="https://luoyec.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="加盐" scheme="https://luoyec.cn/tags/%E5%8A%A0%E7%9B%90/"/>
    
      <category term="安全" scheme="https://luoyec.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>把一个 Node.js web 应用程序给 Docker 化</title>
    <link href="https://luoyec.cn/2019/01/09/cl4e29qgb008v989et3kuggns/"/>
    <id>https://luoyec.cn/2019/01/09/cl4e29qgb008v989et3kuggns/</id>
    <published>2019-01-09T09:09:48.235Z</published>
    <updated>2019-01-09T09:09:48.235Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nodejs.org/zh-cn/docs/guides/nodejs-docker-webapp/" target="_blank" rel="noopener">原文：把一个 Node.js web 应用程序给 Docker 化</a></p><h1 id="把一个-Node-js-web-应用程序给-Docker-化"><a href="#把一个-Node-js-web-应用程序给-Docker-化" class="headerlink" title="把一个 Node.js web 应用程序给 Docker 化"></a>把一个 Node.js web 应用程序给 Docker 化</h1><p>本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 <em>非</em> 产品发布人员。此教程同样假定你有一个可以正常工作的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装</a>，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。</p><p>在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。</p><p>Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。</p><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"First Last &lt;first.last@example.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><p>然后，创建一个 <code>server.js</code> 文件，使用 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a> 框架定义一个 Web 应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello world\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。</p><h2 id="创建一个名称为-Dockerfile-的文件"><a href="#创建一个名称为-Dockerfile-的文件" class="headerlink" title="创建一个名称为 Dockerfile 的文件"></a>创建一个名称为 <code>Dockerfile</code> 的文件</h2><p>创建一个空文件，命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>用你最喜欢的文本编辑器打开这个 <code>Dockerfile</code>。</p><p>我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），<code>Node</code> 的版本号为 <code>8</code>。你可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker 站点</a> 获取相关镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /usr/src/app</span><br></pre></td></tr></table></figure><p>此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 <code>npm</code> 安装你的应用程序的所有依赖。请注意，如果你的 <code>npm</code> 的版本是 4 或者更早的版本，<code>package-lock.json</code> 文件将不会自动生成。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install app dependencies</span></span><br><span class="line"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span><br><span class="line"><span class="comment"># where available (npm@5+)</span></span><br><span class="line"><span class="keyword">COPY</span> package*.json ./</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"># If you are building your code for production</span><br><span class="line"># RUN npm install --only=production</span><br></pre></td></tr></table></figure><p>请注意，我们只是拷贝了 <code>package.json</code> 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">见此</a>。</p><p>在 Docker 镜像中使用 <code>COPY</code> 命令绑定你的应用程序：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br></pre></td></tr></table></figure><p>你的应用程序绑定的端口为 <code>8080</code>，所以你可以使用 <code>EXPOSE</code> 命令使它与 <code>docker</code> 的镜像做映射：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>最后但同样重要的事是，使用定义运行时的 <code>CMD</code> 定义命令来运行应用程序。这里我们使用最简单的 <code>npm start</code> 命令，它将运行 <code>node server.js</code> 启动你的服务器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span> [ "npm", "start" ]</span><br></pre></td></tr></table></figure><p>你的 <code>Dockerfile</code> 现在看上去是这个样子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /usr/src/app</span><br><span class="line"></span><br><span class="line"># Install app dependencies</span><br><span class="line"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span><br><span class="line"># where available (npm@5+)</span><br><span class="line">COPY package*.json ./</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"># If you are building your code for production</span><br><span class="line"># RUN npm install --only=production</span><br><span class="line"></span><br><span class="line"># Bundle app source</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [ "npm", "start" ]</span><br></pre></td></tr></table></figure><h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>在 <code>Dockerfile</code> 的同一个文件夹中创建一个 <code>.dockerignore</code> 文件，带有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。</p><h2 id="构建你的镜像"><a href="#构建你的镜像" class="headerlink" title="构建你的镜像"></a>构建你的镜像</h2><p>进入到 <code>Dockerfile</code> 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 <code>-t</code> 让你标记你的镜像，以至于让你以后很容易地用 <code>docker images</code> 找到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;your username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><p>Docker 现在将给出你的镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">REPOSITORY                      TAG        ID              CREATED</span><br><span class="line">node                            8          1934b0b038d1    5 days ago</span><br><span class="line">&lt;your username&gt;/node-web-app    latest     d64d3505b0d2    1 minute ago</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用 <code>-d</code> 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 <code>-p</code> 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app</span><br></pre></td></tr></table></figure><p>把你应用程序的输出打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get container ID</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print app output</span></span><br><span class="line">$ docker logs &lt;container id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">Running on http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果你需要进入容器中，请运行 <code>exec</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter the container</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container id&gt; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为测试你的应用程序，给出与 Docker 映射过的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">ID            IMAGE                                COMMAND    ...   PORTS</span><br><span class="line">ecce33b30ebf  &lt;your username&gt;/node-web-app:latest  npm start  ...   49160-&gt;8080</span><br></pre></td></tr></table></figure><p>在上面的例子中，在容器中 Docker 把端口号 <code>8080</code> 映射到你机器上的 <code>49160</code> 。</p><p>现在你可以使用 <code>curl</code>（如果需要的话请通过 <code>sudo apt-get install curl</code> 安装）调用你的程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:49160</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 12</span><br><span class="line">ETag: W/<span class="string">"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"</span></span><br><span class="line">Date: Mon, 13 Nov 2017 20:53:59 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。</p><p>你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容：</p><ul><li><a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener">官方 Node.js 的 Docker 镜像</a></li><li><a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">Node.js 基于 Docker 使用的最佳经验</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方 Docker 文档</a></li><li><a href="https://stackoverflow.com/questions/tagged/docker" target="_blank" rel="noopener">在 StackOverFlow 上有关 Docker 标记内容</a></li><li><a href="https://reddit.com/r/docker" target="_blank" rel="noopener">Docker Subreddit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://nodejs.org/zh-cn/docs/guides/nodejs-docker-webapp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文：把一个 Node.js web 应用程序给 Docker 化&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="node" scheme="https://luoyec.cn/tags/node/"/>
    
      <category term="docker" scheme="https://luoyec.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 StoryBook 搭建 UI 组件库</title>
    <link href="https://luoyec.cn/2018/10/26/cl4e29qfl007p989er6fh1x7s/"/>
    <id>https://luoyec.cn/2018/10/26/cl4e29qfl007p989er6fh1x7s/</id>
    <published>2018-10-26T08:49:20.998Z</published>
    <updated>2018-10-26T08:59:12.252Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://storybook.js.org/basics/guide-vue/" target="_blank" rel="noopener">storybook文档</a><br><a href="https://zhuanlan.zhihu.com/p/28239408" target="_blank" rel="noopener">Storybook 3.2 引入 Vue.js 支持</a><br><a href="https://release-3-4--storybooks-vue.netlify.com/?selectedKind=Welcome&amp;selectedStory=Welcome&amp;full=0&amp;addons=1&amp;stories=1&amp;panelRight=0&amp;addonPanel=storybook%2Fstories%2Fstories-panel" target="_blank" rel="noopener">一个完整的Vue例子</a></p><h1 id="使用-StoryBook-搭建-UI-组件库"><a href="#使用-StoryBook-搭建-UI-组件库" class="headerlink" title="使用 StoryBook 搭建 UI 组件库"></a>使用 StoryBook 搭建 UI 组件库</h1><p><code>StoryBook</code> 为UI组件开发提供开发环境，你可有实现不同状态下的<code>UI</code>可视化，并且可以实现交互。</p><h2 id="实现-Vue-UI-组件库"><a href="#实现-Vue-UI-组件库" class="headerlink" title="实现 Vue UI 组件库"></a>实现 Vue UI 组件库</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p><code>vue init webpack my-vue-project. // 通过 vue cli 初始化项目</code></p><p><code>cd my-vue-project</code></p><p><code>npm i -g @storybook/cli  // 全局安装 storybook</code></p><p><code>getstorybook  // 生成</code></p><p><code>npm run storybook //运行</code> </p><h3 id="Writing-Stories"><a href="#Writing-Stories" class="headerlink" title="Writing Stories"></a>Writing Stories</h3><p>我们在 src/component 文件夹下添加简单的按钮组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"button-styles"</span> @click=<span class="string">"onClick"</span>&gt;</span><br><span class="line">    &lt;slot&gt;Fallback Content&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name: 'my-button',</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      onClick () &#123;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .button-styles &#123;</span><br><span class="line">    border: 1px solid #eee;</span><br><span class="line">    border-radiuas: <span class="number">3</span>px;</span><br><span class="line">    background-color: #FFFFFF;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    font-size: <span class="number">15</span>pt;</span><br><span class="line">    padding: <span class="number">3</span>px <span class="number">10</span>px;</span><br><span class="line">    margin: <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 src/stories 目录下，可以利用 Storybook 提供的接口注册 Story:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; storiesOf &#125; <span class="keyword">from</span> <span class="string">'@storybook/vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; action &#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; linkTo &#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-links'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyButton <span class="keyword">from</span> <span class="string">'../component/MyButton.vue'</span>;</span><br><span class="line"></span><br><span class="line">storiesOf(<span class="string">'Button'</span>, <span class="built_in">module</span>)</span><br><span class="line">  .add(<span class="string">'with text'</span>, () =&gt; (&#123;</span><br><span class="line">    components: &#123; MyButton &#125;,</span><br><span class="line">    template: <span class="string">'&lt;my-button @click="action"&gt;Hello Button&lt;/my-button&gt;'</span>,</span><br><span class="line">    methods: &#123; <span class="attr">action</span>: action(<span class="string">'clicked'</span>) &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line">  .add(<span class="string">'with some emoji'</span>, () =&gt; (&#123;</span><br><span class="line">    components: &#123; MyButton &#125;,</span><br><span class="line">    template: <span class="string">'&lt;my-button @click="action"&gt;😀 😎 👍 💯&lt;/my-button&gt;'</span>,</span><br><span class="line">    methods: &#123; <span class="attr">action</span>: action(<span class="string">'clicked'</span>) &#125;,</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwlpzbuntmj30oc0hcab7.jpg" alt="image-20181026164700767"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StoryBook</code> 可以在原有的项目上进行构建，是独立的，并不影响原有项目；</p><p>更多的是作为单独的UI组件库使用，实现UI可视化，交互，日志输出，文档输出等功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://storybook.js.org/basics/guide-vue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;storybook文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.co
      
    
    </summary>
    
      <category term="工程化" scheme="https://luoyec.cn/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="storybook" scheme="https://luoyec.cn/tags/storybook/"/>
    
      <category term="UI组件库" scheme="https://luoyec.cn/tags/UI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入了解合并操作(转)</title>
    <link href="https://luoyec.cn/2018/10/23/cl4e29qgr009n989e2whso2z2/"/>
    <id>https://luoyec.cn/2018/10/23/cl4e29qgr009n989e2whso2z2/</id>
    <published>2018-10-23T06:57:42.774Z</published>
    <updated>2018-10-23T06:57:51.860Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase" target="_blank" rel="noopener">原文</a></p><p>要点：</p><ul><li>合并的发生了什么</li><li>rebase 合并</li><li>rebase 合并的缺点（修改了历史）</li></ul><h2 id="深入了解合并操作-转"><a href="#深入了解合并操作-转" class="headerlink" title="深入了解合并操作(转)"></a>深入了解合并操作(转)</h2><p>在你进入 rebase 这个主题前，我们有必要来再次探讨一下更多关于合并操作的细节。当 Git 执行一个合并时，它实际上会查找三个提交：</p><ul><li>(1)共同的原始提交<br>如果你在项目中查看两个分支的历史，它们总是会出自于一次共同的提交，那么在当时的时间点上，这两个分支还是拥有相同的内容。之后它们就开始有了差别。</li><li>(2) + (3) 两个分支的最终点<br>合并操作的目的就是把两个分支的最新状态结合起来。因此他们各自的最新版本是有特殊含义的。</li></ul><p>结合这三个提交后得到的结果就是我们整合的目标。</p><h2 id="快进或合并提交"><a href="#快进或合并提交" class="headerlink" title="快进或合并提交"></a>快进或合并提交</h2><p>一种最简单的情况是，在其中的一个分支上没有任何一个新的改动提交发生。那么在它之前的最后一次提交就仍然还是那个共同的原始提交。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/starting-situation-fast-forward.gif" alt="img"></p><p>在这种情况下，执行整合操作就非常简单了。 Git 仅仅需要添加所有那些在另外一个分支上的新提交就可以了。在 Git 中，这种最简单的整合操作我们称之为 “快进（fast-forward）”合并。之后两个分支就拥有了完全相同的历史。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/end-situation-fast-forward.gif" alt="img"></p><p>但是在大多数情况下，两个分支都会有自己不同的发展轨迹。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/starting-situation-merge-commit.gif" alt="img"></p><p>为了完成整合，Git 会需要创建一个新的提交来含括它们之间的差异，这就是整合提交（merge commit）。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/end-situation-merge-commit.gif" alt="img"></p><h2 id="手工提交与合并提交"><a href="#手工提交与合并提交" class="headerlink" title="手工提交与合并提交"></a>手工提交与合并提交</h2><p>通常情况下，提交都是由手工精心创建的。这样也就能更好地保证一次提交只涉及一个关联改动，并且能更好地注释这个提交。</p><p>一个合并提交就不同了，它不是由开发人员手动创建的，而是由 Git 自动生成的。它也不涉及一个关联改动，其目的只是连接两个分支，就像节点一样。如果之后想要了解某个合并操作，你只需要查看这两个分支的历史记录和它们相应的提交树（version tree）。</p><h2 id="Rebase-整合"><a href="#Rebase-整合" class="headerlink" title="Rebase 整合"></a>Rebase 整合</h2><p>有些人并不喜欢使用这种自动合并提交。相反，他们希望项目拥有一个单一的历史发展轨迹。比如一条直线。在历史纪录上没有迹象表明在某些时间它被分成过多个分支。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/end-situation-rebase.gif" alt="img"></p><p>现在就让我们一步一步地了解一下 rebase 操作吧！仍然来使用前面的例子：我们想合并分支 B 到 分支 A 中，但是这次使用 rebase 操作。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/starting-situation-rebase.gif" alt="img"></p><p>使用下面这个非常的简单的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase branch-B</span><br></pre></td></tr></table></figure><p>首先，Git 会 “撤销” 所有在分支 A 上的那些在与分支 B 的共同提交之后发生的提交。当然，Git 不会真的放弃这些提交，其实你可以把这些撤销的提交想像成 “<em>被暂时地存储</em>” 到另外的一个地方去了。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/rebase-step-1.gif" alt="img"></p><p>接下来它会整合那些在分支 B（这个我们想要整合的分支）上的还未整合的提交到分支 A 中。在这个时间点，这两个分支看起来会是一模一样的。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/rebase-step-2.gif" alt="img"></p><p>最后，那些在分支 A 的新的提交（也就是第一步中自动撤销掉的那些提交）会被重新应用到这个分支上，但是在不同的位置上，在那些从分支 B 被整合过来的提交之后，它们就被 <em>re-based</em> 了。<br>整个项目开发轨迹看起来就像发生在一条直线上。相对于一个合并提交，rebase 包括了所有的组合变化，最原始的提交结构会被保留下来。</p><p><img src="https://www.git-tower.com/learn/content/01-git/01-ebook/cn/01-command-line/05-advanced-topics/04-rebase/rebase-step-3.gif" alt="img"></p><h2 id="Rebase-存在的陷阱"><a href="#Rebase-存在的陷阱" class="headerlink" title="Rebase 存在的陷阱"></a>Rebase 存在的陷阱</h2><p>当然，使用 rebase 操作不会是永远一帆风顺的。很有可能会搬起石头砸自己的脚，因此你不能忽视一个重要的事实：<strong>rebase 会改写历史记录</strong>。</p><p>你有可能已经注意到了，在被 rebase 操作之后的版本中，提交 “C3*” 存在一个新添加的星号。这是因为，尽管这个提交的内容和 “C3” 完全一样，但是它实际上是一个不同的提交。这样做的原因是，它现在有一个新的源提交 C4（在最初创建 C3 时的源提交是 C1）。</p><p>一个提交仅仅包括很少的属性，比如作者，日期，变动和谁是它的父提交。如果改变其中任何一个信息，就必须创建一个全新的提交。当然，新的提交也会拥有一个新的 hash ID 。</p><p>如果还仅仅只是操作那些尚未发布的提交，重写历史记录本身也没有什么很大的问题。但是如果你重写了已经发布到公共服务器上的提交历史，这样做就非常危险了。其他的开发人员可能这时已经在最原始的提交 C3 上开始工作，并使它成为了一些新提交中不可或缺的部分，而现在你却把 C3 的改动设置到了另一个时间点（就是那个新的 C3*）。除此之外，通过rebase 操作，这个原始的 C3 还被删除掉了，这将是非常可怕的……</p><p>因此你应该只使用 rebase 来清理你的本地工作，千万不要尝试着对那些已经被发布的提交进行这个操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要
      
    
    </summary>
    
      <category term="Vuegit" scheme="https://luoyec.cn/categories/Vuegit/"/>
    
    
      <category term="git" scheme="https://luoyec.cn/tags/git/"/>
    
      <category term="rebase" scheme="https://luoyec.cn/tags/rebase/"/>
    
      <category term="merge" scheme="https://luoyec.cn/tags/merge/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest</title>
    <link href="https://luoyec.cn/2018/10/17/cl4e29qee005f989ebotzzchp/"/>
    <id>https://luoyec.cn/2018/10/17/cl4e29qee005f989ebotzzchp/</id>
    <published>2018-10-17T08:06:20.966Z</published>
    <updated>2018-10-23T06:59:40.754Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">阮一峰 XMLHttpRequest Level 2 使用指南</a></p><p><a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="noopener">你真的会使用XMLHttpRequest吗？</a></p><h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><h2 id="XMLHttpRequest的发展历程"><a href="#XMLHttpRequest的发展历程" class="headerlink" title="XMLHttpRequest的发展历程"></a><code>XMLHttpRequest</code>的发展历程</h2><p><code>XMLHttpRequest</code>一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了<a href="https://www.w3.org/TR/XMLHttpRequest/" target="_blank" rel="noopener"><code>XMLHttpRequest</code>标准</a>。<code>XMLHttpRequest</code>标准又分为<code>Level 1</code>和<code>Level 2</code>。<br><code>XMLHttpRequest Level 1</code>主要存在以下缺点：</p><ul><li>受同源策略的限制，不能发送跨域请求；</li><li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li><li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li></ul><p>那么<code>Level 2</code>对<code>Level 1</code> 进行了改进，<code>XMLHttpRequest Level 2</code>中新增了以下功能：</p><ul><li>可以发送跨域请求，在服务端允许的情况下；</li><li>支持发送和接收二进制数据；</li><li>新增formData对象，支持发送表单数据；</li><li>发送和获取数据时，可以获取进度信息；</li><li>可以设置请求的超时时间；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰 XMLHttpReque
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="XMLHttpRequest" scheme="https://luoyec.cn/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码解析-响应式原理（计算属性、监听属性、组件更新）</title>
    <link href="https://luoyec.cn/2018/08/24/cl4e29qe90056989eijxpvfge/"/>
    <id>https://luoyec.cn/2018/08/24/cl4e29qe90056989eijxpvfge/</id>
    <published>2018-08-24T08:20:55.943Z</published>
    <updated>2018-08-24T08:21:01.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue源码解析-响应式原理（计算属性、监听属性、组件更新）"><a href="#Vue源码解析-响应式原理（计算属性、监听属性、组件更新）" class="headerlink" title="Vue源码解析-响应式原理（计算属性、监听属性、组件更新）"></a>Vue源码解析-响应式原理（计算属性、监听属性、组件更新）</h1><h2 id="计算属性-amp-amp-监听属性"><a href="#计算属性-amp-amp-监听属性" class="headerlink" title="计算属性&amp;&amp;监听属性"></a>计算属性&amp;&amp;监听属性</h2><ul><li>了解计算属性实现原理</li><li>了解监听属性实现原理和几种配置</li><li>了解各自的适用场景</li></ul><h3 id="计算属性实现原理"><a href="#计算属性实现原理" class="headerlink" title="计算属性实现原理"></a>计算属性实现原理</h3><blockquote><p> 类型：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></p></blockquote><p>在 <code>computed</code> 中可以使用函数也可以使用对象，如果使用对象必须有 <code>getter</code> 属性。<br>在 <code>computed</code> 中定义的键值不能喝 <code>data</code>、<code>props</code> 中的重复，否则报错。</p><p><strong>何时开始计算？</strong><br>在组件定义的之前完成 <code>computed</code> 的创建，此时不会开始计算，而是在 <code>render</code> 中触发了 <code>getter</code> 时触发计算。</p><blockquote><p>📌 如果计算属性的值没有改变，不会触发 <code>dep.notify</code> 通知数据更新，不会触发重新渲染。</p></blockquote><h3 id="监听属性实现原理"><a href="#监听属性实现原理" class="headerlink" title="监听属性实现原理"></a>监听属性实现原理</h3><p><code>new watcher</code> 中收集依赖，不同的选项，收集依赖的方式不一样。</p><blockquote><p>类型：<code>{ [key: string]: string | Function | Object | Array }</code><br>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 <code>watch</code> 对象的每一个属性。</p></blockquote><ul><li><p>选项：<code>immediate</code></p><p>  在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 `a` 的当前值触发回调</span></span><br></pre></td></tr></table></figure></li><li><p>选项：<code>deep</code><br>  为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> 。注意监听数组的变动不需要这么做。</p><p>  递归对象，收集每一个属性的依赖，实现数据监听。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// callback is fired</span></span><br></pre></td></tr></table></figure></li><li><p>选项： <code>sync</code><br>  <code>sync：true</code> 数据改变时，同步执行回调，会优先执行该 <code>watch</code></p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>计算属性适合在模板渲染中，适合简单的逻辑，某个值是依赖了其他响应式对象甚者是计算属性而来的；</p><p>监听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p><h2 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h2><p>渲染 <code>watcher</code>： 在数据更新的时候出发更新更是，触发 <code>render</code>， 生成 <code>VNode</code> ，<code>update</code> 更新到 <code>DOM</code>。</p><p>组件更新的过程核心就是新旧 <code>vnode diff</code>，对新旧节点相同以及不同的情况分别做不同的处理。<br>新旧节点不同的更新流程是创建新节点-&gt;更新父占位符节点-&gt;删除旧节点；<br>而新旧节点相同的更新流程是去获取它们的 <code>children</code>，根据不同情况做不同的更新逻辑。<br>最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 <code>updateChildren</code> 逻辑</p><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1535098447023.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue源码解析-响应式原理（计算属性、监听属性、组件更新）&quot;&gt;&lt;a href=&quot;#Vue源码解析-响应式原理（计算属性、监听属性、组件更新）&quot; class=&quot;headerlink&quot; title=&quot;Vue源码解析-响应式原理（计算属性、监听属性、组件更新）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Vue源码解析" scheme="https://luoyec.cn/categories/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="响应式" scheme="https://luoyec.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码解析-响应式原理</title>
    <link href="https://luoyec.cn/2018/08/24/cl4e29qe70051989eysblt1fn/"/>
    <id>https://luoyec.cn/2018/08/24/cl4e29qe70051989eysblt1fn/</id>
    <published>2018-08-24T03:55:14.296Z</published>
    <updated>2018-08-24T03:55:32.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue源码解析-响应式原理"><a href="#Vue源码解析-响应式原理" class="headerlink" title="Vue源码解析-响应式原理"></a>Vue源码解析-响应式原理</h1><p>原理图：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1534992505279.jpg" alt=""></p><p>数据变化到 <code>DOM</code> 变化，前端开发工作</p><ul><li>数据渲染到界面</li><li>处理用户交互</li></ul><h2 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h2><p><code>Vue.js</code> 实现响应式的核心是利用了 <code>ES5</code> 的 <code>Object.defineProperty</code>，这也是为什么 <code>Vue.js</code> 不能兼容 <code>IE8</code> 及以下浏览器的原因，<code>Object.defineProperty</code> 在对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p><p>其中最关键的是实现了</p><ul><li><code>getter</code>，当访问属性的时候触发，依赖收集</li><li><code>setter</code>，当修改属性的时候触发，通知更新</li></ul><blockquote><p>⚠️ 对象以及对象嵌套的对象都会被添加为响应式对象。</p></blockquote><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>代理的作用是把 <code>props</code> 和 <code>data</code> 上的属性代理到 vm 实例上，这也就是为什么比如我们定义了如下 <code>props</code>，却可以通过 <code>vm</code> 实例访问到它。</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><code>observe</code> 方法的作用就是给非 <code>VNode</code> 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>Observer</code> 是一个类，它的作用是给对象的属性添加 <code>getter</code> 和 <code>setter</code>，用于依赖收集和派发更新。</p><p>在它的构造函数中会执行 <code>this.walk(value)</code>，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>defineReactive</code> 方法是给对象动态添加 <code>getter</code>、<code>setter</code>，</p><p>函数最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 <code>getter</code> 和 <code>setter</code>。</p><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>响应式对象 <code>getter</code> 相关的逻辑就是做依赖收集，<code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 的实例，在 <code>get</code> 函数中通过 <code>dep.depend</code> 做依赖收集。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p><code>Dep</code> 是 <code>depend</code> 的缩写，是整个 <code>getter</code> 依赖收集的核心，在 <code>getter</code> 方法中，通过 <code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 的实例，然后通过 <code>dep.depend</code> 做依赖收集。</p><p><code>Dep</code> 有一个静态属性 <code>target</code>，这是当前唯一的全局 <code>Watcher</code>，因为同一时间只有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 数组。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * watcher 观察一个数据，当数据的值发生改变时执行回调方法，watcher也被用于  $watch()  * api 和 directives</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">this</span>.deps = []  <span class="comment">// 表示 Watcher 实例持有的 Dep 实例数组</span></span><br><span class="line"><span class="keyword">this</span>.newDeps = [] <span class="comment">// 表示 Watcher 实例持有的 Dep 实例数组</span></span><br><span class="line"><span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure><h3 id="清空依赖"><a href="#清空依赖" class="headerlink" title="清空依赖"></a>清空依赖</h3><p><code>Vue</code> 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 <code>b</code> 模板的时候去修改 <code>a</code> 模板的数据，<code>a</code> 数据订阅回调已经被移除，每次执行 <code>depend</code>， <code>render</code> 不会订阅 <code>v-if</code> 为 <code>false</code> 的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>依赖收集就是订阅数据变化的 <code>watcher</code> 的收集</li><li>依赖收集的目的是为了当这些响应式数据发送变化，触发它们的 <code>setter</code> 的时候，能知道应该通知哪里订阅者去做相应的逻辑处理</li></ul><h2 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h2><p><code>setter</code> 的逻辑有 2 个关键的点</p><ul><li><p>一个是 <code>childOb = !shallow &amp;&amp; observe(newVal)</code>，如果 <code>shallow</code> 为 <code>false</code> 的情况，会对新设置的值变成一个响应式对象；</p></li><li><p>另一个是 <code>dep.notify()</code>，通知所有的订阅者</p></li></ul><h3 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify()"></a>dep.notify()</h3><p>该方法是 <code>Dep</code> 实例的一个方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑非常简单，遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法。</p><blockquote><p>📌 每一个 <code>Vue</code> 的实例都有 <code>Watcher</code></p></blockquote><p>在 <code>update</code> 方法中，引入了一个队列，<code>update</code> 不会每次数据发生改变时都会触发 <code>watcher</code> 回调，而是将这些 <code>watcher</code> 先添加到一个队列中，然后再 <code>nextTick</code> 后再执行。</p><blockquote><p>😜 <code>nextTick</code> 可以理解为一个事件循环周期</p></blockquote><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>在数据更新的同时又触发了数据更新，比如在 一个 <code>computed</code> 中执行了 <code>data</code> 数据的修改，而 <code>data</code> 又依赖于 <code>computed</code>，这是 <code>Vue</code> 有机制限定最大更新数为 <code>100</code>，超过则报异常。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（<code>execution context stack</code>）。</p><p>（2）主线程之外，还存在一个”任务队列”（<code>task queue</code>）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p><p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p><p>（4）主线程不断重复上面的第三步。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1535005253509.jpg" alt=""></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 <code>DOM</code> 变化，我们就必须在 <code>nextTick</code> 后执行</p><p><code>Vue.js</code> 提供了 2 种调用 <code>nextTick</code> 的方式</p><ul><li>一种是全局 <code>API Vue.nextTick</code>，</li><li>一种是实例上的方法 <code>vm.$nextTick</code></li></ul><h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><ul><li>了解哪些数据变化不能被检测到</li><li>了解如何解决数据变化检测的问题以及其中的原理</li></ul><p>当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 <code>setter</code> 的，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:<span class="number">1</span>，</span><br><span class="line">aArray: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// vm.b 是非响应的</span></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line">aArray[<span class="number">1</span>] = <span class="number">1</span>  <span class="comment">// 直接修改数组也是非响应的</span></span><br></pre></td></tr></table></figure></p><h3 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h3><ul><li><p>参数：</p><ul><li><code>{Object | Array} target</code></li><li><code>{string | number} key</code></li><li><code>{any} value</code></li><li>返回值：设置的值。</li></ul></li><li><p>用法：</p><p>  向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 <code>Vue</code> 无法探测普通的新增属性 (比如 <code>this.myObject.newProperty = &#39;hi</code>‘)</p></li></ul><blockquote><p>⚠️ 注意对象不能是 <code>Vue</code> 实例，或者 <code>Vue</code> 实例的根数据对象。</p></blockquote><h3 id="数组的情况"><a href="#数组的情况" class="headerlink" title="数组的情况"></a>数组的情况</h3><p>操作数组时使用以下方法是可以检测到数组变化的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><code>Vue</code> 重写了 这些方法，如果有新值插入到数组中，就将这些新值变成响应式对象，并且再次调用 <code>ob.dep.notify()</code> 手动触发依赖通知（触发依赖收集）。</p><h3 id="Vue-delete"><a href="#Vue-delete" class="headerlink" title="Vue.delete"></a>Vue.delete</h3><p><code>Vue.delete( target, key )</code> 类似于 <code>Vue.set</code> 方法, 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue源码解析-响应式原理&quot;&gt;&lt;a href=&quot;#Vue源码解析-响应式原理&quot; class=&quot;headerlink&quot; title=&quot;Vue源码解析-响应式原理&quot;&gt;&lt;/a&gt;Vue源码解析-响应式原理&lt;/h1&gt;&lt;p&gt;原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="Vue源码解析" scheme="https://luoyec.cn/categories/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="响应式" scheme="https://luoyec.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="观察者" scheme="https://luoyec.cn/tags/%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码解析-组件化</title>
    <link href="https://luoyec.cn/2018/08/22/cl4e29qed005d989e2e0rttbl/"/>
    <id>https://luoyec.cn/2018/08/22/cl4e29qed005d989e2e0rttbl/</id>
    <published>2018-08-22T10:39:34.503Z</published>
    <updated>2018-08-22T10:39:39.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-源码解析-组件化"><a href="#Vue-源码解析-组件化" class="headerlink" title="Vue 源码解析-组件化"></a>Vue 源码解析-组件化</h1><p><code>Vue</code> 其中一个核心思想是组件化，把页面拆分成多个组件，组件是可复用的 <code>Vue</code> 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p><h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 这里的 h 是 createElement 方法</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>createComponent</code>最终会调用 <code>_createElement</code> 方法， 通过判断传入的参数是否是组件，而选择使用 <code>createComponent</code> 方法创建一个 <code>VNode</code>。</p><blockquote><p>源码： src/core/vdom/create-component.js</p></blockquote><p>该方法针对组件渲染有三个关键步骤：</p><p><strong>构造子类构造函数</strong><br><code>mergeOptions</code> 方法将 <code>Vue</code> 构造函数的 <code>options</code> 和用户传入的 <code>options</code> 合并到同一层，到 <code>vm.$options</code> 上</p><p><code>Vue.extend</code> 的作用就是将一个纯对象转换成一个继承于 <code>Vue</code> 的构造器 <code>Sub</code> 并返回。<br>并且对 <code>Sub</code> 这个对象做了一些扩展，如扩展 <code>options</code>、全局 <code>API</code> 等；对配置中的 <code>props</code>、 <code>computed</code> 进行初始化工作；最后对 <code>Sub</code> 的构造函数缓存，避免多次 <code>extend</code> 同一个子组件的时候重复执行。</p><p><strong>安装组件的钩子函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node/ instal</span></span><br><span class="line">installComponentHooks(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span>(<span class="params">data: VNodeData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hooksToMerge[i];</span><br><span class="line">    <span class="keyword">const</span> existing = hooks[key];</span><br><span class="line">    <span class="keyword">const</span> toMerge = componentVNodeHooks[key];</span><br><span class="line">    <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 <code>VNode</code> 执行 <code>patch</code> 的过程中执行相关的钩子函数。</p><p><strong>实例化 VNode</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = Ctor.options.name || tag;</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">  <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">  data,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  context,</span><br><span class="line">  &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">  asyncFactory</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> vnode;</span><br></pre></td></tr></table></figure><p>最后通过 <code>new VNode</code> 实例化一个 <code>VNode</code> 并返回，与普通元素节点不同的是，组件的参数中是没有 <code>children</code> 的，在之后的 <code>patch</code> 过程中有关键性作用。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>上一节中 <code>createComponent</code> 创建的组件的 <code>VNode</code>，之后会执行 <code>vm._update</code>, 执行 <code>vm.__patch__</code> （包含<code>diff</code>算法）把 <code>VNode</code> 转换成真正的 <code>DOM</code> 节点。</p><p><code>patch</code> 的过程会调用 <code>createElm</code> 创建元素节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的初始化时不传 <code>el</code> 的，因为自己接管了 <code>vm$mount</code>.</p><p>在完成组件的整个 <code>patch</code> 过程后，最后执行 <code>insert(parentElm, vnode.elm, refElm)</code> 完成组件的 <code>DOM</code> 插入，如果组件 <code>patch</code> 过程中又创建了子组件，那么 <code>DOM</code> 的插入顺序是先子后父。</p><h2 id="配置合并"><a href="#配置合并" class="headerlink" title="配置合并"></a>配置合并</h2><p><code>new Vue</code> 通常有两种情况，一种是外部代码中主动调用 <code>new Vue(opitons)</code> 去实例化一个 <code>Vue</code> 对象，另一种是在组件过程中内部通过调用 <code>new Vue(opitons)</code> 实例化子组件。</p><p>无论哪种场景，都会首先执行 <code>merge options</code> 的逻辑。</p><p><strong>外部调用场景</strong></p><p>合并前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent created'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(childComp)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>合并后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  created: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">created</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'parent created'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  directives: &#123;&#125;,</span><br><span class="line">  filters: &#123;&#125;,</span><br><span class="line">  _base: <span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>组件场景</strong><br>组件的构造函数是通过 <code>Vue.extend</code> 继承自 <code>Vue</code>。其中最关键的逻辑是，将 <code>Vue.options</code> 和组件定义的对象合并到 <code>Sub.options</code> 中。</p><p>子组件初始化过程通过 <code>initInternalComponent</code> 方式要比外部初始化 <code>Vue</code> 通过 <code>mergeOptions</code> 的过程要快，合并完的结果保留在 <code>vm.$options</code> 中。</p><blockquote><p><code>options</code> 就是 <code>new vue</code> 大括号里的内容<br>使用 <code>mergeOptions</code> 合并配置，在 <code>Vue options</code> 扩展配置，之后执行<code>new Vue()</code></p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 <code>Vue</code> 实例（<code>new Vue</code>、子组件内部调用的 <code>new Vue</code>）被创建都需要经过一系列初始化过程。其中需要设置数据监听、编译模板、挂载实例到 <code>DOM</code>、在数据更新时更新 <code>DOM</code>。在这个过程中会调用相关的钩子方法。</p><h3 id="callHook"><a href="#callHook" class="headerlink" title="callHook"></a><strong>callHook</strong></h3><p>最终执行生命周期是通过调用 <code>callHook</code> 方法，根据传入的字符串 <code>hook</code>，去拿到 <code>vm.$options[hook]</code> 对应的回调函数数组，然后遍历执行，执行的时候把 <code>vm</code> 作为函数执行的上下文。</p><p>在之前的配置合并中，这些钩子函数都被合并到了 <code>vm.$options</code> 中并且是一个数组。</p><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p><strong>beforeCreate &amp; created</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initLifecycle(vm);</span><br><span class="line">  initEvents(vm);</span><br><span class="line">  initRender(vm);</span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>);</span><br><span class="line">  initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm);</span><br><span class="line">  initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性，之后我们会详细分析。那么显然 <code>beforeCreate</code> 的钩子函数中就不能获取到 <code>props</code>、<code>data</code> 中定义的值，也不能调用 <code>methods</code> 中定义的函数。</p><p>这两个方法执行完后，并没有渲染 <code>DOM</code>，此时是不能访问 <code>DOM</code>。 一把来说后端的接口请求，放在这里两个钩子函数中都可以，如果需要访问 <code>props</code>、<code>data</code> 等数据，就需要在 <code>created</code> 中执行了。</p><p><code>vue-router</code> 、 <code>vuex</code> 都混合了 <code>beforeCreatd</code> 钩子函数。</p><p><strong>beforeMount &amp; mounted</strong><br>这一对方法是以 <code>DOM</code> 挂载前后为分界线。</p><p>在执行 <code>vm._render</code> 方法前，执行了 <code>beforeMount</code>， 当在执行完 <code>vm.update</code> 方法后，把 <code>VNode patch</code> 到真是 <code>DOM</code> 后，执行了 <code>mouted</code> 钩子。</p><p><code>mounted</code> 钩子函数的执行顺序也是先子后父。</p><p><strong>beforeUpdate &amp; updated</strong><br><code>beforeUpdate</code> 的执行时机是在渲染 <code>Watcher 的 before</code> 函数中，组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。</p><p><code>update</code> 的执行时机是在 <code>flushSchedulerQueue</code> 函数调用的时候。</p><p>组件 <code>mount</code> 的过程中，会实例化一个渲染的 <code>Watcher</code> 去监听 <code>vm</code> 上的数据变化重新渲染。</p><p><strong>beforeDestroy &amp; destroyed</strong><br><code>beforeDestroy</code> 和 <code>destroyed</code> 钩子函数的执行时机在组件销毁的阶段</p><p><code>beforeDestroy</code> 钩子函数的执行时机是在 <code>$destroy</code> 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 <code>parent</code> 的 <code>$children</code> 中删掉自身，删除 <code>watcher</code>，当前渲染的 <code>VNode</code> 执行销毁钩子函数等，执行完毕后再调用 <code>destroy</code> 钩子函数。</p><p>在 <code>$destroy</code> 的执行过程中，它又会执行 <code>vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 <code>destroy</code> 钩子函数执行顺序是先子后父，和 <code>mounted</code> 过程一样。</p><p><strong>activated &amp; deactivated</strong><br><code>activated</code> 和 <code>deactivated</code> 钩子函数是专门为 <code>keep-alive</code> 组件定制的钩子。</p><p><strong>总结</strong><br>在 <code>created</code> 中可以访问到数据，在 <code>mounted</code> 钩子函数中可以访问到 <code>DOM</code>，<code>在destroyed</code> 钩子函数中做定时器销毁</p><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>在 <code>Vue.js</code> 中，除了它内置的组件如 <code>keep-alive</code>、<code>component</code>、<code>transition</code>、<code>transition-group</code> 等，其它用户自定义组件在使用前必须注册。</p><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>可以在任意地方使用，扩展在<code>Vue options</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>在当前组件内，扩展在 <code>Sub options</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 <code>Vue.options</code> 下，所以在所有组件创建的过程中，都会从全局的 <code>Vue.options.components</code> 扩展到当前组件的 <code>vm.$options.components</code> 下，这就是全局注册的组件能被任意使用的原因。</p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>开发中，为了减少首屏代码体积，往往把一些非首屏的组件设计成异步组件，按需加载。<br>本质是两次渲染，先渲染成注释节点，在组件加载成功了，在通过 <code>foreceRender</code> 重新渲染。</p><p><strong>普通函数异步组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">  <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>component</code> 的第二个参数传入的是函数， 普通组件传入的是对象。</p><blockquote><p>⚠️ 在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 <code>$forceUpdate</code> 可以强制组件重新渲染一次。</p></blockquote><p><strong>Promise 异步组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>判断是否是 <code>Promise</code> 的方法：<code>typeof res.then === &#39;function&#39;</code></p><p><strong>高级异步组件</strong><br>由于异步加载组件需要动态加载 <code>JS</code>，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计 <code>loading</code> 组件和 <code>error</code> 组件，并在适当的时机渲染它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue-源码解析-组件化&quot;&gt;&lt;a href=&quot;#Vue-源码解析-组件化&quot; class=&quot;headerlink&quot; title=&quot;Vue 源码解析-组件化&quot;&gt;&lt;/a&gt;Vue 源码解析-组件化&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt; 其中一个核心思想是组件化，
      
    
    </summary>
    
      <category term="Vue源码解析" scheme="https://luoyec.cn/categories/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="组件化" scheme="https://luoyec.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="patch" scheme="https://luoyec.cn/tags/patch/"/>
    
      <category term="异步组件" scheme="https://luoyec.cn/tags/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码解析-数据驱动</title>
    <link href="https://luoyec.cn/2018/08/21/cl4e29qeb0059989ev5sgpvne/"/>
    <id>https://luoyec.cn/2018/08/21/cl4e29qeb0059989ev5sgpvne/</id>
    <published>2018-08-21T08:06:57.691Z</published>
    <updated>2018-08-21T08:07:14.273Z</updated>
    
    <content type="html"><![CDATA[<p>资源列表：<br><a href="https://coding.imooc.com/learn/list/228.html" target="_blank" rel="noopener">慕课网：Vue.js 源码全方位深入解析</a><br><a href="https://ustbhuangyi.github.io/vue-analysis/data-driven/" target="_blank" rel="noopener">Vue.js 技术揭秘</a><br><a href="https://zhuanlan.zhihu.com/p/29450092" target="_blank" rel="noopener">知乎：染陌同学 VirtualDOM与diff(Vue实现)</a></p><h1 id="Vue源码解析-数据驱动"><a href="#Vue源码解析-数据驱动" class="headerlink" title="Vue源码解析-数据驱动"></a>Vue源码解析-数据驱动</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>现代前端框架抛弃里如使用 <code>JQuery</code> 等前端库直接修改 <code>DOM</code>，而是由数据驱动视图。<br>本章节主要研究 <code>Vue</code> 中模板和数据如果渲染成最红的 <code>DOM</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    message: 'Hello Vue!'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="new-Vue-发生了什么"><a href="#new-Vue-发生了什么" class="headerlink" title="new Vue 发生了什么"></a>new Vue 发生了什么</h2><p><code>new</code> 关键字在 <code>JavaScript</code> 中实例化一个对象，而 <code>Vue</code> 本质是一个 <code>Function</code> 模拟的类，在其上扩展静态方法和原型方法。</p><blockquote><p>源码，在<code>src/core/instance/index.js</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 <code>new Vue()</code> 调用的是 <code>this._init</code> 方法。</p><blockquote><p>源码：<code>src/core/instance/init.js</code>。</p></blockquote><p><strong><code>Vue</code> 初始化主要做了几件事</strong></p><ul><li>合并配置</li><li>初始化生命周期</li><li>初始化事件中心</li><li>初始化渲染</li><li>初始化 <code>data</code>、<code>props</code>、<code>computed</code>、<code>watcher</code> 等</li></ul><p>最后判断是否有 <code>el</code> 属性，如果有则调用 <code>vm.$mount</code> 方法挂载 <code>vm</code>，挂载的目标就是把模板渲染成最终的 <code>DOM</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 68</span></span><br><span class="line">   <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">     vm.$mount(vm.$options.el)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="el、template"><a href="#el、template" class="headerlink" title="el、template"></a>el、template</h3><p><a href="https://cn.vuejs.org/v2/api/#el" target="_blank" rel="noopener">Vue 文档</a></p><p><strong>el</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1534834313420.jpg" alt=""></p><p><strong>template</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1534834324670.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;hello-world&gt;&lt;/hello-world&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    Vue.component(&apos;hello-world&apos;, &#123;</span><br><span class="line">      template: &quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-实例挂载的实现"><a href="#Vue-实例挂载的实现" class="headerlink" title="Vue 实例挂载的实现"></a>Vue 实例挂载的实现</h2><p><code>$mount</code> 方法的实现是和平台、构建方式相关，不同平台如 <code>weex</code> 有不同的 <code>$mount</code> 实现，底层使用的 <code>API</code> 也不尽相同，这里研究 <code>compiler</code> 的实现。</p><blockquote><p>源码： src/platform/web/entry-runtime-with-compiler.js</p></blockquote><ul><li>对 <code>el</code> 做了限制，不能挂载到 <code>body</code>、<code>html</code> 根节点上</li><li><code>如果没有render</code> 方法，则会把 <code>el</code> 或者 <code>template</code> 字符串转成 <code>render</code> 方法，在 <code>Vue 2.0</code> 版本中，所有 <code>Vue</code> 的组件的渲染最终都需要 <code>render</code> 方法</li></ul><p><code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，</p><blockquote><p>源码：src/core/instance/lifecycle.js</p></blockquote><ul><li>先调用 <code>vm._render</code> 方法生成虚拟 <code>Node</code></li><li>再实例化一个渲染 <code>Watcher</code>，在它的回调函数中调用了 <code>updateComponent</code></li><li>最后调用 <code>vm._update</code> 更新 <code>DOM</code></li><li>最后的判断，<code>vm._isMounted</code> 为 <code>true</code>， 表示已经挂载，同时执行 <code>mounted</code> 钩子函数。</li></ul><blockquote><p>⚠️ 这里注意 <code>vm.$vnode</code> 表示 <code>Vue</code> 实例的父虚拟 <code>Node</code>，所以它为 <code>Null</code> 则表示当前是根 <code>Vue</code> 的实例。</p></blockquote><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>它用来把实例渲染成一个虚拟 <code>Node</code>，</p><blockquote><p>源码： src/core/instance/render.js</p></blockquote><p>Vue 文档中的 render 方法，第一个参数 createElement，用来创建 Vnode，模板中的写法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>等同于 <code>render</code> 函数的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">     attrs: &#123;</span><br><span class="line">        id: <span class="string">'app'</span></span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;, <span class="keyword">this</span>.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>📌 Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM</p></blockquote><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>为什么要使用虚拟 <code>DOM</code> ？<br>在文档中，一个真实的 <code>DOM</code> 元素是很庞大的，直接修改该元素成本很高，使用 虚拟 <code>DOM</code>，只需要维护一个真实 <code>DOM</code> 映射的对象，这要比维护真实 <code>DOM</code> 成本小得多。</p><p><code>Virtual DOM</code> 是用 <code>VNode</code> 这么一个 <code>Class</code> 去描述</p><blockquote><p>定义在 src/core/vdom/vnode.js</p></blockquote><p><code>VNode</code> 是对真实 <code>DOM</code> 的一种抽象描述，核心无非就是几个关键属性，标签名、数据、子节点、键值等。</p><p>映射到真实的 <code>DOM</code> 实际上要经历 <code>VNode</code> 的 <code>create</code>、<code>diff</code>、<code>patch</code> 等过程。</p><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p><code>Vue.js</code> 利用 <code>createElement</code> 方法创建 <code>VNode</code>，</p><blockquote><p>它定义在 src/core/vdom/create-elemenet.js 中：</p></blockquote><p>每个 <code>VNode</code> 都有 <code>children</code>，每个 <code>children</code> 也是一个 <code>VNode</code>，这样就形成了 <code>VNode tree</code>。</p><p>最后通过 <code>vm._update</code>， 将 <code>VNode</code> 渲染成真实的 <code>DOM</code> 并渲染出来。</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>该方法被调用的时机有两次，一次是首次渲染，一次是在数据更新的时候。</p><blockquote><p>源码： src/core/instance/lifecycle.js</p></blockquote><p>核心是调用了 <code>vm.__patch__</code>，该方法根据平台的不同有区别。</p><p>在该方法中实现了 diff 算法，具体参考： <a href="https://ustbhuangyi.github.io/vue-analysis/data-driven/" target="_blank" rel="noopener">Vue.js 技术揭秘</a></p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p><code>diff</code> 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历，所以时间复杂度只有 <code>O(n)</code>，是一种高效的算法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1534838321680.jpg" alt=""></p><p><strong>判断为同一个 VNode的依据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断两个VNode节点是否是同一个节点，需要满足以下条件</span></span><br><span class="line"><span class="comment">key相同</span></span><br><span class="line"><span class="comment">tag（当前节点的标签名）相同</span></span><br><span class="line"><span class="comment">isComment（是否为注释节点）相同</span></span><br><span class="line"><span class="comment">是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义</span></span><br><span class="line"><span class="comment">当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断当标签是&lt;input&gt;的时候，type是否相同</span></span><br><span class="line"><span class="comment">某些浏览器不支持动态修改&lt;input&gt;类型，所以他们被视为不同类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>如何进行对比？</strong></p><ul><li><p>1.如果新旧 <code>VNode</code> 都是静态的，同时它们的 <code>key</code> 相同（代表同一节点），并且新的 <code>VNode</code> 是 <code>clone</code> <code>或者是标记了once</code>（标记 <code>v-once</code> 属性，只渲染一次），那么只需要替换 <code>elm</code> 以及 <code>componentInstance</code> 即可。</p></li><li><p>2.新老节点均有 <code>children</code> 子节点，<code>则对子节点进行diff</code> 操作，调用 <code>updateChildren</code>，<code>这个updateChildren</code> 也是 <code>diff</code> 的核心。</p></li><li><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点 <code>DOM</code> 的文本内容，然后为当前 <code>DOM</code> 节点加入子节点。</p></li><li><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该 <code>DOM</code> 节点的所有子节点。</p></li><li><p>5.当新老节点都无子节点的时候，只是文本的替换。</p></li></ul><p>其他对比细节参考博客文章。</p><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>我们只是将虚拟 <code>DOM</code> 映射成了真实的 <code>DOM</code>。那如何给这些 <code>DOM</code> 加入 <code>attr</code>、<code>class</code>、<code>style</code> 等 <code>DOM</code> 属性呢？</p><p>需要在 <code>create</code> 以及 <code>update</code> 钩子被调用时更新 <code>DOM</code> 的 <code>attr</code> 属性即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板和数据如何渲染成最终的 <code>DOM</code> 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 <code>Vue</code> 到最终渲染的整个过程。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1534838168846.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源列表：&lt;br&gt;&lt;a href=&quot;https://coding.imooc.com/learn/list/228.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网：Vue.js 源码全方位深入解析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="Vue源码解析" scheme="https://luoyec.cn/categories/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="数据驱动" scheme="https://luoyec.cn/tags/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="虚拟DOM" scheme="https://luoyec.cn/tags/%E8%99%9A%E6%8B%9FDOM/"/>
    
      <category term="diff算法" scheme="https://luoyec.cn/tags/diff%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Object.defineProperty()</title>
    <link href="https://luoyec.cn/2018/08/17/cl4e29qdw004g989euw5fwdf4/"/>
    <id>https://luoyec.cn/2018/08/17/cl4e29qdw004g989euw5fwdf4/</id>
    <published>2018-08-17T03:11:06.085Z</published>
    <updated>2018-08-17T03:11:12.075Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a></p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与数据描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value : <span class="number">37</span>,</span><br><span class="line">  writable : <span class="literal">true</span>,</span><br><span class="line">  enumerable : <span class="literal">true</span>,</span><br><span class="line">  configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象o拥有了属性a，值为37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与存取描述符的示例</span></span><br><span class="line"><span class="keyword">var</span> bValue;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  set : <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">    bValue = newValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable : <span class="literal">true</span>,</span><br><span class="line">  configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b = <span class="number">38</span>;</span><br><span class="line"><span class="comment">// 对象o拥有了属性b，值为38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// o.b的值现在总是与bValue相同，除非重新定义o.b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据描述符和存取描述符不能混合使用</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"conflict"</span>, &#123;</span><br><span class="line">  value: <span class="number">0x9f91102</span>, </span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xdeadbeef</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 数据描述符和存取描述符不能混用</p></blockquote><h3 id="Writable-属性"><a href="#Writable-属性" class="headerlink" title="Writable 属性"></a>Writable 属性</h3><p>当 <code>writable</code> 属性设置为 <code>false</code> 时，该属性被称为“不可写”。它不能被重新分配。</p><p>⚠️普通模式不会抛出异常，严格模式抛出异常<code>“read-only”</code></p><h3 id="Enumerable-特性"><a href="#Enumerable-特性" class="headerlink" title="Enumerable 特性"></a>Enumerable 特性</h3><p> <code>enumerable</code> 定义了对象的属性是否可以在 <code>for...in</code> 循环和 <code>Object.keys()</code> 中被枚举。</p><h3 id="Configurable-特性"><a href="#Configurable-特性" class="headerlink" title="Configurable 特性"></a>Configurable 特性</h3><p><code>configurable</code> 特性表示对象的属性是否可以被删除，<code>以及除writable</code> 特性外的其他特性是否可以被修改。</p><h3 id="一般的-Setters-和-Getters"><a href="#一般的-Setters-和-Getters" class="headerlink" title="一般的 Setters 和 Getters"></a>一般的 Setters 和 Getters</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I alway return this string,whatever you have assigned'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myname = <span class="string">'this is my name string'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'myproperty'</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'I alway return this string,whatever you have assigned'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myproperty);</span><br><span class="line"><span class="comment">// 'this is my name string'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myname);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 语义化最佳实践</title>
    <link href="https://luoyec.cn/2018/06/26/cl4e29qcb0018989e4y5x7qih/"/>
    <id>https://luoyec.cn/2018/06/26/cl4e29qcb0018989e4y5x7qih/</id>
    <published>2018-06-26T10:08:24.092Z</published>
    <updated>2018-06-26T10:08:28.891Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://medium.com/beginners-guide-to-mobile-web-development/writing-accessible-html-5c8e99bf9944" target="_blank" rel="noopener">Are you Writing Accessible HTML?</a><br><a href="https://www.w3cplus.com/html5/semantics-tags.html" target="_blank" rel="noopener">HTML5 语义化 w3cplus</a></p><h1 id="HTML5-语义化最佳实践"><a href="#HTML5-语义化最佳实践" class="headerlink" title="HTML5 语义化最佳实践"></a>HTML5 语义化最佳实践</h1><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530005965493.jpg" alt=""></p><ul><li>使用 <code>a</code> 标签代替点击行为的 <code>span</code> 标签</li><li>使用 <code>button</code> 标签作为按钮</li><li>在表单元素中使用 <code>label</code></li><li>所有的 <code>img</code> 标签都应有有 <code>alt</code> 属性描述图标本身</li><li>修饰作用的 <code>img</code> 如 <code>loading.gif</code> 应有用空的 <code>alt=&quot;&quot;</code> 属性</li><li>焦点管理 - 使用 <code>tabindex</code> 控制 <code>tab</code> 键切换焦点的顺序 - 将 <code>tabindex</code> 置为 <code>-1</code> 可以避免 <code>tab</code> 键获取焦点</li></ul><h2 id="新元素"><a href="#新元素" class="headerlink" title="新元素"></a>新元素</h2><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p><code>mark</code> 元素对其内容赋予任何重要性，仅仅是突出显示。用于替代 <code>em</code> 或 <code>strong</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007424355.jpg" alt=""></p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007443683.jpg" alt=""></p><h3 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h3><p>元素可用于测量的标记，提供测量的最大值和最小值进行测量值的缩放。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007485291.jpg" alt=""></p><h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007508909.jpg" alt=""></p><h3 id="figure-与-figcaption"><a href="#figure-与-figcaption" class="headerlink" title="figure 与 figcaption"></a>figure 与 figcaption</h3><p><code>figure</code> 元素标记文档中的一个图像<br><code>figcaption</code> 元素被用来为 <code>figure</code> 元素定义标题。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007609322.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1530007618112.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://medium.com/beginners-guide-to-mobile-web-development/writing-accessible-html-5c8e99bf9944&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="HTML5" scheme="https://luoyec.cn/categories/HTML5/"/>
    
    
      <category term="语义化" scheme="https://luoyec.cn/tags/%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    
      <category term="图解" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 部署静态页面</title>
    <link href="https://luoyec.cn/2018/06/11/cl4e29qdq0044989ebcezrogq/"/>
    <id>https://luoyec.cn/2018/06/11/cl4e29qdq0044989ebcezrogq/</id>
    <published>2018-06-11T09:14:01.244Z</published>
    <updated>2018-06-11T09:14:07.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-部署静态页面"><a href="#Nginx-部署静态页面" class="headerlink" title="Nginx 部署静态页面"></a>Nginx 部署静态页面</h1><p>在前后端分离的项目中，前端经过编译生成的文件中，往往只包含一个 <code>index.html</code> 入口文件。可以利用 <code>Nginx</code> 进行简单配置就可以实现在部署到服务器端。</p><blockquote><p>🐸 如果是 <code>nodejs</code> 的项目可以利用 <code>pm2</code> 进行部署，如果是 <code>egg</code> 的项目可以利用 <code>egg</code> 的工具 <code>egg-scripts</code> 进行部署</p></blockquote><h2 id="Nginx-的全局配置"><a href="#Nginx-的全局配置" class="headerlink" title="Nginx 的全局配置"></a>Nginx 的全局配置</h2><p>通过 <code>yum</code> 安装 <code>Nginx</code> 的配置文件在 <code>/etc/nginx/nginx.conf</code> 下。</p><p>其中 <code>include /etc/nginx/default.d/*.conf;</code> 引入在目录下的所有配置文件，原则上每个配置文件对应一个静态页面文件。</p><blockquote><p>⚠️ <code>include</code> 的坑：<code>include</code> 的位置应该在第一个 server 块后面<br>⚠️ 权限问题导致的 403： 修改 <code>conf</code> 配置 <code>user</code> 字段为 <code>root</code>（默认是 <code>nginx</code> ）</p></blockquote><p><strong>完整的 nginx.conf 配置：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="comment"># include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="attribute">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">            <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate "/etc/pki/nginx/server.crt";</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key "/etc/pki/nginx/private/server.key";</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="default-conf-的配置"><a href="#default-conf-的配置" class="headerlink" title="default.conf 的配置"></a>default.conf 的配置</h2><p>在 <code>/etc/nginx/default.d</code> 目录下配置，新建文件，一个简单的文件模板如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /root/node-project/pm2test;</span><br><span class="line">        <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 注意这里只包含 <code>server</code> 块</p><h2 id="相关命令行"><a href="#相关命令行" class="headerlink" title="相关命令行"></a>相关命令行</h2><p><strong>检查配置文件是否配置正确</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p><strong>修改配置后，刷新配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><strong>杀死 nginx 进程，重启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 nginx</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p><strong>启动 nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>利用 <code>nginx</code> 反向代理可以解决前端开中的跨域问题，而不需要服务端配合。具体请参考：<a href="http://luoyec.cn/2017/11/18/cjh5m1vhr003gsz6pr58ed54r/">Nginx 反向代理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-部署静态页面&quot;&gt;&lt;a href=&quot;#Nginx-部署静态页面&quot; class=&quot;headerlink&quot; title=&quot;Nginx 部署静态页面&quot;&gt;&lt;/a&gt;Nginx 部署静态页面&lt;/h1&gt;&lt;p&gt;在前后端分离的项目中，前端经过编译生成的文件中，往往只包含一
      
    
    </summary>
    
      <category term="工程化" scheme="https://luoyec.cn/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="nginx" scheme="https://luoyec.cn/tags/nginx/"/>
    
      <category term="部署" scheme="https://luoyec.cn/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 快速入门与专业应用</title>
    <link href="https://luoyec.cn/2018/05/14/cl4e29qe5004y989ecvk6yphy/"/>
    <id>https://luoyec.cn/2018/05/14/cl4e29qe5004y989ecvk6yphy/</id>
    <published>2018-05-14T02:03:57.255Z</published>
    <updated>2018-05-14T02:09:43.470Z</updated>
    
    <content type="html"><![CDATA[<p>摘抄自： 《 Vue.js 前端开发- 快速入门与专业应用》</p><h1 id="Vue-js-快速入门与专业应用"><a href="#Vue-js-快速入门与专业应用" class="headerlink" title="Vue.js 快速入门与专业应用"></a>Vue.js 快速入门与专业应用</h1><h2 id="Vue-js-简介"><a href="#Vue-js-简介" class="headerlink" title="Vue.js 简介"></a>Vue.js 简介</h2><p><code>Vue.js</code> 的组件化理念和 <code>ReactJS</code> 异曲同工——“一切都是组件”，可以将任意封装好的代码注册成标签，例如:<code>Vue.component(&#39;example&#39;, Example)</code>，可以在模板中以 <code>&lt;example&gt;&lt;/ example&gt;</code> 的形式调用。</p><p><code>Vue.js</code> 的使用都是通过构造函数 <code>Vue({option})</code> 创建一个 <code>Vue</code> 的实例: <code>var vm = new Vue({})</code>。一个 <code>Vue</code> 实例相当于一个 <code>MVVM</code> 模式中的 <code>ViewModel</code>。</p><p>在实例化的时候，我们可以传入一个选项对象，包含数据、模板、挂载元素、方法、生 命周期钩子等选项。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525933032850.jpg" alt=""></p><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p><strong>模板</strong></p><p><code>el</code> :类型为字符串，<code>DOM</code> 元素或函数。其作用是为实例提供挂载元素。</p><p><code>template</code> :类型为字符串。默认会将 <code>template</code> 值替换挂载元素(即 <code>el</code> 值对应的元素)， 并合并挂载元素和模板根节点的属性(如果属性具有唯一性，类似 <code>id</code>，则以模板根节点为准)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="number">123</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script id=<span class="string">"tpl"</span> type=<span class="string">"x-template"</span>&gt;   &lt;div class='tpl'&gt;</span><br><span class="line">   &lt;p&gt;This is a tpl from script tag&lt;/p&gt;   &lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  var vm = new Vue(&#123;    el : '#app',</span></span><br><span class="line"><span class="string">   template : '#tpl'   &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>Vue</code> 实例中需要有一个根元素，模板的定义只能有一个根元素，建议模板定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"tpl"</span> type=<span class="string">"x-template"</span>&gt;</span><br><span class="line">  &#123;<span class="string">' '</span>&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tpl"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="tpl"&gt; ...&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 实例通过 <code>data</code> 属性定义数据，这些数据可以在实例对应的模板中进行绑定并使用。需要注意的是传入 data 是一个对象，那么 <code>Vue</code> 实例会代理起所有 <code>data</code> 对象中的所有属性，而不会对传入的对象进行深拷贝。</p><p>可以通过 <code>Vue</code> 实例 <code>vm</code> 中的 <code>$data</code> 来获取声明数据，需要注意的是，只有初始化传入的对象才是响应式的，在声明完实例后再增加的属性，将不会是响应式的</p><p><code>Vue</code> 推荐在初始化的时候将所有的变量都设定好，如果没有值，额可以用 <code>undefined</code> 或<code>null</code> 占位。</p><p>另外，组件的实例可以通过 props 获取数据，同 data ，也需要在初始化时预设好。<br>通过 <code>methods</code> 对象来定义方法，并使用 <code>v-on</code> 指令来监听 <code>DOM</code> 事件</p><p><code>Vue</code> 实例也支持自定义事件，可以在初始化时传入 <code>event</code> 对象，通过实例的 <code>$emit</code> 方法进行触发。这套机制常在组件间相互通信的情况中，例如子组件冒泡触发父组件事件方法，或者父组件广播某个事件，子组件对其进行监听等。（⚠️ <code>Vue 2.x</code> 中已经废弃 <code>events</code> 属性，不再支持事件广播，推荐直接使用 <code>Vue</code> 实例的全局方法 <code>$on()/$emit()</code>， 或者使用插件 <code>vuex</code> 来处理）</p><p><strong>生命周期</strong></p><p><code>Vue</code> 实例在创建时有一系列初始化步骤，例如建立数据观察，编译模板，创建数据绑定等，这些过程中，可以通过生命周期钩子函数<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p><ul><li><code>beforeCreate()</code> : 在实例开始初始化时同步调用，此时数据观测、事件都尚未初始化</li><li><code>created()</code>：在实例创建之后调用，此时已经完成数据绑定、事件方法，但尚未开始 <code>DOM</code> 编译，即未挂在到 <code>document</code></li><li><code>beforeMount()</code>:</li><li><code>mounted()</code>: 在编译结束时调用，此时指令已经生效，数据变化已经能触发 <code>DOM</code> 更新，但不保证 <code>$el</code> 已插入文档</li><li><code>beforeDestroy()</code>: 在开始销毁实例时调用，此时实例仍然有效</li><li><code>destroyed()</code>: 在实例被销毁之后调用，此时所有的绑定和实例指令都已经解绑，子实例也被销毁。</li><li><code>beforeUpdate()</code>: 在实例挂载之后，再次更新实例（例如更新 <code>data</code>）时会调用该方法，此时尚未更新 <code>DOM</code> 结构</li><li><code>updated()</code>: 在实例挂载之后，再次更新实例并在实例更新完 <code>DOM</code> 之后被调用</li><li><code>activated()</code>:2.0 新增的生命周期钩子，需要配合动态组件 <code>keep-live</code> 属性使用。在动态组件初始化渲染的过程中调用该方法。</li><li><code>deactivated()</code> :2.0 新增的生命周期钩子，需要配合动态组件 <code>keep-live</code> 属性使用。在动 态组件移出的过程中调用该方法。</li></ul><ul><li><p>数据绑定，<code>Vue</code> 的核心是一个响应式的数据绑定系统，简历绑定后， <code>DOM</code> 将和数据保持同步，这样就无需手动维护 <code>DOM</code>，使代码能够更加简洁易懂、提升效率。</p></li><li><p>指令，可以理解为当表达式的值发生改变时，会有些特殊行为作用到绑定的 <code>DOM</code> 上，指定通常直接书写在模板的 <code>HTML</code> 元素中，而为了有别于普通的属性， <code>Vue</code> 是带有前缀的 <code>v-</code> 属性</p></li><li><p>表单控件，<code>Vue</code> 中提供 <code>v-model</code> 的指令对表单元素进行双向绑定，在修改表单元素值的同时，实例 <code>vm</code> 中对应是属性值也会同时更新，反之亦然。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"message"</span> /&gt;</span><br><span class="line">&lt;span&gt;Your input is : &#123;&#123; message &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;label&gt;&lt;input type="radio" value="male" v-model="gender "&gt; 男 &lt;/</span>lable&gt;</span><br><span class="line">&lt;label&gt;&lt;input type="radio" value="female" v-model="gender "&gt; 女 &lt;/lable&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; gender &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ gender 值即为选中的 radio 元素的 value 值。</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 声明周期流程图中包含了模板的渲染顺序</p></blockquote><p><strong><code>Class</code> 与 <code>Style</code> 绑定</strong><br><code>class</code> 属性，我们绑定的数据可以是对象和数组，绑定修改的是元素的 <code>class</code> 属性，内联样式绑定，<code>style</code> 属性绑定数据的内联样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"alertStyle"</span>&gt;&lt;/div&gt; data : &#123;</span><br><span class="line">  alertStyle : &#123;</span><br><span class="line">   color : <span class="string">'red'</span>,</span><br><span class="line">   fontSize : <span class="string">'20px'</span>  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法，允许将多个样式绑定到同一个元素上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"[ styleObjectA, styleObjectB]"</span> .&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>自动添加前缀，在使用 <code>transform</code> 这类属性时，<code>v-bind:style</code> 会根据需要自动添加厂商前缀</p><p>条件渲染，<code>Vue.js</code> 提供 <code>v-if，v-show，v-else，v-for</code> 这几个指令来说明模板和数据间的逻辑关系，这基本就构成了模板引擎的主要部分。</p><p><code>template</code> 标签用法，<code>Vue.js</code> 提供了 <code>template</code> 标签，我们可以将指令作用到这个标 签上，但最后的渲染结果里不会有它。</p><p><strong>事件绑定与监听</strong><br>通过 <code>v-on</code> 可以绑定实例选项属性 <code>methods</code> 中的方法作为事件的处理器，<code>v-on</code>：后参数接受所有的原生事件名称。</p><p>同一元素上也可以通过 <code>v-on</code> 绑定多个相同事件函数，执行顺序为顺序执行<br><code>&lt;div v-on:click=&quot;sayFrom(&#39;first&#39;)&quot; v-on:click =&quot;sayFrom(&#39;second)&quot;&gt;</code></p><p><strong>修饰符</strong><br><code>Vue</code> 为指令 <code>v-on</code> 提供了多个修饰符，方便我们处理一些 <code>DOM</code> 事件的细节，并且修饰符可以串联使用</p><ul><li><code>.stop</code>: <code>event.stopPropagation()</code></li><li><code>.prevent</code>: <code>event.preventDefault()</code></li><li><code>.capture</code>: 使用 <code>capture</code> 模式添加事件监听器</li><li><code>.self</code>: 只当事件是从监听元素本身触发时才触发回调</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是 <code>Vue</code> 中一个重要的特性，重要提供一种机制将数据的变化映射为 <code>DOM</code> 行为。在 <code>Vue</code> 中通过数据驱动，一般情况不会直接修改 <code>DOM</code>，通过大量内置的指令进行 <code>DOM</code> 操作，也可以开发自定义指令。</p><ul><li><code>v-bind</code>: 主要用于动态绑定 <code>DOM</code> 元素属性，即属性实际的值是由 <code>vm</code> 实例中 <code>data</code> 属性提供的</li><li><code>v-model</code>: 用于表单控件</li><li><code>v-if / v-else/ v-show</code>: 展示对应模板内容</li><li><code>v-for</code>: 模板渲染</li><li><code>v-on</code>: 事件绑定</li><li><code>v-text</code>: 作用是更新元素的 <code>textContent</code>，闪现问题？⚠️</li><li><code>v-HTML</code>：作用是更新元素的 <code>innerHTML</code></li><li><code>v-el</code>：为 <code>DOM</code> 元素注册一个索引，使得可以直接访问 <code>DOM</code> 元素</li><li><code>v-ref</code>： 类似于 <code>v-el</code>，只不过这是作用域子组件上，实例可以通过 <code>$refs</code> 访问子组件</li><li><code>v-pre</code>：跳过编译这个元素和子元素，现实原始双花括号</li><li><code>v-cloak</code>：官方推荐可以和 <code>css</code> 规则 <code>[v-cloak]{ display :none }</code> 一起使用，可以隐藏未编译的 <code>Mustache</code> 标签直到实例准备完毕。<code>&lt;div v-cloak&gt;&lt;/div&gt;</code></li><li><code>v-once</code>: 用于标明元素或组件只渲染一次</li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器本质是一个函数，接受管道符前面的值作为初始值，同时也能接受额外的参数，返回值为经过处理后的输出值。多个过滤器可以串联。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA <span class="string">'arg1'</span> <span class="string">'arg2'</span> &#125;&#125; &#123;&#123; message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure><p>双向过滤器，在写回 <code>data</code> 绑定属性中的过滤器，成为双向过滤器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"price | cents"</span> &gt;</span><br><span class="line"><span class="comment">// 该过滤器的作用是处理价钱的转化，一般数据库中保存的单位都为分，避免浮点运算 Vue.filter('cents', &#123;</span></span><br><span class="line">  read : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (value / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">  write : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value * <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;   <span class="attr">el</span> : <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">   price : <span class="number">150</span>  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>过渡系统是 <code>Vue</code> 为 <code>DOM</code> 动画效果提供的一个特性，它能在元素从 <code>DOM</code> 中插入或移除时触发 <code>CSS</code> 过渡（<code>transition</code>）和动画（<code>animation</code>），也就是说在 <code>DOM</code> 元素发生变化时为其添加特定的 <code>class</code> 类名，从而产生过渡效果。除了 <code>CSS</code> 过渡外，<code>Vue.js</code> 的过渡系统也 支持 <code>javascript</code> 的过渡，通过暴露过渡系统的钩子函数，我们可以在 <code>DOM</code> 变化的特定时机对 其进行属性的操作，产生动画效果。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件注册 <code>var MyComponent = Vue.extend({ ... });</code>，这样我们获得了一个组件构造器，但现在无法直接使用这个组件，需要将组件注册到应用中。<code>Vue</code> 提供了两种注册方法，分别是全局注册和局部注册。</p><p>全局注册，需要在根实例初始化之前注册，这样才能使组件在任意实例中被使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent);</span><br></pre></td></tr></table></figure><p>对于组件的命名，<code>W3C</code> 规范是字母小写且包含一个短横杠“-”。</p><p>局部注册，限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;This is a child component&lt;/p&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; \</span></span><br><span class="line"><span class="string">   &lt;p&gt;This is a parent component&lt;/p&gt;     &lt;my-child&gt;&lt;/my-child&gt; \</span></span><br><span class="line"><span class="string">   &lt;/div&gt;'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-child'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;This is a parent component&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;This is a child component&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>组件接受的选项大部分与 <code>Vue</code> 实例一样，区别</p><ul><li><code>data</code> 属性，通过函数返回</li><li>也就是说子组件的模板和模块中是 无法直接调用父组件的数据，所以通过 <code>props</code> 将父组件的数据传递给子组件，子组件在接受数 据时需要显式声明 <code>props</code>，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-child'</span>, &#123;</span><br><span class="line">  props : [<span class="string">'parent'</span>],</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123; parent &#125;&#125; is from parent'</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;my-child parent=<span class="string">"This data"</span>&gt;&lt;/my-child&gt; //-&gt; &lt;p&gt;This data is from</span><br><span class="line">parent &lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>组件间通信</strong><br><code>Vue.js</code> 在组件间通信这一部分既提供了直接访问组件实例 的方法，也提供了自定义事件机制，通过广播、派发、监听等形式进行跨组件的函数调用。</p><ul><li><code>$parent</code>: 父组件实例。</li><li><code>$children</code>: 包含所有子组件实例。</li><li><code>$root</code>: 组件所在的根实例。</li></ul><p><strong>自定义事件触发机制</strong></p><ul><li><code>$emit</code>: 在实例本身上触发</li><li><code>$dispatch</code>: 派发事件，事件沿着父链冒泡，并且在第一次触发回调后自动停止，除非触发函数明确返回 <code>true</code>，才会继续向上冒泡</li><li><code>$broadcast</code>:广播事件，事件向下传递给所有后代</li></ul><p><strong>自组件索引</strong></p><ul><li><code>this.childre</code></li><li>子组件定义指定 <code>v-ref</code> 父组件获取子组件 <code>this.$refs.first</code></li></ul><h2 id="Vue-js-常用插件"><a href="#Vue-js-常用插件" class="headerlink" title="Vue.js 常用插件"></a>Vue.js 常用插件</h2><p><code>Vue-router</code><br><code>vue-router</code>的基本作用就是讲每个路径映射到对应的组件，并通过修改路由进行组件间的切换。</p><p><code>Vue-resource</code><br>所以这里就和大家介绍下 <code>Vue.js</code> 的插件 <code>Vue- resouce</code>，它同样对异步请求进行了封装，方便我们同服务端进行数据的交互。</p><p><code>Vue-devtools</code>:它可以在 <code>chrome</code> 的开发者模式下直接查看当前页面的 <code>Vue</code> 实例的组件结构和内部属性，方便我们直接观测。</p><h2 id="状态管理-VueX"><a href="#状态管理-VueX" class="headerlink" title="状态管理 VueX"></a>状态管理 VueX</h2><p><code>Vuex</code> 是状态管理模式的一种实现库，主要以插件的形式和 <code>Vue.js</code> 进行配合使用，能够 使我们在 <code>Vue.js</code> 中管理复杂的组件事件流。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1526010695904.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘抄自： 《 Vue.js 前端开发- 快速入门与专业应用》&lt;/p&gt;
&lt;h1 id=&quot;Vue-js-快速入门与专业应用&quot;&gt;&lt;a href=&quot;#Vue-js-快速入门与专业应用&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 快速入门与专业应用&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://luoyec.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="框架" scheme="https://luoyec.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数组去重</title>
    <link href="https://luoyec.cn/2018/05/06/cl4e29qcm001u989exdplzf8p/"/>
    <id>https://luoyec.cn/2018/05/06/cl4e29qcm001u989exdplzf8p/</id>
    <published>2018-05-06T11:50:18.040Z</published>
    <updated>2018-05-06T11:50:23.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-数组去重"><a href="#JavaScript-数组去重" class="headerlink" title="JavaScript 数组去重"></a>JavaScript 数组去重</h1><p><strong>方法一</strong></p><p>双循环，外循环遍历整个数组，内层循环进行比较，如果有相同的值则跳过，不同则 push 进结果数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                j = ++i <span class="comment">// 如果后面的元素等于当前外层循环遍历的元素，则跳过该元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(arr[i]) <span class="comment">//i有两种请求，一直是正常遍历的，一种是经过跳跃的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arra = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arra.distinct()) <span class="comment">//返回[3,4,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br>利用 <code>splice</code> 方法直接在原数组上将相同的元素删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                len--</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arra = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arra.distinct()) <span class="comment">//返回[3,4,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>方法三</strong><br>利用对象的属性不能相同的特点进行去重，但存在 数值型 1 和字符型 1 是同一个的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        i,</span><br><span class="line">        obj = &#123;&#125;,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">            <span class="comment">//如果能查找到，证明数组元素重复了,则不会放到结果数组中</span></span><br><span class="line">            obj[arr[i]] = <span class="number">1</span></span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.distinct()) <span class="comment">//1,2,3,4,5,6,56</span></span><br></pre></td></tr></table></figure><p><strong>方法四</strong><br>利用<code>ES6 Set</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> resultarr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="built_in">console</span>.log(resultarr) <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p><strong>方法五</strong><br>利用 <code>indexOf</code> 和 <code>forEach</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, arr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里利用map，filter方法也可以实现</span></span><br><span class="line">        <span class="keyword">var</span> bool = arr.indexOf(v, i + <span class="number">1</span>) <span class="comment">//从传入参数的下一个索引值开始寻找是否存在重复</span></span><br><span class="line">        <span class="keyword">if</span> (bool === <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.distinct()</span><br><span class="line"><span class="built_in">console</span>.log(b.toString()) <span class="comment">//1,23,2,3</span></span><br></pre></td></tr></table></figure><p><strong>方法六</strong><br>利用数组递归去重，先排序，然后从最后开始比较，遇到相同则删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        len = arr.length</span><br><span class="line">    arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对数组进行排序才能方便比较</span></span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] === arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            loop(index - <span class="number">1</span>) <span class="comment">//递归loop函数进行去重</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(len - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">56</span>, <span class="number">45</span>, <span class="number">56</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.distinct()</span><br><span class="line"><span class="built_in">console</span>.log(b.toString()) <span class="comment">//1,2,3,4,5,6,45,56</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-数组去重&quot;&gt;&lt;a href=&quot;#JavaScript-数组去重&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 数组去重&quot;&gt;&lt;/a&gt;JavaScript 数组去重&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;方法一&lt;/stron
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="排序算法" scheme="https://luoyec.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript排序算法</title>
    <link href="https://luoyec.cn/2018/05/06/cl4e29qd50033989eh8rspnuk/"/>
    <id>https://luoyec.cn/2018/05/06/cl4e29qd50033989eh8rspnuk/</id>
    <published>2018-05-06T03:59:25.542Z</published>
    <updated>2018-05-06T03:59:37.568Z</updated>
    
    <content type="html"><![CDATA[<p>参考：《数据结构与算法 JavaScript 描述》<br><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo 数据可视化</a></p><h1 id="JavaScript-排序算法"><a href="#JavaScript-排序算法" class="headerlink" title="JavaScript 排序算法"></a>JavaScript 排序算法</h1><p>排序算法的核心思想是对一组数据按照一定的顺序重新排列。重新排序时用到一组嵌套的 <code>for</code> 循环，其中外循环会遍历数组的每一项，内循环则用于比较元素。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>之所以叫冒泡排序，是因为排序时，数据会像起跑一样从数组的一端漂浮到另一端。算法在数组中移动，比较相邻的数据，当左侧大于右侧数据时将他们进行交换。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、第一轮排序之后就能将最大数放到最后，那么经过 n-1 轮，就能完成所有的排序，所以需要遍历的次数是 n-1</span></span><br><span class="line"><span class="comment"> * 2、内层循环中，max - i 而不是 max？ 因为没经过一轮都会讲最大数放到后面，不再需要对这些已经排序的值进行再次遍历</span></span><br><span class="line"><span class="comment"> * 3、为什么需要标志位，当一次遍历之后发现没有进行任何交换，说明次数数组已经完成排序，跳出循环，返回结果即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = data.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; max - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = data[j]</span><br><span class="line">                data[j] = data[j + <span class="number">1</span>]</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j]</span><br><span class="line">                done = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testArr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6579</span>, <span class="number">7569</span>, <span class="number">23.32</span>, <span class="number">234</span>, <span class="number">234</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(testArr))</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序从数组的开头开始，将第一个元素和其他<strong>每一个</strong>元素进行比较，检查所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便完成了排序。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外层循环遍历 n-1 次</span></span><br><span class="line"><span class="comment"> * 内层循环，没经过一次，找出最小值的坐标，循环结束后交互外循环坐标和最小坐标元素</span></span><br><span class="line"><span class="comment"> * 内层循环是依次减少的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> example = [<span class="number">8</span>, <span class="number">94</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">21</span>, <span class="number">39</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectSort(example))</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序有两个循环，外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及后面的那个元素进行比较。如果外循环中选中的元素比内循环中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组长度为1时，不需要排序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// tmp 是需要被插入的元素</span></span><br><span class="line">        <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历已经排序的元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j - <span class="number">1</span>] &gt; tmp) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">            --j</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort([<span class="number">1</span>, <span class="number">45</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的工作原理是，通过定义一个间隔序列来小时排序过程中进行比较的元素之间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分实际应用常见，算法要用到间隔序列可以提前定义好。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525575968269.jpg" alt=""></p><p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 动态定义间隔序列 1 4 13</span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = [<span class="number">8</span>, <span class="number">94</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">21</span>, <span class="number">39</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(shellSort(example))</span><br></pre></td></tr></table></figure><p>外循环控制间隔序列的移动，也就是说，算法在第一次处理数据集时，会检查所有间隔为 4 的元素，下一次检查间隔为 1 的元素。在开始最后一次处理是时，大部分元素都将在正确的位置，算法就不必对很多元素进行交换，这也是希尔排序高效的地方。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是序列的。</p><p>首先要在列表中选择一个元素作为基准值 (<code>pivot</code>)。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525577492984.jpg" alt=""></p><p>快速排序的算法和伪代码：</p><ul><li>选择一个基准元素，将列表分隔成两个子序列</li><li>对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面</li><li>分别对较小元素的子序列和较大元素的子序列重复步骤 1 和步骤 2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> left = [] <span class="comment">//小于基准存放数组</span></span><br><span class="line">    <span class="keyword">var</span> right = [] <span class="comment">// 大于基准存放数组</span></span><br><span class="line">    <span class="keyword">var</span> pivot = arr[<span class="number">0</span>] <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qSort(left).concat(pivot, qSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span> + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(qSort(a))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：《数据结构与算法 JavaScript 描述》&lt;br&gt;&lt;a href=&quot;https://visualgo.net/zh/sorting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;visualgo 数据可视化&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Jav
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="排序算法" scheme="https://luoyec.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AJAX 工作原理及概述</title>
    <link href="https://luoyec.cn/2018/05/04/cl4e29qb90002989e6xbvg5yp/"/>
    <id>https://luoyec.cn/2018/05/04/cl4e29qb90002989e6xbvg5yp/</id>
    <published>2018-05-04T07:11:14.446Z</published>
    <updated>2018-05-04T07:11:33.599Z</updated>
    
    <content type="html"><![CDATA[<p>参考： <a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="noopener">你真的会使用 XMLHttpRequest 吗？</a></p><h1 id="AJAX-工作原理及概述"><a href="#AJAX-工作原理及概述" class="headerlink" title="AJAX 工作原理及概述"></a>AJAX 工作原理及概述</h1><p><code>AJAX</code> 使用 <code>XMLHttpRequest</code> 对象与服务器通信，它可以使用 <code>JSON、XML、HTML</code>和文本等多种格式发送和接受。<code>AJAX</code> 最吸引人的是它的异步特性，也就是说可以在不重新刷新页面的情况下雨服务器通信，交换数据，更新页面。</p><p>最主要的两个特性：</p><ul><li>在不重新加载页面的情况下发送请求给服务器</li><li>接受并使用从服务器发来的数据</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>Ajax</code> 的原理简单来说通过 <code>XmlHttpRequest</code> 对象来向服务器发异步请求，从服务器获得数据，然后用 <code>javascript</code> 来操作 <code>DOM</code> 而更新页面。这其中最关键的一步就是从服务器获得请求数据。</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><p>创建 <code>XMLHttpRequest</code> 对象，需要注意兼容性问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造表单数据</span></span><br><span class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">    formData.append(<span class="string">'username'</span>, <span class="string">'johndoe'</span>)</span><br><span class="line">    formData.append(<span class="string">'id'</span>, <span class="number">123456</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 xhr 对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.timeout = <span class="number">3000</span></span><br><span class="line">    xhr.responseType = <span class="string">'text'</span></span><br><span class="line">    <span class="comment">//创建一个 post 请求， 第三个布尔值参数是同步还是异步, 默认是异步</span></span><br><span class="line">    xhr.open(<span class="string">'POST'</span>, <span class="string">'/server'</span>, <span class="literal">true</span>)</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span> || <span class="keyword">this</span>.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">    xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    xhr.send(formData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置请求头 xhr.setRequestHeader('X-Text', 'one')</span></span><br><span class="line"><span class="comment"> * 获取响应头</span></span><br><span class="line"><span class="comment">*/</span><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 指定响应类型</span></span><br><span class="line"><span class="string">`</span>responseType<span class="string">` 是 `</span>xhr level <span class="number">2</span><span class="string">` 新增的属性，用来指定 `</span>xhr.response<span class="string">` 的数据类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![][2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/path/to/image.png'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//可以将`xhr.responseType`设置为`"blob"`也可以设置为`" arrayBuffer"`</span></span><br><span class="line"><span class="comment">//xhr.responseType = 'arrayBuffer';</span></span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">this</span>.response;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h2 id="如何获取-response-数据"><a href="#如何获取-response-数据" class="headerlink" title="如何获取 response 数据"></a>如何获取 response 数据</h2><p><code>xhr</code> 提供了 3 个属性来获取请求返回的数据，分别是：<code>xhr.response、xhr.responseText、xhr.responseXML</code></p><ul><li><p><code>xhr.response</code> - 默认值：空字符串<code>&quot;&quot;</code> - 当请求完成时，此属性才有正确的值 - 请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></p></li><li><p><code>xhr.responseText</code> - 默认值为空字符串<code>&quot;&quot;</code> - 只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、””时，<code>xhr</code> 对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错 - 只有当请求成功时，才能拿到正确值。以下 2 种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</p></li><li><p><code>xhr.responseXML</code> - 默认值为 <code>null</code> - 只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code> 对象上才有此属性，此时才能调用 <code>xhr.responseXML</code>，否则抛错 - 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下 3 种情况下值都为 <code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p></li></ul><h2 id="如何追踪-ajax-请求的当前状态"><a href="#如何追踪-ajax-请求的当前状态" class="headerlink" title="如何追踪 ajax 请求的当前状态"></a>如何追踪 ajax 请求的当前状态</h2><p>用 <code>xhr.readyState</code> 这个属性即可追踪到。这个属性是只读属性，总共有 5 种可能值，分别对应 xhr 不同的不同阶段。每次 <code>xhr.readyState</code> 的值发生变化时，都会触发 <code>xhr.onreadystatechange</code> 事件，我们可以在这个事件中进行相关状态判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(xhr.readyState)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525417528673.jpg" alt=""></p><h2 id="可以发送什么类型的数据"><a href="#可以发送什么类型的数据" class="headerlink" title="可以发送什么类型的数据"></a>可以发送什么类型的数据</h2><p><code>xhr.send(data)</code>的参数 <code>data</code> 可以是以下几种类型：</p><ul><li><code>ArrayBuffer</code></li><li><code>Blob</code></li><li><code>Document</code></li><li><code>DOMString</code></li><li><code>FormData</code></li><li><code>null</code></li></ul><h2 id="事件触发顺序"><a href="#事件触发顺序" class="headerlink" title="事件触发顺序"></a>事件触发顺序</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525417713166.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考： &lt;a href=&quot;https://segmentfault.com/a/1190000004322487&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你真的会使用 XMLHttpRequest 吗？&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;AJAX-工作
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="ajax" scheme="https://luoyec.cn/tags/ajax/"/>
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="XMLHttpRequest" scheme="https://luoyec.cn/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式练习题</title>
    <link href="https://luoyec.cn/2018/05/01/cl4e29qgj009a989er9hwpoqi/"/>
    <id>https://luoyec.cn/2018/05/01/cl4e29qgj009a989er9hwpoqi/</id>
    <published>2018-05-01T06:31:39.761Z</published>
    <updated>2018-05-01T06:31:52.739Z</updated>
    
    <content type="html"><![CDATA[<p>资源：<br><a href="https://www.hackerrank.com/challenges/matching-anything-but-new-line/problem" target="_blank" rel="noopener">HackerRank 正则练习</a><br><a href="https://regexper.com/#%5E%28.%7B3%7D%5C.%29%7B3%7D.%7B3%7D$" target="_blank" rel="noopener">Regexper 正则可视化</a><br><a href="https://juejin.im/post/5ac1f1106fb9a028be362731" target="_blank" rel="noopener">面试中会遇到的正则题</a></p><h1 id="正则表达式练习题"><a href="#正则表达式练习题" class="headerlink" title="正则表达式练习题"></a>正则表达式练习题</h1><h2 id="匹配连续出现的四组以-连接的字符串"><a href="#匹配连续出现的四组以-连接的字符串" class="headerlink" title="匹配连续出现的四组以 . 连接的字符串"></a>匹配连续出现的四组以 <code>.</code> 连接的字符串</h2><p>题目：<code>abc.dss.sds.wer</code></p><p>答案：<code>/^(.{3}\.){3}.{3}$/g</code> 或者 <code>^(...\.){3}...$</code></p><ul><li><code>^</code> 以什么作为开头</li><li><code>$</code> 以什么作为结尾</li><li><code>.</code> 表示匹配任意字符</li><li><code>\.</code> 转义表示匹配 <code>.</code> 字符本身</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524932841581.jpg" alt=""></p><h2 id="匹配数字而非数字"><a href="#匹配数字而非数字" class="headerlink" title="匹配数字而非数字"></a>匹配数字而非数字</h2><p>题目：<code>xxXxxXxxxx</code></p><p>答案：<code>/(\d{2}\D){2}\d{4}/</code></p><ul><li><code>\d</code> 表示匹配一个数字</li><li><code>\D</code> 表示匹配非数字字符</li><li><code>()</code> 表示一个分组</li><li><code>{2}</code> 表示重复匹配两次</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934463555.jpg" alt=""></p><h2 id="匹配空白符"><a href="#匹配空白符" class="headerlink" title="匹配空白符"></a>匹配空白符</h2><p>题目： <code>SSsSSsSS</code></p><p>答案：<code>(\S{2}\s){2}\S{2}</code></p><ul><li><code>\S</code> 表示非空白符（<code>\r\n\t\f</code>）都是空白符</li><li><code>\s</code> 表示空白符</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934661285.jpg" alt=""></p><h2 id="匹配单词字符"><a href="#匹配单词字符" class="headerlink" title="匹配单词字符"></a>匹配单词字符</h2><p>单词字符包括从 <code>a-z A-Z 0-9</code> 和 <code>_</code></p><ul><li><code>\w</code> 匹配单词字符</li><li><code>\W</code> 匹配非单词字符</li></ul><h2 id="边界匹配，以什么开始，以什么结束"><a href="#边界匹配，以什么开始，以什么结束" class="headerlink" title="边界匹配，以什么开始，以什么结束"></a>边界匹配，以什么开始，以什么结束</h2><p><code>^\d\w{4}\.$</code></p><p>匹配以数字开头的一个字符，连续四个单词字符，以 <code>.</code> 结束的字符串</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524937039845.jpg" alt=""></p><h2 id="转换为驼峰命名"><a href="#转换为驼峰命名" class="headerlink" title="转换为驼峰命名"></a>转换为驼峰命名</h2><p><code>var s1 = &quot;get-element-by-id&quot;;</code> 给定这样一个连字符串，<code>写一个function</code> 转换为驼峰命名法形式的字符串 <code>getElementById</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'get-element-by-id'</span> <span class="comment">// getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断字符串是否包含数字"><a href="#判断字符串是否包含数字" class="headerlink" title="判断字符串是否包含数字"></a>判断字符串是否包含数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'arhs 23jyfhahr 234 ag'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/\d/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断电话号码"><a href="#判断电话号码" class="headerlink" title="判断电话号码"></a>判断电话号码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'13898762123'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否符合指定格式"><a href="#判断是否符合指定格式" class="headerlink" title="判断是否符合指定格式"></a>判断是否符合指定格式</h2><p>给定字符串 str，检查其是否符合如下格式<br>XXX-XXX-XXXX，其中 X 为 Number 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'234-234-2342'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否符合-USD-格式"><a href="#判断是否符合-USD-格式" class="headerlink" title="判断是否符合 USD 格式"></a>判断是否符合 USD 格式</h2><p>给定字符串 str，检查其是否符合美元书写格式</p><ul><li>以 $ 开始</li><li>整数部分，从个位起，满 3 个数字用 , 分隔</li><li>如果为小数，则小数部分长度为 2</li><li>正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3**</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'$1,023,032.03'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-实现千位分隔符"><a href="#JS-实现千位分隔符" class="headerlink" title="JS 实现千位分隔符"></a>JS 实现千位分隔符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regx = <span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span></span><br><span class="line">    <span class="keyword">return</span> (number + <span class="string">''</span>).replace(regx, <span class="string">'$&amp;,'</span>) <span class="comment">// $&amp;表示与regx相匹配的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-url-中的参数"><a href="#获取-url-中的参数" class="headerlink" title="获取 url 中的参数"></a>获取 url 中的参数</h2><blockquote><p><code>replace()</code> 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式,<br>替换值可以是一个字符串或者一个每次匹配都要调用的函数。<br>⚠️ 返回新的字符串，而原来的字符串不会被改变。如果第二个参数是个函数，那么函数的返回值将会替换字符串中匹配到的元素，如果第一个参数是个正则，且是全局匹配模式，那么该函数将会被多次调用，每次匹配到元素都会被执行。</p></blockquote><p><code>replace()</code> 参数：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525150013967.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span></span><br><span class="line">    <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">' - '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newString = <span class="string">'abc12345#$*%'</span>.replace(<span class="regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer)</span><br><span class="line"><span class="built_in">console</span>.log(newString) <span class="comment">// abc - 12345 - #$*%</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析的结果以对象行使存放</span></span><br><span class="line">    <span class="keyword">var</span> arr = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  字符串查找替换方法，可以传入字符串或者正则作为第一个参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &#123;regexp&#125; 以等号连接的，前面可以有?开始，后面可以有&amp; 结束的</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; matchKey 第一个圆括号匹配到的值，也就是参数等号左边的key</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; matchValue 第而个圆括号匹配到的值，也就是参数等号右边的value</span></span><br><span class="line"><span class="comment">     * @returns 返回替换后的字符串，原有的字符串不会被改变</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    url.replace(<span class="regexp">/\??(\w+)=(\w+)&amp;?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, matchKey, matchValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!arr[matchKey]) &#123;</span><br><span class="line">            arr[matchKey] = matchValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果参数存在重复，则连接两个参数的值，存放在一个数组中</span></span><br><span class="line">            <span class="keyword">var</span> temp = arr[matchKey]</span><br><span class="line">            arr[matchKey] = [].concat(temp, matchValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断第二个参数key，绝对返回内容</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ele <span class="keyword">in</span> arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ele = key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr[ele]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = getUrlParam(<span class="string">'www.baidu.com?name=234234&amp;age=age&amp;name=tt'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h2 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'luoyecong@aliyun.com'</span></span><br><span class="line"><span class="comment">// ? 最多一个</span></span><br><span class="line"><span class="comment">// + 最少一个</span></span><br><span class="line"><span class="comment">// * 零个或多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个合法的邮箱地址有三部分组成，以 @  . 符号连接，每个部分需要符合 a-zA-z0-9_- 字符组成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmail</span>(<span class="params">email = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^([a-zA-Z\d_-])+@([a-zA-Z\d_-])+\.([a-zA-Z\d_-])+$/</span>.test(email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEmail(<span class="string">'luo2\3yec_-ong@ali23yun.com'</span>))</span><br></pre></td></tr></table></figure><h2 id="验证合法身份证号"><a href="#验证合法身份证号" class="headerlink" title="验证合法身份证号"></a>验证合法身份证号</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 身份证号码可能为15位或18位，15位为全数字，18位中前17位为数字，最后一位为数字或者X</span></span><br><span class="line"></span><br><span class="line">;<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span></span><br></pre></td></tr></table></figure><h2 id="匹配汉字"><a href="#匹配汉字" class="headerlink" title="匹配汉字"></a>匹配汉字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^[\u4e00-\u9fa5]&#123;0,&#125;$/</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 这种匹配汉字的方法并不严谨，正确的方法是通过正则的底层提供的校验，但是需要 babel 的协助，还有汉字并不包括标点，具体请参看<br><a href="https://zhuanlan.zhihu.com/p/33335629" target="_blank" rel="noopener">JavaScript 正则表达式匹配汉字</a></p></blockquote><h2 id="去除首尾的’-‘"><a href="#去除首尾的’-‘" class="headerlink" title="去除首尾的’/‘"></a>去除首尾的’/‘</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以一个或者多个 / 开始或者以一个或者多个 / 结束的</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'/asdf//'</span></span><br><span class="line">str = str.replace(<span class="regexp">/^\/+|\/+$/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="判断日期格式是否符合-‘2017-05-11’的形式，简单判断，只判断格式"><a href="#判断日期格式是否符合-‘2017-05-11’的形式，简单判断，只判断格式" class="headerlink" title="判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式"></a>判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^\d&#123;4&#125;\-\d&#123;1,2&#125;\-\d&#123;1,2&#125;$/</span></span><br></pre></td></tr></table></figure><h2 id="判断日期格式是否符合-‘2017-05-11’的形式，严格判断（比较复杂）"><a href="#判断日期格式是否符合-‘2017-05-11’的形式，严格判断（比较复杂）" class="headerlink" title="判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）"></a>判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/</span></span><br></pre></td></tr></table></figure><h2 id="IPv4-地址正则"><a href="#IPv4-地址正则" class="headerlink" title="IPv4 地址正则"></a>IPv4 地址正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</span></span><br></pre></td></tr></table></figure><h2 id="十六进制颜色正则"><a href="#十六进制颜色正则" class="headerlink" title="十六进制颜色正则"></a>十六进制颜色正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/</span></span><br></pre></td></tr></table></figure><h2 id="车牌号正则"><a href="#车牌号正则" class="headerlink" title="车牌号正则"></a>车牌号正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/</span></span><br></pre></td></tr></table></figure><h2 id="过滤-HTML-标签"><a href="#过滤-HTML-标签" class="headerlink" title="过滤 HTML 标签"></a>过滤 HTML 标签</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配一对&lt;&gt; 内不包括 &lt;&gt;  的</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&lt;p&gt;dasdsa&lt;/p&gt;nice &lt;br&gt; test&lt;/br&gt;'</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/&lt;[^&lt;&gt;]+&gt;/g</span></span><br><span class="line">str = str.replace(regx, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="密码强度正则，最少-6-位，包括至少-1-个大写字母，1-个小写字母，1-个数字，1-个特殊字符"><a href="#密码强度正则，最少-6-位，包括至少-1-个大写字母，1-个小写字母，1-个数字，1-个特殊字符" class="headerlink" title="密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符"></a>密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续使用前瞻，匹配多个符合要求的分组，在每个分组中，任意字符、字母、数字、特殊字符</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span></span><br></pre></td></tr></table></figure><h2 id="URL-正则"><a href="#URL-正则" class="headerlink" title="URL 正则"></a>URL 正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/</span></span><br></pre></td></tr></table></figure><h2 id="匹配标签内数据，包括标签"><a href="#匹配标签内数据，包括标签" class="headerlink" title="匹配标签内数据，包括标签"></a>匹配标签内数据，包括标签</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;OPTION value="待处理"&gt;待处理&lt;/OPTION&gt;</span></span><br><span class="line"><span class="comment">// 写一个正则表达式,匹配 "&lt;OPTION value="待处理"&gt;"</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&lt;OPTION value="待处理"&gt;待处理&lt;/OPTION&gt;'</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^&lt;.*?&gt;/</span></span><br><span class="line"><span class="keyword">var</span> resiult = regx.exec(str)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源：&lt;br&gt;&lt;a href=&quot;https://www.hackerrank.com/challenges/matching-anything-but-new-line/problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HackerRank 正
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="正则" scheme="https://luoyec.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 类的继承</title>
    <link href="https://luoyec.cn/2018/04/17/cl4e29qcq0025989eoyriixn9/"/>
    <id>https://luoyec.cn/2018/04/17/cl4e29qcq0025989eoyriixn9/</id>
    <published>2018-04-17T05:16:30.391Z</published>
    <updated>2018-04-17T05:59:53.545Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript 设计模式》总结</p><h1 id="JavaScript-类的继承"><a href="#JavaScript-类的继承" class="headerlink" title="JavaScript 类的继承"></a>JavaScript 类的继承</h1><blockquote><p>大体上，每个类由三部分组成，第一部分是构造函数内的，这是供实例化对象复制用的；第二部分是构造函数外的，直接通过点语法添加的，这是供类使用的，实例化对象是访问不到的；第三部分是类的原型中的，实例化对象可以通过其原型链间接地访问到，也是为供所有实例化对象所使用的。</p></blockquote><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类式继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.superValue = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为父类添加共有方法</span></span><br><span class="line">SuperClass.prototype.getSuperVlaue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.superValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subValue = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//为子类添加共有方法</span></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新创建的对象复制了父类的构造函数内的属性与方法并且将原型 <code>__proto__</code> 指向了父类的原型对象，这样就拥有了父类的原型对象上的属性和方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。</p><p><strong>弊端</strong></p><ul><li>父类的共有属性要是引用类型，就会在子类中被所有实例共有，因此一个子类的实例更改子类型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li></ul><ul><li>子类的实现的继承是靠其原型 <code>prototype</code> 对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因此在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li></ul><h2 id="构造函数式继承（创建即继承）"><a href="#构造函数式继承（创建即继承）" class="headerlink" title="构造函数式继承（创建即继承）"></a>构造函数式继承（创建即继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 引用类型共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.books = [<span class="string">"JavaScript"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>]</span><br><span class="line">    <span class="comment">// 值类型共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类声明原型方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.books)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承父类</span></span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一个子类的实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = newSubClass(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个子类的实例</span></span><br><span class="line"><span class="keyword">var</span> instance2 = newSubClass(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523939316850.jpg" alt=""></p><p><strong>分析</strong><br><code>SuperClass.call(this, id)</code> 这是构造函数式继承的精华，由于 call 这个方法可以改变函数的作用域，因此在子类中，对 <code>SuperClass</code> 调用这个方法就是将子类的变量在父类中执行一遍，由于父类是给 <code>this</code> 绑定属性的，那么子类自然也就继承了父类的共有属性。</p><p><strong>弊端</strong><br>这种继承方式没有涉及原型 <code>prototype</code>， 所以父类的原型方法自然不会被子类继承，而如果想要被子类继承就必须放在构造函数中，这样的创建方式的每个实例都会单独的拥有一份而不能共用，也就违背了代码复用的原则。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>接上文，类式继承是通过子类原型的 <code>prototype</code> 对父类实例化来实现的，构造继承是通过在子类的构造函数作用环境中执行了一次父类的构造函数来实现的，组合继承整合这两点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="comment">//引用类型的共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.books = [<span class="string">"JavaScript"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型共有方法</span></span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类式继承 子类原型继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"><span class="comment">// 子类原型方法</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523939997209.jpg" alt=""></p><p><strong>弊端</strong><br>在使用构造函数继承是执行了一遍父类的构造函数，而在实现子类原型的类式继承又调用了一遍父类的构造函数，因此父类的构造函数调用了两遍。造成不必要的资源浪费。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote><p>借助原型 prototype 可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。 – 道格拉斯·克罗克福德</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="comment">//声明一个过渡函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//  过渡对象的原型继承父对象</span></span><br><span class="line"> F.prototype = o;</span><br><span class="line"> <span class="comment">//返回过渡对象的一个实例，该实例的原型继承了父对象</span></span><br><span class="line"> reutrn <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523941042826.jpg" alt=""></p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明基对象</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">name : <span class="string">'js book'</span>,</span><br><span class="line">alikeBook = [<span class="string">'css book'</span>, <span class="string">'html book'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 通过原型继承方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> inheritObject(obj);</span><br><span class="line">o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回扩展后的对象</span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄生式继承其实就是对原型继承的二次封装，并且在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且添加新的属性和方法。</p><h2 id="寄生组合式继承（目前最好的继承实现）"><a href="#寄生组合式继承（目前最好的继承实现）" class="headerlink" title="寄生组合式继承（目前最好的继承实现）"></a>寄生组合式继承（目前最好的继承实现）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决2.4中组合继承问题： 在使用构造函数继承时执行了一遍父类的够赞方法，而在实例化子类的时候又执行了一遍父类的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 《JavaScript中原型式继承》：借助原型 prototype 已有的对象创建一个新的对象，同时不必创建新的自定义对象类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寄生组合继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面的函数得到的对象F，拥有了对象o的全部属性（在原型链上），而修改F的属性，不会影响到o，相当于把o复制了一份。</span></span><br><span class="line"><span class="comment"> * F 对象拥有父对象的所有方法（在原型链上）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生命一个过渡函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//过渡对象的原型式父对象</span></span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="comment">//返回过渡对象的一个实例，该实例的原型继承了父对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 复制一份父类的原型副本保存在变量中， 复制了父类原型的所有属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> p = inheritObject(SuperClass.prototype)</span><br><span class="line">    <span class="comment">//修正因为重写子类原型导致子类的 constructor 属性被修改</span></span><br><span class="line">    p.constructor = subClass</span><br><span class="line">    <span class="comment">//设置子类原型</span></span><br><span class="line">    subClass.prototype = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"black"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义父类原型方法</span></span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数式继承</span></span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="comment">//子类新增属性</span></span><br><span class="line">    <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生式继承父类原型</span></span><br><span class="line">inheritPrototype(SubClass, SuperClass)</span><br><span class="line"><span class="comment">//子类新增原型方法</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个测试方法</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">"js book"</span>, <span class="number">2014</span>)</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">"css book"</span>, <span class="number">2013</span>)</span><br></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavaScript 实现多继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.mix = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>,</span><br><span class="line">        len = <span class="built_in">arguments</span>.length,</span><br><span class="line">        arg</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历被继承的对象</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//缓存当前对象</span></span><br><span class="line">        arg = <span class="built_in">arguments</span>[i]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> arg) &#123;</span><br><span class="line">            <span class="keyword">this</span>[property] = arg[property]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    name: <span class="string">"JavaScript"</span>,</span><br><span class="line">    alike: [<span class="string">"css"</span>, <span class="string">"js"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherBook = &#123;</span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newBook = &#123;&#125;</span><br><span class="line"></span><br><span class="line">newBook.mix(newBook, anotherBook, book)</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523942104926.jpg" alt=""></p><h2 id="ES6-class-实现继承"><a href="#ES6-class-实现继承" class="headerlink" title="ES6 class 实现继承"></a>ES6 class 实现继承</h2><p><code>class</code> 声明创建一个基于原型继承的具有给定名称的新类。</p><p>你也可以使用类表达式定义类。但是不同于类表达式，类声明不允许再次声明已经存在的类，否则将会抛出一个类型错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(width, height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">        <span class="keyword">this</span>.height = height</span><br><span class="line">        <span class="keyword">this</span>.area = width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">        <span class="keyword">this</span>.title = <span class="string">"hh"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subclass = <span class="keyword">new</span> SubClass(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subclass.area)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《JavaScript 设计模式》总结&lt;/p&gt;
&lt;h1 id=&quot;JavaScript-类的继承&quot;&gt;&lt;a href=&quot;#JavaScript-类的继承&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 类的继承&quot;&gt;&lt;/a&gt;JavaScript 类的继
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="类" scheme="https://luoyec.cn/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="https://luoyec.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 类的封装</title>
    <link href="https://luoyec.cn/2018/04/15/cl4e29qct002a989e6gw3q5di/"/>
    <id>https://luoyec.cn/2018/04/15/cl4e29qct002a989e6gw3q5di/</id>
    <published>2018-04-15T13:51:01.501Z</published>
    <updated>2018-04-15T13:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://blog.csdn.net/xi_2130/article/details/50276025" target="_blank" rel="noopener">js 如何创建类（封装）</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a><br><a href="https://item.jd.com/11747684.html" target="_blank" rel="noopener">《JavaScript 设计模式》</a></p><h1 id="JavaScript-类的封装"><a href="#JavaScript-类的封装" class="headerlink" title="JavaScript 类的封装"></a>JavaScript 类的封装</h1><p>在 <code>JavaScript</code> 中，类的实现是基于原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。</p><p>如果两个对象继承自同一个原型，往往意味着它们是由同一个构造函数创建并初始化的。</p><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>在 <code>JavaScript</code> 中创建一个类很容易，声明一个函数保存在一个变量中，在这个函数内部使用<code>this</code> 添加属性或者方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523793569198.jpg" alt=""></p><p>也可以通过在类的原型对象上添加属性和方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523793628214.jpg" alt=""></p><blockquote><p>⁉️ 通过 <code>prototype</code> 和 <code>this</code> 添加属性和方法有什么区别？通过 <code>this</code> 是在当前对手上添加的，每次对象被创建时这些方法和属性都会被重复创建；而通过 <code>prototype</code> 继承的方法不是对象自身的，所以当使用这些方法和属性时，会通过 <code>prototype</code> 一级一级想上查找（原型链），所有不会被重复创建（但是原型上的属性被修改是，所有继承该原型的对象都会被影响）。</p></blockquote><blockquote><p>⁉️ 什么是 <code>constructor</code> ？这是一个属性，当创建一个函数或对象时都会为期创建一个原型对象 <code>prototype</code>， 在 <code>prototype</code> 对象中又会创建一个 <code>constructor</code> 属性，那么 <code>constructor</code> 属性指向的就是拥有整个原型对象的函数或者对象。</p></blockquote><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523794135407.jpg" alt=""></p><h2 id="属性和方法的封装"><a href="#属性和方法的封装" class="headerlink" title="属性和方法的封装"></a>属性和方法的封装</h2><p>利用 <code>JavaScript</code> 的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建私有变量和私有方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523796141443.jpg" alt=""></p><p>思考 <code>new</code> 运算符原理，通过 <code>new</code> 实例化对象时，构造函数执行，<code>this</code> 执行新创建的对象。</p><p>类通过 <code>prototype</code> 创建的属性或者方法在类的实例对象是可以通过 <code>this</code> 访问的。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523797992598.jpg" alt=""></p><h2 id="再进一步，利用闭包进行封装"><a href="#再进一步，利用闭包进行封装" class="headerlink" title="再进一步，利用闭包进行封装"></a>再进一步，利用闭包进行封装</h2><blockquote><p>闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另一个函数。我们将这个闭包作为创建对象的构造函数，在闭包内部返回一个完整的类。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bookNum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkBook</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_book</span>(<span class="params">newID, newName, newPrice</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name, price</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">checkID</span>(<span class="params">id</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接构建原型</span></span><br><span class="line">    _book.prototype = &#123;</span><br><span class="line">        isJSBook: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   记得要返回该对象，否则会 “is not a constructor”</span></span><br><span class="line">    <span class="keyword">return</span> _book</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> Book1()</span><br></pre></td></tr></table></figure><h2 id="创建对象的安全模式"><a href="#创建对象的安全模式" class="headerlink" title="创建对象的安全模式"></a>创建对象的安全模式</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523799581237.jpg" alt=""></p><p>当忘记写 new 运算符时，是对象的直接复制，对象内部的 <code>this</code> 指向的是全局对象<code>window</code>，使用 <code>instanceof</code> 运算符判断当前 <code>this</code>，在使用闭包的封装中，是不会有整个问题的，其属性和方法都被限定在函数内部的作用域中。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523799875156.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/xi_2130/article/details/50276025&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js 如何创建类（封装）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http:
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="类" scheme="https://luoyec.cn/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="https://luoyec.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基本数据类型-对象</title>
    <link href="https://luoyec.cn/2018/04/15/cl4e29qcl001q989eiy5pu6wf/"/>
    <id>https://luoyec.cn/2018/04/15/cl4e29qcl001q989eiy5pu6wf/</id>
    <published>2018-04-14T19:03:40.058Z</published>
    <updated>2018-04-14T19:03:45.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-基本数据类型-对象"><a href="#JavaScript-基本数据类型-对象" class="headerlink" title="JavaScript 基本数据类型-对象"></a>JavaScript 基本数据类型-对象</h1><p>对象是 <code>JavaScript</code> 的基本数据类型，对象可以看做是属性的无序集合。对象不仅仅是字符串到值的映射，除了保持自身的属性，<code>JavaScript</code> 对象还可从一个称谓原型的对象中继承属性。对象的方法通常是继承的属性。这种“原型式继承”是 <code>JavaScript</code> 的核心特征。</p><p>对象的常见方法：</p><ul><li>创建 <code>create</code></li><li>设置 <code>set</code></li><li>查找 <code>query</code></li><li>删除 <code>delete</code></li><li>检测 <code>test</code></li><li>枚举 <code>enumerate</code></li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>创建对象最简单的方式就是使用对象字面量（直接量）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"min title"</span>: <span class="string">"JavaScript"</span>, <span class="comment">//属性名字有空格、连接符（-），必须要用字符串表示</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="string">"all audiences"</span> <span class="comment">// for 是保留字，必须用引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象字面量是一个表达式，每次运算都会创建并初始化一个新的对象。这就意味着，如果在一个重复调用的函数的循环内使用了对象字面量，它将创建很多对象，并且每次创建的对象的属性值都有可能不同。</p><h3 id="通过-new-创建对象"><a href="#通过-new-创建对象" class="headerlink" title="通过 new 创建对象"></a>通过 new 创建对象</h3><p>new 运算符创建并初始化一个对象。new 后跟随一个函数调用，这个函数被称为构造函数（constructor），构造函数用以初始化一个新创建的对象。</p><p>JavaScript 的原始类型都包含内置构造函数，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Arrya()</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>)</span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个 <code>JavaScript</code> 对象（<code>null</code> 除外）都和另一个对象相关联。</p><p>所有通过对象字面量创建的对象，原型都指向 <code>Object.prototype</code> (<code>obj.__proto__ === Object.prototype</code>)，通过 <code>new</code> 关键字创建的对象，其原型就是构造函数的 <code>prototype</code> 属性的值。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>ES6</code> 中新增的方法，它创建一个新对象，其中第一个采纳数是这个对象原型。 <code>Object.create()</code> 提供第二个参数，用以对对象的属性进行进一步描述。</p><p>创建一个空对象，（例如和 <code>{}、new Object()</code> 一样） ，需要传入 <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure><p>使用该方法，可以使得任意对象得以被继承，这是一个强大的特性。</p><h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>可以通过 <code>.</code> 或者方括号 <code>[]（必须是一个计算结果为字符串的表达式）</code> 运算符来获取属性的值。</p><h3 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h3><p>查询一个不存在属性并不会报错，会返回 undefined，但是如果对象不存在，那么使用查询这个不存对象的属性就会报错，null 和 undefined 都没有属性值，查询时均会报错。</p><p>利用 <code>&amp;&amp;</code> 运算符的短路行为，可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length</span><br></pre></td></tr></table></figure><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code> 运算符可以删除对象属性，但是只能删除自身属性，不能删除继承属性。（要删除继承属性，必须要定义这个属性的原型对象上删除它，但这回影响到所有继承这个原型的对象）。</p><p><code>delete</code> 不能删除可配置属性为 <code>false</code> 的属性。</p><h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><ul><li><code>in</code> 运算符，如果对象自有属性或继承属性中包含这个属性则返回 <code>true</code><br><code>javascript var o = {x: 1} &#39;x&#39; in o // true &#39;toString&#39; in o</code></li><li><code>hasOwnProperty()</code>， 用来检测给定的名字是否是对象自有的属性，继承属性将返回 <code>false</code><br><code>javascript o.hasOwnProperty(&#39;x&#39;) true o.hasOwnProperty(&#39;toString&#39;) false</code></li><li><p><code>propertyIsEnumerable()</code>，是 <code>hasOwnProperty()</code> 的增强版，检测自有属性并且该属性是可枚举的 - 通过代码增加的属性都是可枚举的，除非手动修改属性的可枚举性</p></li><li><p>使用 <code>!==</code> 判断 - 判断属性是否为 <code>undefined</code>，可用于自有属性和继承属性 - 当属性值位 <code>undefined</code> 时，则这种方法失效</p></li></ul><h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>对象序列化是指将对象的状态转换成字符串，使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 进行序列化和还原 <code>JavaScript对</code> 对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-基本数据类型-对象&quot;&gt;&lt;a href=&quot;#JavaScript-基本数据类型-对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 基本数据类型-对象&quot;&gt;&lt;/a&gt;JavaScript 基本数据类型-对象&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="对象" scheme="https://luoyec.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Object" scheme="https://luoyec.cn/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 原型及原型链</title>
    <link href="https://luoyec.cn/2018/04/14/cl4e29qcg001h989eg6qu80ct/"/>
    <id>https://luoyec.cn/2018/04/14/cl4e29qcg001h989eg6qu80ct/</id>
    <published>2018-04-14T08:15:53.601Z</published>
    <updated>2018-04-14T10:28:43.620Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="http://www.mollypages.org/tutorials/js.mp" target="_blank" rel="noopener">MollyPages.org</a><br><a href="http://www.cnblogs.com/liubaozhe/p/4618989.html" target="_blank" rel="noopener">javascript 原型链继承</a><br><a href="http://www.cnblogs.com/liushannet/archive/2011/09/28/2194905.html" target="_blank" rel="noopener">JavaScript：constructor 属性</a></p><h1 id="JavaScript-原型及原型链"><a href="#JavaScript-原型及原型链" class="headerlink" title="JavaScript 原型及原型链"></a>JavaScript 原型及原型链</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523687434929.jpg" alt=""></p><h2 id="原型的基本概念"><a href="#原型的基本概念" class="headerlink" title="原型的基本概念"></a>原型的基本概念</h2><ul><li><p>所有的实例都<strong>继承</strong>自创建他们的构造函数的 <code>prototype</code> 对象</p></li><li><p>实例拥有一个特殊的实现 <code>__proto__</code>指针，它指向创建者的 <code>prototype</code> 对象</p></li><li><p>无论是否存在 <code>__proto__</code>，所有的函数都存在 <code>prototype</code> 对象，它拥有一个 <code>constructor</code> 属性指向函数自身，这个属性是只读的。</p></li><li><p><code>constructor</code> 属性始终指向创建当前对象的构造函数</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="keyword">new</span> <span class="built_in">Function</span>() &#123;<span class="keyword">this</span>.name = <span class="string">'name'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> M;</span><br><span class="line"></span><br><span class="line">M.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">m.constructor === M  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>所有对象的原型最终都会指向 <code>Object</code> 对象的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__); <span class="comment">//指向Foo构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__); <span class="comment">//指向Object构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__.__proto__); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h2><p><code>instanceof</code> 检测一个对象 A 是不是另一个对象 B 的实例的原理是：<code>查看对象B的prototype</code> 指向的对象是否在对象 A 的 <code>[[prototype]]</code> 链上。如果在，则返回 <code>true</code> ,如果不在则返回 <code>false</code>。不过有一个特殊的情况，当对象 <code>B</code> 的 <code>prototype</code> 为 null 将会报错(类似于空指针异常)。</p><h2 id="new-运算符的原理"><a href="#new-运算符的原理" class="headerlink" title="new 运算符的原理"></a>new 运算符的原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"M"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> M()</span><br></pre></td></tr></table></figure><ul><li>创建一个对象 <code>m</code>，它继承自 <code>M.prototype</code></li><li>构造函数 <code>M</code> 会被执行，执行的时候，可以传递参数。同时上下文 <code>this</code>，执行新创建的对象 <code>m</code></li><li>如果构造函数 <code>m</code> 返回了一个对象，那么 <code>new</code> 的结果将会是这个对象，而不是对象 <code>m</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://www.mollypages.org/tutorials/js.mp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MollyPages.org&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblo
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域通信原理及示例</title>
    <link href="https://luoyec.cn/2018/04/14/cl4e29qfv0088989e4op1o2xk/"/>
    <id>https://luoyec.cn/2018/04/14/cl4e29qfv0088989e4op1o2xk/</id>
    <published>2018-04-14T04:45:50.875Z</published>
    <updated>2018-04-14T04:46:15.411Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="http://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">前端跨域通信的几种方式</a></p><h1 id="前端跨域通信原理及示例"><a href="#前端跨域通信原理及示例" class="headerlink" title="前端跨域通信原理及示例"></a>前端跨域通信原理及示例</h1><h2 id="同源策略及限制"><a href="#同源策略及限制" class="headerlink" title="同源策略及限制"></a>同源策略及限制</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p>所谓同源是指：<strong>域名，协议，端口</strong> 相同。</p><p><code>cookie,localstorage，dom</code> 没办法相互获取 ，<code>ajax</code> 请求也不能</p><h2 id="前后端的通信方式"><a href="#前后端的通信方式" class="headerlink" title="前后端的通信方式"></a>前后端的通信方式</h2><ul><li><p><code>Ajax</code> - 通过在后台与服务器进行少量数据交换，<code>Ajax</code> 可以使网页实现异步更新 - 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 - 同源下使用的通信方式</p></li><li><p><code>WebSocket</code> - 不限制同源策略 - 基于 <code>TCP</code> 的一种新的网络协议 - 实现了浏览器与服务器全双工(<code>full-duplex</code>)通信——允许服务器主动发送信息给客户端。</p></li><li><p><code>CORS</code> - 支持跨域通信也支持同源通信 - <code>CORS</code> 机制让 <code>web</code> 服务器能跨站访问控制 - 简单请求 - 浏览器直接发送 <code>CORS</code> 跨域请求，并在 <code>header</code> 信息中增加一个 <code>Origin</code> 字段，表明这是一个跨域的请求。 - 非简单请求 - 在正式通信前进行一次 <code>Http</code> 查询请求，又称预检请求</p></li></ul><h2 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h2><ul><li><code>JSONP</code></li><li><code>HASH</code></li><li><code>postMessage</code></li><li><code>WebSocket</code></li><li><code>CORS</code></li></ul><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><strong>跨域原理</strong></p><p>利用 <code>&lt;script src=””&gt;&lt;/script&gt;</code> 中的 <code>src</code> 的地址可以跨域，动态的构造 <code>script</code> 标签，以实现跨域数据访问。</p><p>前端通过 <code>script</code> 标签以发送请求，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt src=&quot;http://www.abc.com/?data=name&amp;callback=callback_fn&quot; charset=&quot;utf-8&quot;&gt;&lt;/scirpt&gt;</span><br></pre></td></tr></table></figure><p>服务端返回的也是 <code>script</code> 标签，<code>callback</code> 就是方法名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback_fn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"callback_fn"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 <code>jsonp</code> 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function 获取一个随机的5位字符串]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; prefix [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;        [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.getName = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        prefix +</span><br><span class="line">        <span class="built_in">Math</span>.random()</span><br><span class="line">            .toString(<span class="number">36</span>)</span><br><span class="line">            .replace(<span class="regexp">/[^a-z]+/g</span>, <span class="string">""</span>)</span><br><span class="line">            .substr(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function 判断是否为函数]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; source [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;        [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.isFunction = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[object Function]"</span> === <span class="built_in">Object</span>.prototype.toString.call(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function jsonp]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; url      [请求地址]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; onsucess [成功的回调]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; onerror  [错误处理方法]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; charset  [字符集]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;          [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.jsonp = <span class="function"><span class="keyword">function</span>(<span class="params">url, onsuccess, onerror, charset</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> callbackName = util.getName(<span class="string">"tt_player"</span>)</span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">            onsuccess(<span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> script = util.createScript(url + <span class="string">"&amp;callback="</span> + callbackName, charset)</span><br><span class="line">    script.onload = script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!script.readyState || <span class="regexp">/loaded|complete/</span>.test(script.readyState)) &#123;</span><br><span class="line">            script.onload = script.onreadystatechange = <span class="literal">null</span></span><br><span class="line">            <span class="comment">// 移除该script的 DOM 对象</span></span><br><span class="line">            <span class="keyword">if</span> (script.parentNode) &#123;</span><br><span class="line">                script.parentNode.removeChild(script)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除函数或变量</span></span><br><span class="line">            <span class="built_in">window</span>[callbackName] = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">            onerror()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><code>url</code> 的 <code>#</code> 后面的内容就叫 <code>Hash</code>。<code>Hash</code> 的改变，页面不会刷新。这就是用 <code>Hash</code> 做跨域通信的基本原理。</p><p>补充：<code>url</code> 的 <code>?</code> 后面的内容叫 <code>Search</code>。<code>Search</code> 的改变，会导致页面刷新，因此不能做跨域通信。</p><p><strong>使用举例：</strong></p><p>场景：我的页面 <code>A</code> 通过 <code>iframe</code> 或 <code>frame</code> 嵌入了跨域的页面 <code>B</code>。</p><p>现在，我这个 <code>A</code> 页面想给 <code>B</code> 页面发消息，怎么操作呢？</p><p>（1）首先，在我的 <code>A</code> 页面中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"iframe"</span>)</span><br><span class="line">B.src = B.src + <span class="string">"#"</span> + <span class="string">"jsonString"</span> <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></table></figure><p>（2）然后，在 <code>B</code> 页面中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postMessage-方法"><a href="#postMessage-方法" class="headerlink" title="postMessage()方法"></a>postMessage()方法</h3><p><code>H5</code> 中新增的 <code>postMessage()</code> 方法，可以用来做跨域通信。既然是 <code>H5</code> 中新增的，那就一定要提到。</p><p>场景：窗口 <code>A (http:A.com)</code> 向跨域的窗口 <code>B (http:B.com)</code>发送信息。步骤如下。</p><p>（1）在 <code>A</code> 窗口中操作如下：向 B 窗口发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">"data"</span>, <span class="string">"http://B.com"</span>) <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>) <span class="comment">//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把请求发出去</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>)</span><br><span class="line">    ws.send(<span class="string">"Hello WebSockets!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对方发消息过来时，我接收</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received Message: "</span>, evt.data)</span><br><span class="line">    ws.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 <code>B</code> 窗口中操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(</span><br><span class="line">    <span class="string">"message"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.origin) <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.source) <span class="comment">//获取：A window对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.data) <span class="comment">//获取传过来的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><code>CORS</code> 可以理解成是既可以同步、也可以异步*的 <code>Ajax</code>。</p><p><code>fetch</code> 是一个比较新的 <code>API</code>，用来实现 <code>CORS</code> 通信。用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">"/some/url/"</span>, &#123;</span><br><span class="line">    method: <span class="string">"get"</span></span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>CORS</code> 为什么能实现跨域通信？浏览器会拦截 <code>Ajax</code>，<code>如果Ajax</code> 是跨域的，会在 <code>Http头部增加</code> <code>origin</code></p></blockquote><h3 id="CORS-和-JSONP-比较"><a href="#CORS-和-JSONP-比较" class="headerlink" title="CORS 和 JSONP 比较"></a><code>CORS</code> 和 <code>JSONP</code> 比较</h3><p><code>CORS</code> 和 <code>JSONP</code> 都是为了使 <code>web</code> 浏览器能够跨源请求，使用目的相同，但是比 <code>JSONP</code> 更强大。<code>JSONP</code> <code>只支持GET</code> 请求，而 <code>CORS</code> 支持所有类型的 <code>HTTP</code> 请求，<code>不过JSONP</code> 的优势在于支持老式浏览器以及可以向不支持 <code>CORS</code> 的网站跨源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8523576.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端跨域通信的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前端跨域通信原理及示例&quot;&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="https://luoyec.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="http" scheme="https://luoyec.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest请求</title>
    <link href="https://luoyec.cn/2018/04/13/cl4e29qeh005j989edefbu72w/"/>
    <id>https://luoyec.cn/2018/04/13/cl4e29qeh005j989edefbu72w/</id>
    <published>2018-04-13T15:38:53.944Z</published>
    <updated>2018-04-13T15:39:14.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XMLHttpRequest-请求"><a href="#XMLHttpRequest-请求" class="headerlink" title="XMLHttpRequest 请求"></a>XMLHttpRequest 请求</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [json 实现ajax的json]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; options [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;         [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.json = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opt = &#123;</span><br><span class="line">        url: <span class="string">""</span>,</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    util.extend(opt, options)</span><br><span class="line">    <span class="keyword">if</span> (opt.url) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">        <span class="keyword">var</span> data = opt.data,</span><br><span class="line">            url = opt.url,</span><br><span class="line">            type = opt.type.toUpperCase(),</span><br><span class="line">            dataArr = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="comment">// 将ke-value的数据转成数组存放</span></span><br><span class="line">            dataArr.push(k + <span class="string">"="</span> + data[k])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">"GET"</span>) &#123;</span><br><span class="line">            url = url + <span class="string">"?"</span> + dataArr.join(<span class="string">"&amp;"</span>)</span><br><span class="line">            <span class="comment">// 删除以问号结尾的问号</span></span><br><span class="line">            xhr.open(type, url.replace(<span class="regexp">/\?$/g</span>, <span class="string">""</span>), <span class="literal">true</span>)</span><br><span class="line">            xhr.send()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">"POST"</span>) &#123;</span><br><span class="line">            xhr.open(type, url, <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 设置请求头部</span></span><br><span class="line">            xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">            xhr.send(dataArr.join(<span class="string">"&amp;"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 304 客户端可从缓存中获取数据，还可以增加 206 视频等媒体资源加载时用</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> res</span><br><span class="line">                <span class="keyword">if</span> (opt.success &amp;&amp; opt.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                    res = xhr.responseText</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">"string"</span>) &#123;</span><br><span class="line">                        res = <span class="built_in">JSON</span>.parse(res)</span><br><span class="line">                        opt.success.call(xhr, res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (opt.error &amp;&amp; opt.error <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                    opt.error.call(xhr, res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XMLHttpRequest-请求&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-请求&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest 请求&quot;&gt;&lt;/a&gt;XMLHttpRequest 请求&lt;/h1&gt;&lt;figure class
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="http" scheme="https://luoyec.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>React 服务端渲染理论</title>
    <link href="https://luoyec.cn/2018/04/05/cl4e29qe3004u989eb07amgna/"/>
    <id>https://luoyec.cn/2018/04/05/cl4e29qe3004u989eb07amgna/</id>
    <published>2018-04-05T07:09:31.232Z</published>
    <updated>2018-04-05T07:09:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>资源列表：<br><a href="https://github.com/wssgcg1213/koa2-react-isomorphic-boilerplate" target="_blank" rel="noopener">Git仓库: <code>koa2-react-isomorphic-boilerplate</code></a><br><a href="https://zhuanlan.zhihu.com/p/28322014" target="_blank" rel="noopener">Webpack工程化解决方案easywebpack</a><br><a href="https://zhuanlan.zhihu.com/p/30526168" target="_blank" rel="noopener">Egg + React + React Router ＋ Redux 服务端渲染实践</a><br><a href="https://zhuanlan.zhihu.com/p/30681341" target="_blank" rel="noopener">Egg + React 服务端渲染开发指南</a><br><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a><br><a href="http://www.alloyteam.com/2015/10/8783/" target="_blank" rel="noopener">React服务器端渲染实践小结</a></p><h1 id="React-服务端渲染理论"><a href="#React-服务端渲染理论" class="headerlink" title="React 服务端渲染理论"></a>React 服务端渲染理论</h1><p>相关的知识点：</p><ul><li>了解服务端渲染解决的问题</li><li>了解服务端渲染的基本原理</li><li>使用现有框架实现服务端渲染</li><li>进阶，dva+egg框架实现服务端渲染</li><li>进行性能测试</li></ul><h2 id="客户端渲染、服务端渲染、同构的区别"><a href="#客户端渲染、服务端渲染、同构的区别" class="headerlink" title="客户端渲染、服务端渲染、同构的区别"></a>客户端渲染、服务端渲染、同构的区别</h2><ul><li><p>客户端渲染：页面在 <code>JavaScript</code>，<code>CSS</code> 等资源文件加载完毕后开始渲染，路由为客户端路由，也就是我们经常谈到的 <code>SPA（Single Page Application）</code>。</p></li><li><p>服务端渲染：页面由服务端直接返回给浏览器，路由为服务端路由，<code>URL</code> 的变更会刷新页面，原理与 <code>ASP</code>，<code>PHP</code> 等传统后端框架类似。</p></li><li><p>同构：英文表述为 <code>Isomorphic</code> 或 <code>Universal</code>，即编写的 <code>JavaScript</code> 代码可同时运行在浏览器及 <code>Node.js</code> 两套环境中，用服务端渲染来提升首屏的加载速度，首屏之后的路由由客户端控制，即在用户到达首屏后，整个应用仍是一个 <code>SPA</code>。</p></li></ul><h2 id="总的架构"><a href="#总的架构" class="headerlink" title="总的架构"></a>总的架构</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522851689181.jpg" alt=""></p><ul><li>服务端预先获取编译好的客户端代码及其他资源。</li><li>服务端接收到用户的 <code>HTTP</code> 请求后，触发服务端的路由分发，将当前请求送至服务端渲染模块处理。</li><li>服务端渲染模块根据当前请求的 <code>URL</code> 初始化 <code>memory history</code> 及 <code>redux store</code>。</li><li>根据路由获取渲染当前页面所需要的异步请求（<code>thunk</code>）并获取数据。</li><li>调用 <code>renderToString</code> 方法渲染 <code>HTML</code> 内容并将初始化完毕的 <code>redux store</code> 塞入 <code>HTML</code> 中，供客户端渲染时使用。</li><li>客户端收到服务端返回的已渲染完毕的 <code>HTML</code> 内容并开始同步加载客户端 <code>JavaScript</code>，<code>CSS</code>，图片等其他资源。</li><li>之后的流程与客户端渲染完全相同，客户端初始化 <code>redux store</code>，路由找到当前页面的组件，触发组件的生命周期函数，再次获取数据。唯一不同的是 <code>redux store</code> 的初始状态将由服务端在 <code>HTML</code> 中塞入的数据提供，以保证客户端渲染时可以得到与服务端渲染相同的结果。受益于 <code>Virtual DOM</code> 的 <code>diff</code> 算法，这里并不会触发一次冗余的客户端渲染。</li></ul><h2 id="为什么要采用服务端渲染？"><a href="#为什么要采用服务端渲染？" class="headerlink" title="为什么要采用服务端渲染？"></a>为什么要采用服务端渲染？</h2><ul><li>利于 <code>SEO</code></li><li>加速首屏渲染速度</li><li>享受 <code>React</code> 组件式开发的优势：高复用、低耦合</li><li>前后端维护一套代码（代码同构）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源列表：&lt;br&gt;&lt;a href=&quot;https://github.com/wssgcg1213/koa2-react-isomorphic-boilerplate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git仓库: &lt;code&gt;koa2-react
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="React" scheme="https://luoyec.cn/tags/React/"/>
    
      <category term="rss" scheme="https://luoyec.cn/tags/rss/"/>
    
      <category term="服务端渲染" scheme="https://luoyec.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 正则表达式</title>
    <link href="https://luoyec.cn/2018/03/31/cl4e29qcp0022989e6g6attej/"/>
    <id>https://luoyec.cn/2018/03/31/cl4e29qcp0022989e6g6attej/</id>
    <published>2018-03-31T03:02:24.965Z</published>
    <updated>2018-03-31T03:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="https://www.imooc.com/learn/706" target="_blank" rel="noopener">慕课网 JavaScript 正则表达式</a><br><a href="https://regexper.com" target="_blank" rel="noopener">正则表达式的可视化开源工具</a></p><h1 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h1><h2 id="REGEXP-对象"><a href="#REGEXP-对象" class="headerlink" title="REGEXP 对象"></a>REGEXP 对象</h2><p><code>JavaScript</code> 通过内置对象 <code>RegExp</code> 支持正则表达式，有两种方法实例化 <code>RegExp</code> 对象</p><ul><li>字面量</li><li>构造函数</li></ul><p>字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span></span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\bis\\b"</span>, <span class="string">"g"</span>)</span><br></pre></td></tr></table></figure><p>修饰符</p><blockquote><p><code>g</code>：<code>global</code> 全文搜索，不添加则搜索到第一个匹配停止<br><code>i</code>：<code>ignore case</code> 忽略大小写，默认大小写敏感<br><code>m</code>：<code>multiple lines</code> 多行搜索</p></blockquote><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式由两种基本字符类型组成</p><ul><li>原义文本字符如字母 <code>a</code>，表示的就是小写英文字母 <code>a</code></li><li>元字符元字符是在正则表达式中有特殊含义的非字母字符<br><code>* + ? $ ^ . | \ ( ) { } [ ]</code></li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522430983610.jpg" alt=""></p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul><li>一般情况下正则表达式一个字符对应字符串一个字符</li><li>表达式 <code>ab\t</code> 的含义就是 <img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432161908.jpg" alt=""></li></ul><p><strong>有时候需要匹配某一类字符</strong></p><ul><li>我们可以使用元字符 <code>[]</code> 来构建一个简单的类</li><li>所谓类是指符合某些特性的对象，一个泛指，而不是特质某个字符</li><li>表达式 <code>[abc]</code> 把字符 <code>a</code> 或 <code>b</code> 或 <code>c</code> 归为一类，表达式可以匹配这类的字符</li></ul><p><strong>字符类取反</strong></p><ul><li>使用元字符 <code>^</code> 创建 反向类/负向类</li><li>反向类的意思是不属于某类的内容</li><li>表达式 <code>[^abc]</code> 表示不是字符 <code>a</code> 或 <code>b</code> 或 <code>c</code> 的内容</li></ul><h2 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h2><ul><li>我们可以使用 [a-z] 来连接两个字符，表示从 <code>a</code> 到 <code>z</code> 的任意字符</li><li>这是个闭区间，也就是包含 <code>a</code> 和 <code>z</code> 本身</li><li>在 [] 组成的类内部是可以连写的 [a-zA-Z] <img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432684275.jpg" alt=""></li></ul><h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><p>正则表达式提供预定义类来匹配常见的字符类</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432833923.jpg" alt=""></p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>常用边界匹配字符</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432964967.jpg" alt=""></p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>希望匹配一个连续出现 20 次数字的字符串</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522433319882.jpg" alt=""></p><h2 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h2><p>正则尽可能的匹配，例如匹配 3-6 个数字，<code>\d{3,6}</code>，在一串数字中，例如 12345678 ，匹配的结果为 123456</p><p><strong>非贪婪模式</strong><br>让正则尽可能少的匹配，也就是说一旦匹配成功不再继续尝试就是非贪婪模式，直接在量词后加上 ？ 即可，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123253253455"</span>.match(<span class="regexp">/\d&#123;3,6&#125;?/g</span>)</span><br><span class="line"><span class="comment">// ["123", "253", "253", "455"]</span></span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用 <code>( )</code> 可以达到分组的功能，使量词作用域分组，例如</p><p><code>(lyctea){3}</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456387142.jpg" alt=""></p><p>或用 | 表示或，例如</p><p><code>lyctea|luoyecong</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456487629.jpg" alt=""></p><p><code>luoye(c|cong)</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456550113.jpg" alt=""></p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>例如将用 - 连接的日期，转成 / 表示的日期格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"2017-03-30"</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">"$2/$3/$1"</span>)</span><br><span class="line"><span class="comment">// "03/30/2017"</span></span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522457145865.jpg" alt=""></p><p><strong>忽略分组</strong><br>不希望捕获某些分组，只需要在分组内加上 ? : 就可以</p><p><code>(?:Byron).(ok)</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522457301448.jpg" alt=""></p><h2 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h2><ul><li>正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“前”</li><li>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言；后顾/后瞻方向相反</li><li><code>JavaScript</code> 不支持后顾</li><li>符合和不符合特定断言成为 <strong>肯定/正向</strong> 匹配和 <strong>否定/负向</strong> 匹配</li></ul><p><strong>语法（规则+断言）</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522460847546.jpg" alt=""></p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配前面是单词或数字，后面是数字</span></span><br><span class="line"><span class="string">"x3*33vV"</span>.replace(<span class="regexp">/\w(?=\d)/g</span>, <span class="string">'_'</span>)；</span><br><span class="line"><span class="comment">// "_3*_3vV"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配前面是单词或数字，后面不是数字</span></span><br><span class="line"><span class="string">"x3*33vV"</span>.replace(<span class="regexp">/\w(?!\d)/g</span>, <span class="string">'_'</span>)；</span><br><span class="line"><span class="string">"x_*3___"</span></span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462277518.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462262993.jpg" alt=""></p><h2 id="JS-对象属性"><a href="#JS-对象属性" class="headerlink" title="JS 对象属性"></a>JS 对象属性</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462629556.jpg" alt=""></p><h2 id="test-和-exec-方法"><a href="#test-和-exec-方法" class="headerlink" title="test 和 exec 方法"></a>test 和 exec 方法</h2><p><strong><code>RegExp.prototype.test()</code></strong></p><blockquote><p><code>test()</code> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p></blockquote><p><code>lastIndex</code>：当前匹配结果的最后一个字符的下一个字符（使用 <code>test()</code> 会分段匹配，可能会执行多次，当全文匹配完毕时，会从头匹配）</p><p><strong><code>RegExp.prototype.exec()</code></strong><br><code>exec()</code> 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <code>null</code>。</p><p>如果你只是为了判断是否匹配（<code>true</code>或 <code>false</code>），可以使用 <code>RegExp.test()</code> 方法，或者 <code>String.search()</code> 方法。</p><h2 id="字符串方法中的正则"><a href="#字符串方法中的正则" class="headerlink" title="字符串方法中的正则"></a>字符串方法中的正则</h2><p><strong>String.prototype.search()</strong><br><code>search()</code> 方法执行正则表达式和 <code>String</code> 对象之间的一个搜索匹配。</p><p><strong>String.prototype.match()</strong><br>当一个字符串与一个正则表达式匹配时， <code>match()</code> 方法检索匹配项。</p><p><strong>String.prototype.replace()</strong><br><code>replace()</code> 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。</p><blockquote><p>⚠️ 注意：原字符串不会改变。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;https://www.imooc.com/learn/706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网 JavaScript 正则表达式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://regexper.c
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="RegExp" scheme="https://luoyec.cn/tags/RegExp/"/>
    
      <category term="正则" scheme="https://luoyec.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>浏览器存储、HTTP缓存、SSR</title>
    <link href="https://luoyec.cn/2018/03/24/cl4e29qgl009d989esilt647f/"/>
    <id>https://luoyec.cn/2018/03/24/cl4e29qgl009d989esilt647f/</id>
    <published>2018-03-24T14:32:19.000Z</published>
    <updated>2018-03-24T14:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存 MDN</a><br><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a></p><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521824473690.jpg" alt=""></p><p><code>HTTP</code> 请求是无状态的，一次连接关闭，使用 <code>Cookie</code>去维持客户端状态，维护用户的登录信息。服务端可以判断这个请求是来自哪个客户端。</p><p>总结两点功能：</p><ul><li>用于浏览器端和服务器端的交互</li><li>客户端自身数据的存储</li></ul><p><code>Cookie</code> 存储的限制：</p><ul><li>作为浏览器存储，大小 4kb 左右（<code>存储数据能力被localstorage</code> 替代）</li><li>需要设置过期时间 <code>expire</code></li><li><code>httponly</code>：当前这个 <code>Cookie</code> 只能用户 <code>http</code> 传输，而不能用 <code>js</code> 进行读写</li><li><code>Cookie</code>中在相关域名下面 – <code>CND</code> 的流量损耗 - 在同一个域名下的所有请求，都会携带请求<ul><li><code>CDN</code> 的域名和主站的域名要分开</li></ul></li></ul><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><ul><li><code>HTML5</code> 设计专门用来浏览器存储的</li><li>大小为 5MB 左右</li><li>尽在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>浏览器本地缓存方案</li></ul><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><ul><li>会话级别的浏览器存储</li><li>大小为 <code>5MB</code> 左右</li><li>尽在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>对于表单信息的维护</li></ul><h2 id="IndexDB"><a href="#IndexDB" class="headerlink" title="IndexDB"></a>IndexDB</h2><p><code>IndexDB</code> 是一种低级 <code>API</code>，用于客户端存储大量结构化数据。该 <code>API</code> 使用索引来实现对该数据的高性能搜索。虽然 <code>Web Storage</code> 对于储存较少的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexDB</code> 提供了解决方案。</p><p>为应用创建离线版本。</p><h2 id="Service-Workers-产生的意义"><a href="#Service-Workers-产生的意义" class="headerlink" title="Service Workers 产生的意义"></a>Service Workers 产生的意义</h2><blockquote><p><code>Service workers</code><br>本质上充当 <code>Web</code> 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。</p></blockquote><p><code>Service workers</code>是一个脚本。浏览器独立与当前网页，将其在后台运行，为实现一些不依 赖页面或者用户交互的特性打开了一扇大门，在未来这些特性将包括推送消息，背景后台同步，<code>geofencing</code>（地理围栏定位），但他将退出的第一个首要特性，就是拦截和处理网络请求的能力，包括变成方式来管理被缓存的响应。</p><p>使用拦截网络请求的能力，可以实现离线应用。</p><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p><code>PWA（Progressive Web APPs）</code> 是一种 <code>Web App</code> 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写就能看出来，这事一个<strong>渐进式</strong>的 <code>WebApp</code> ，是通过一系列新的 <code>Web</code> 特性。配合优秀的 <code>UI</code> 交互设计，逐步的增强 <code>Web APP</code> 的用户体验。</p><ul><li>可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现 “未连接到互联网”的页面。</li><li>快速：针对网页渲染及网路数据访问有较好的优化。</li><li>融入（<code>Engaging</code>）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。</li></ul><blockquote><p>⚠️ <code>lighthouse</code>：<code>chorm</code> 扩展插件，检查网站性能，SEO 等</p></blockquote><h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><blockquote><p>重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。</p></blockquote><h1 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server Side Rendering"></a>Server Side Rendering</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521898842131.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 缓存 MDN&lt;/a&gt;&lt;br&gt;&lt;a hre
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="离线存储" scheme="https://luoyec.cn/tags/%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>懒加载与预加载，重绘与回流</title>
    <link href="https://luoyec.cn/2018/03/24/cl4e29qg8008t989e3m62ins7/"/>
    <id>https://luoyec.cn/2018/03/24/cl4e29qg8008t989e3m62ins7/</id>
    <published>2018-03-23T16:40:34.000Z</published>
    <updated>2018-03-23T16:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="懒加载与预加载"><a href="#懒加载与预加载" class="headerlink" title="懒加载与预加载"></a>懒加载与预加载</h1><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul><li>图片进入可视区域之后请求图片资源 - 进入可视区域之后修改 src 属性</li><li><code>UI</code> 与电商等图片资源很多，页面很长的业务场景使用</li><li>减少无效资源的加载</li><li>并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用</li></ul><p>实现方式：需要去监听 <code>scroll</code> 事件，在 <code>scrool</code> 滚动事件的回调中</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521813324228.jpg" alt=""></p><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ul><li>图片等静态资源在使用之前的提前请求</li><li>资源使用时能从缓存中加载，提升用户体验</li><li>页面展示的依赖关系维护</li></ul><p>实现方式：</p><ul><li>使用 <code>XMLHttpRequest</code> 对象</li><li>使用 <code>Image</code> 对象</li><li>使用 <code>preload.js</code> 库</li></ul><h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><ul><li>理解浏览器重绘与回流的机制</li><li>对于一些经典的案例进行分析</li><li>重绘与回流的案例实战</li></ul><p><strong>css 性能会让 JavaScript 变慢？</strong><br>在加载 <code>css</code> 的时候，<code>js</code> 的执行被阻塞，在 <code>js</code> 中执行的时候，页面的渲染也是被阻塞的。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521815434613.jpg" alt=""></p><p>频繁触发重绘与回流，会导致 <code>UI</code> 频繁渲染，最终导致 <code>js</code> 执行效率。</p><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><ul><li><p>当 <code>render tree</code> 中的一部分（或全部）因为元素的规模尺寸，<strong>布局</strong>，隐藏改变而需要重新构建，这就成为回流（<code>reflow</code>）</p></li><li><p>当页面布局和几何属性改变时就需要回流</p></li></ul><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当 <code>render tree</code> 的一些元素需要更新属性，二者属性只是影响元素的外观，风格，而不会影响<strong>布局</strong>的，比如 <code>background-color</code> 。则成为重绘。</p><p><strong>综上，回流一定会触发重绘，重绘不一定会触发回流。</strong></p><h3 id="触发页面重新布局的属性"><a href="#触发页面重新布局的属性" class="headerlink" title="触发页面重新布局的属性"></a>触发页面重新布局的属性</h3><ul><li>盒子模型相关属性会触</li><li>定位属性及浮动也会触发</li><li>改变节点内部文字结构</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521816177011.jpg" alt=""></p><p>将频发重绘回流的 <code>DOM</code> 元素单独作为一个独立图层，那么这个 <code>DOM</code> 元素的重绘和回流的影响只会在这个图层中。</p><p><code>Chrome</code> 创建图层的条件：</p><ul><li>3D 或透视变换 <code>CSS</code> 属性（<code>perspective transform</code>）</li><li>使用加速视频解码的 <code>video</code> 节点</li><li>拥有 3D （<code>WebGL</code>） 上下文或加速的 2D 上下文的 <code>canvas</code> 节点</li><li>混合插件（如 <code>Flash</code>）</li><li>对自己的 <code>opacity</code> 做 <code>CSS</code> 动画或使用一个动画 <code>webkit</code> 变换的元素</li><li>拥有加速 <code>CSS</code> 过滤器的元素</li><li>元素有一个包含复合层的后代节点</li><li>元素由一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素</li></ul><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li>避免使用触发重绘、回流的 CSS 属性</li><li>将重绘、 回流的影响返回限制在单独的图层之内</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521821670261.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;懒加载与预加载&quot;&gt;&lt;a href=&quot;#懒加载与预加载&quot; class=&quot;headerlink&quot; title=&quot;懒加载与预加载&quot;&gt;&lt;/a&gt;懒加载与预加载&lt;/h1&gt;&lt;h2 id=&quot;懒加载&quot;&gt;&lt;a href=&quot;#懒加载&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="懒加载，预加载" scheme="https://luoyec.cn/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>资源合并与压缩</title>
    <link href="https://luoyec.cn/2018/03/23/cl4e29qh700ai989ezv8hwa4n/"/>
    <id>https://luoyec.cn/2018/03/23/cl4e29qh700ai989ezv8hwa4n/</id>
    <published>2018-03-23T05:31:52.000Z</published>
    <updated>2018-03-23T05:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br>[什么是 CDN–阿里云][1]</p><ul><li>理解减少 <code>HTTP</code> 请求数量和减少请求资源大小的两个优化点</li><li>掌握压缩与合并的原理</li><li>掌握通过在线网站和 <code>fis3</code> 两种实现压缩的与合并的方法</li></ul><h2 id="HTTP-请求过程及潜在的性能优化点"><a href="#HTTP-请求过程及潜在的性能优化点" class="headerlink" title="HTTP 请求过程及潜在的性能优化点"></a>HTTP 请求过程及潜在的性能优化点</h2><p>❓ 浏览器的一个请求从发送到返回都经历了什么？</p><p>❓ <code>DNS</code> 是否可用通过魂村减少 <code>DNS</code> 查询时间</p><p>❓ 网络请求的过程走最近的网络环境？</p><p>❓ 相同的静态资源是否可用缓存</p><p>❓ 是否减少请求 <code>HTTP</code> 请求大小？</p><p>❓ 减少 <code>HTTP</code> 请求</p><p>❓ 服务端渲染</p><h2 id="Google-首页案例学习"><a href="#Google-首页案例学习" class="headerlink" title="Google 首页案例学习"></a>Google 首页案例学习</h2><ul><li><code>HTML</code> 压缩</li><li><code>CSS</code> 压缩</li><li><code>JS</code> 的压缩和混淆</li><li>文件合并</li><li>开启 <code>gzip</code></li></ul><h3 id="HTML-压缩"><a href="#HTML-压缩" class="headerlink" title="HTML 压缩"></a>HTML 压缩</h3><p><code>HTML</code> 代码压缩就是压缩这些在文本文件中有意义，但是在 <code>HTML</code> 中不显示的字符，包括空格、制表符、换行符等，还有一些其他有意义的字符，如 <code>HTML</code> 注释也可以压缩。</p><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>后端模板引擎渲染压缩</li></ul><h3 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h3><ul><li>无效代码删除</li><li>css 语义合并</li></ul><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>使用 <code>clean-css</code></li></ul><h3 id="JS-的压缩和混淆"><a href="#JS-的压缩和混淆" class="headerlink" title="JS 的压缩和混淆"></a>JS 的压缩和混淆</h3><ul><li>无效字符的删除</li><li>剔除注释</li><li>代码语义的缩减和优化</li><li>代码保护</li></ul><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>使用 <code>uglifyjs2</code></li></ul><h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><p>![][2]</p><p>文件合并的弊端：</p><ul><li>首屏渲染问题</li><li>缓存失效问题 - 增加 <code>MD5</code> 戳，用来标识文件是否更改 - 采用文件合并会存在大面积缓存失效</li></ul><p>文件合并的策略：</p><ul><li>公共库合并</li><li>不同页面的合并 - 单页应用被路由到的时候才去请求 <code>JS</code></li><li>见机行事，随机应变</li></ul><p>合并的方法：</p><ul><li>使用在线网站进行合并</li><li><p>使用 <code>nodejs</code> 实现文件合并</p><p>[1]: <a href="https://help.aliyun.com/document_detail/27101.html?spm=a2c4g.11174283.2.3.85hgy4" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/27101.html?spm=a2c4g.11174283.2.3.85hgy4</a><br>[2]: <a href="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521771263712.jpg" target="_blank" rel="noopener">http://oudfgqwcq.bkt.clouddn.com/lyctea/1521771263712.jpg</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;[什么是 CDN–阿里云][1]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解减少 &lt;code&gt;HTTP&lt;/code&gt; 请求数量和减少请求资源大小的两个优化点&lt;/li&gt;
&lt;li&gt;掌握压缩与合并的原理&lt;/li&gt;
&lt;li&gt;掌握通过在线网站和 &lt;code&gt;fis3&lt;/code
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="文件压缩" scheme="https://luoyec.cn/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 迭代器与生成器</title>
    <link href="https://luoyec.cn/2018/03/21/cl4e29qcv002e989e1wx0tm2e/"/>
    <id>https://luoyec.cn/2018/03/21/cl4e29qcv002e989e1wx0tm2e/</id>
    <published>2018-03-21T08:58:44.000Z</published>
    <updated>2018-03-21T08:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-迭代器与生成器"><a href="#JavaScript-迭代器与生成器" class="headerlink" title="JavaScript 迭代器与生成器"></a>JavaScript 迭代器与生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>迭代器是一种检查容器内元素并遍历元素的数据类型。</strong></p><blockquote><p>迭代器（<code>iterator</code>）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p></blockquote><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>生成器( <code>generator</code> )是能返回一个迭代器的函数。</strong> 生成器函数由放在 function 关键字之 后的一个星号( * )来表示，并能使用新的 yield 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 在循环内遇到yield就会停止，指定再次调用next方法，将会在上次停止的位置继续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>关于生成器的几点注意事项：</p><ul><li><p>使用函数表达式来创建一个生成器，只要在 <code>function</code> 关键字与圆括号之间使用一个星号( * )</p></li><li><p>由于生成器就是函数，因此也可以被添加到对象中，下列两种方法是等价的。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span>*(<span class="params">items</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    *createIterator(items) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>不能将箭头函数创建为生成器</li></ul><h2 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h2><p>与迭代器紧密相关的是，可迭代对象( <code>iterable</code> )是包含 <code>Symbol.iterator</code> 属性的对象。这 个 <code>Symbol.iterator</code> 知名符号定义了为指定对象返回迭代器的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;&#125;, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h2><p>你可以使用 Symbol.iterator 来访问对象上的默认迭代器，就像这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>检查一个对象是否能够进行迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-迭代器与生成器&quot;&gt;&lt;a href=&quot;#JavaScript-迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 迭代器与生成器&quot;&gt;&lt;/a&gt;JavaScript 迭代器与生成器&lt;/h1&gt;&lt;h2 id=&quot;迭
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="迭代器" scheme="https://luoyec.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
      <category term="生成器" scheme="https://luoyec.cn/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 递归上</title>
    <link href="https://luoyec.cn/2018/03/08/cl4e29qcs0028989epgbtlkke/"/>
    <id>https://luoyec.cn/2018/03/08/cl4e29qcs0028989epgbtlkke/</id>
    <published>2018-03-08T01:01:16.000Z</published>
    <updated>2018-03-08T01:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://juejin.im/post/59c1d91d6fb9a00a53275f79" target="_blank" rel="noopener">翻译连载 | 第 9 章：递归（上）－《JavaScript轻量级函数式编程》 |《你不知道的JS》姊妹篇</a></p><h1 id="JavaScript-递归上"><a href="#JavaScript-递归上" class="headerlink" title="JavaScript 递归上"></a>JavaScript 递归上</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓递归，是当一个函数调用自身，并且该调用做了同样的事情，这个循环持续到基本条件满足时，调用循环返回。</p><blockquote><p>⚠️  <code>警告： 如果你不能确保基本条件是递归的 终结者，递归将会一直执行下去，并且会把你的项目损坏或锁死；恰当的基本条件十分重要！</code></p></blockquote><h2 id="直接递归"><a href="#直接递归" class="headerlink" title="直接递归"></a>直接递归</h2><blockquote><p>当一个函数调用自身时，很明显，这叫作直接递归</p></blockquote><h3 id="简单的函数递归"><a href="#简单的函数递归" class="headerlink" title="简单的函数递归"></a>简单的函数递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> foo(x / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><h3 id="求质数"><a href="#求质数" class="headerlink" title="求质数"></a>求质数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 判断一个数是否是质数：</span></span><br><span class="line"><span class="comment"> * 从2到 num 的平方根之间的每个整数，看是否存在某一整数可以整除 num (% 求余结果为 0)。</span></span><br><span class="line"><span class="comment"> * 如果存在这样的整数，那么 num 不是质数。反之，是质数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125;  num  被判断是否是质数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; divisor </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num, divisor = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出口，非质数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span> || (num &gt; <span class="number">2</span> &amp;&amp; num % divisor == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口，递归的条件</span></span><br><span class="line">    <span class="keyword">if</span> (divisor &lt;= <span class="built_in">Math</span>.sqrt(num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> isPrime(num, divisor + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出口，质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPrime(<span class="number">40</span>));</span><br></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fib</span><span class="params">( <span class="number">0</span> )</span></span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">( <span class="number">1</span> )</span></span>: <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">( n )</span></span>:</span><br><span class="line">    fib( n - <span class="number">2</span> ) + fib( n - <span class="number">1</span> )</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出口，当n小于等于1时，结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足，出口条件 ，持续递归</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">2</span>) + fib(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相互递归"><a href="#相互递归" class="headerlink" title="相互递归"></a>相互递归</h2><blockquote><p>如果在一个递归循环中，出现两个及以上的函数相互调用，则称之为相互递归。</p></blockquote><h3 id="求奇数偶数"><a href="#求奇数偶数" class="headerlink" title="求奇数偶数"></a>求奇数偶数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isEven(<span class="built_in">Math</span>.abs(v) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isOdd(<span class="built_in">Math</span>.abs(v) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">31</span>));</span><br></pre></td></tr></table></figure><h3 id="简单迭代改为递归"><a href="#简单迭代改为递归" class="headerlink" title="简单迭代改为递归"></a>简单迭代改为递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环求和</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; total 求和</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; nums 参数数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">total, ...nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total = total + nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求和</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; total 求和</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; nums 参数数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_sum</span>(<span class="params">num1, ...nums</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 每次取到传入的第一个参数，参数列表数量每次少一个</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">return</span> num1 + _sum(...nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_sum(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="找出入参最大偶数值"><a href="#找出入参最大偶数值" class="headerlink" title="找出入参最大偶数值"></a>找出入参最大偶数值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出入参最大偶数值</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; nums </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxEven</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; num) &#123;</span><br><span class="line">            num = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num !== -<span class="literal">Infinity</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 递归法，找出入参最大偶数值</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; num1 </span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; restNums </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_maxEven</span>(<span class="params">num1, ...restNums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxRest = restNums.length &gt; <span class="number">0</span> ? _maxEven(...restNums) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> (num1 % <span class="number">2</span> != <span class="number">0</span> || num1 &lt; maxRest) ? maxRest : num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_maxEven(<span class="number">9878</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">98</span>, <span class="number">65</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/59c1d91d6fb9a00a53275f79&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻译连载 | 第 9 章：递归（上）－《JavaScript轻量级函数式编程》
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="递归" scheme="https://luoyec.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins安装及基础配置</title>
    <link href="https://luoyec.cn/2018/03/07/cl4e29qde003k989etrduifg2/"/>
    <id>https://luoyec.cn/2018/03/07/cl4e29qde003k989etrduifg2/</id>
    <published>2018-03-07T01:55:41.000Z</published>
    <updated>2018-03-07T01:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p><a href="http://linux.it.net.cn/CentOS/course/2016/0502/21250.html" target="_blank" rel="noopener">CentOS 上安装 Jenkins</a><br><a href="https://pkg.jenkins.io/redhat/" target="_blank" rel="noopener">RedHat Linux RPM packages for Jenkins</a><br><a href="https://segmentfault.com/a/1190000004639923" target="_blank" rel="noopener">Jenkins+Node.js持续集成</a><br><a href="https://medium.com/risingstack-blog/getting-started-with-jenkins-and-node-f859934d0249" target="_blank" rel="noopener">Getting started with Jenkins and Node</a><br><a href="https://segmentfault.com/a/1190000002729796" target="_blank" rel="noopener">CentOS 7 安装 Gitlab</a><br><a href="http://www.cnblogs.com/dzblog/p/6930147.html" target="_blank" rel="noopener">Jenkins、Git ssh原理以及与https的区别</a><br><a href="https://segmentfault.com/a/1190000010154974" target="_blank" rel="noopener">Jenkins打包node项目步骤</a><br><a href="https://wiki.jenkins.io/display/JENKINS/NodeJS+Plugin" target="_blank" rel="noopener">NodeJS Plugin官方文档</a><br><a href="http://www.cnblogs.com/zipon/p/6206063.html" target="_blank" rel="noopener">jenkins publish over ssh使用</a></p><h1 id="Jenkins安装及基础配置"><a href="#Jenkins安装及基础配置" class="headerlink" title="Jenkins安装及基础配置"></a>Jenkins安装及基础配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Java-环境安装"><a href="#Java-环境安装" class="headerlink" title="Java 环境安装"></a>Java 环境安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure><h3 id="Jenkins-安装"><a href="#Jenkins-安装" class="headerlink" title="Jenkins 安装"></a>Jenkins 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo</span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key</span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><h4 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h4><p><code>jenkins</code> 安装目录，<code>WAR</code> 包会放在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jenkins</span><br></pre></td></tr></table></figure><p><code>jenkins</code> 配置文件，端口、<code>JENKINS_HOME</code> 等都可以在这里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><p>默认的 <code>JENKINS_HOME</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/jenkins/</span><br></pre></td></tr></table></figure><p><code>Jenkins</code> 日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/jenkins/jenkins.log</span><br></pre></td></tr></table></figure></p><h4 id="启动Jenkins"><a href="#启动Jenkins" class="headerlink" title="启动Jenkins"></a>启动Jenkins</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br><span class="line"></span><br><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure><h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518146884703.jpg" alt=""></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518161368952.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://linux.it.net.cn/CentOS/course/2016/0502/21250.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 上安装 Jenkins&lt;/a&gt;&lt;br
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Jenkins" scheme="https://luoyec.cn/tags/Jenkins/"/>
    
      <category term="ECS" scheme="https://luoyec.cn/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>NPM 数组模块学习与使用</title>
    <link href="https://luoyec.cn/2018/03/05/cl4e29qdn0040989ei0v4kr07/"/>
    <id>https://luoyec.cn/2018/03/05/cl4e29qdn0040989ei0v4kr07/</id>
    <published>2018-03-05T02:36:36.000Z</published>
    <updated>2018-03-05T02:37:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<br><a href="https://github.com/parro-it/awesome-micro-npm-packages" target="_blank" rel="noopener">awesome-micro-npm-packages</a></p><h1 id="NPM-数组模块学习与使用"><a href="#NPM-数组模块学习与使用" class="headerlink" title="NPM 数组模块学习与使用"></a>NPM 数组模块学习与使用</h1><table><thead><tr><th>类型</th><th>仓库地址</th><th>描述</th></tr></thead><tbody><tr><td>数组</td><td><a href="https://github.com/dcousens/is-sorted/blob/a8704a399c3a68ad08a1af3ec7f6186c9f4a613a/README.md" target="_blank" rel="noopener"><code>is-sorted</code></a></td><td>一个检查数组是否排序的小型模块</td></tr><tr><td>数组</td><td><a href="https://github.com/jonschlinkert/array-first" target="_blank" rel="noopener"><code>array-first</code></a></td><td>获取数组的第一个元素,可以传递一个长度参数，返回从头部开始指定长度的元素的数组</td></tr><tr><td>数组</td><td><a href="https://github.com/jonschlinkert/array-last" target="_blank" rel="noopener"><code>array-last</code></a></td><td>获取数组的最后一个元素,可以传递一个长度参数，返回从尾部开始指定长度的元素的数组</td></tr><tr><td>数组</td><td><a href="https://github.com/jonschlinkert/arr-flatten" target="_blank" rel="noopener"><code>arr-flatten</code></a></td><td>递归扁平化数组。特性：如果元素是数组，递归数组，如果不是数组，则加入到新数组中，最后返回</td></tr><tr><td>数组</td><td><a href="https://github.com/seriousManual/dedupe" target="_blank" rel="noopener"><code>dedupe</code></a></td><td>数组去重: 特性：支持字符型、数值型简单数组；数组对象，可传入判断方法执行判断 <code>key</code></td></tr><tr><td>数组</td><td><a href="https://github.com/mattdesl/array-range" target="_blank" rel="noopener"><code>array-range</code></a></td><td>产生指定范围的密集数组，可用于函数式编程</td></tr><tr><td>数组</td><td><a href="https://github.com/jonschlinkert/arr-diff" target="_blank" rel="noopener"><code>arr-diff</code></a></td><td>返回第一个数组的唯一值，比较时使用严格相等。特性：如果第二个参数不是数组，则无效返回原数组。实现：遍历数组，相同元素舍弃，存在多个数组，则循环多次</td></tr><tr><td>数组</td><td><a href="https://github.com/sindresorhus/filled-array" target="_blank" rel="noopener"><code>filled-array</code></a></td><td>使用指定的元素，生成数组，可以传递一个函数返回特定的元素</td></tr><tr><td>数组</td><td><a href="https://github.com/parro-it/map-array" target="_blank" rel="noopener"><code>map-array</code></a></td><td>遍历对象数组的元素 <code>key value</code> 加入到数组中</td></tr><tr><td>数组</td><td><a href="https://github.com/jonschlinkert/in-array" target="_blank" rel="noopener"><code>in-array</code></a></td><td>如果值存在于数组中，返回 <code>true</code>; 比 <code>indexOf</code> 速度更快，前不用担心 <code>null</code> 的问题</td></tr><tr><td>数组</td><td><a href="https://github.com/mafintosh/unordered-array-remove" target="_blank" rel="noopener"><code>unordered-array-remove</code></a></td><td>有效的移除数组元素，而不进行分割；算法实现元素最后一位出栈，对于元素进行交换，如果是最后的元素，直接返回</td></tr><tr><td>数组</td><td><a href="https://github.com/johnwquarles/mirrarray" target="_blank" rel="noopener"><code>mirrarray</code></a></td><td>通过数组的 <code>value</code> 快速创建 <code>key-value</code> 的对象， 键值重名</td></tr><tr><td>数组</td><td><a href="https://github.com/doowb/group-array" target="_blank" rel="noopener"><code>group-array</code></a></td><td>将对象数组分组到列表中</td></tr></tbody></table><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="号运算符隐式转换"><a href="#号运算符隐式转换" class="headerlink" title="+号运算符隐式转换"></a>+号运算符隐式转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">"12"</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组尾部，截取 n 长度，赋值给新数组</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    res[n] = arr[--len];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果元素是数组，递归数组，如果不是数组，则加入到新数组中，最后返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, cur;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    cur = arr[i];</span><br><span class="line">    <span class="built_in">Array</span>.isArray(cur) ? flat(cur, res) : res.push(cur);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递可选参数（函数）"><a href="#传递可选参数（函数）" class="headerlink" title="传递可选参数（函数）"></a>传递可选参数（函数）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断参数是否是函数</span></span><br><span class="line"><span class="keyword">var</span> isFn = <span class="keyword">typeof</span> item === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组对象是否有 fill 方法, ie不兼容</span></span><br><span class="line"><span class="keyword">if</span> (!isFn &amp;&amp; <span class="keyword">typeof</span> ret.fill === <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ret.fill(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断key是否属于-‘string’-‘number’-‘boolean’-‘undefined’-或-null-中的一种"><a href="#判断key是否属于-‘string’-‘number’-‘boolean’-‘undefined’-或-null-中的一种" class="headerlink" title="判断key是否属于 [‘string’, ‘number’, ‘boolean’, ‘undefined’] 或 null 中的一种"></a>判断key是否属于 [‘string’, ‘number’, ‘boolean’, ‘undefined’] 或 null 中的一种</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否属于 ['string', 'number', 'boolean', 'undefined'] 或 null 中的一种</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isValidKey = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isNull = element === <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'string'</span>, <span class="string">'number'</span>, <span class="string">'boolean'</span>, <span class="string">'undefined'</span>].includes(<span class="keyword">typeof</span> element) || isNull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查同一个-key-中不能有多个-value"><a href="#检查同一个-key-中不能有多个-value" class="headerlink" title="检查同一个 key 中不能有多个 value"></a>检查同一个 <code>key</code> 中不能有多个 <code>value</code></h3><p>实现思路，用对象存储已经保存的 <code>key</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nonOverlappingKey = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Ensure we don't have distinct elements that coerce to the same key, leading to unexpected results.</span></span><br><span class="line"><span class="comment">   * For example, input of [true, 'true'] would return a keymirror of &#123;true: 'true'&#125; despite containing two distinct elements</span></span><br><span class="line"><span class="comment">   * if we didn't make this check.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> isNull = element === <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> typeSeenBefore = keysSeen[<span class="string">''</span> + element];</span><br><span class="line">  <span class="keyword">const</span> thisType = isNull ? <span class="string">'null'</span> : <span class="keyword">typeof</span> element;</span><br><span class="line">  <span class="keyword">if</span> (typeSeenBefore) &#123;</span><br><span class="line">    <span class="keyword">return</span> typeSeenBefore === thisType;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keysSeen[<span class="string">''</span> + element] = thisType;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;https://github.com/parro-it/awesome-micro-npm-packages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;awesome-micro-npm-packages&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="模块" scheme="https://luoyec.cn/categories/%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="npm" scheme="https://luoyec.cn/tags/npm/"/>
    
      <category term="数组" scheme="https://luoyec.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign() 与 扩展操作符（...）</title>
    <link href="https://luoyec.cn/2018/02/27/cl4e29qdu004d989eixp0oy7t/"/>
    <id>https://luoyec.cn/2018/02/27/cl4e29qdu004d989eixp0oy7t/</id>
    <published>2018-02-27T02:49:38.000Z</published>
    <updated>2018-02-27T03:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN：<code>Object.assign()</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">MDN: <code>扩展操作符（...）</code></a></li><li><a href="https://leanpub.com/the-road-to-learn-react-chinese" target="_blank" rel="noopener">《React学习之道》扩展操作符 (可免费下载) </a></li></ul><h1 id="Object-assign-与-扩展操作符（…）"><a href="#Object-assign-与-扩展操作符（…）" class="headerlink" title="Object.assign() 与 扩展操作符（…）"></a>Object.assign() 与 扩展操作符（…）</h1><blockquote><p>React 提倡不可变的数据结构。因此你不应该改变一个对象(或者直接改变状态)。<br>更好的做法是基于现在拥有的资源来创建一个新的对象。这样就没有任何对象被改变了。<br>这样做的好处是数据结构将保持不变，因为你总是返回一个新对象，而之前的对象保持不变。</p></blockquote><p>简单说就是，不要直接修改对象属性，而是直接创建新的对象。<br>实现创建一个新的对象有两种方法，即：<code>Object.assign()</code> 与 扩展操作符（…）</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a><code>Object.assign()</code></h2><blockquote><p><code>Object.assign()</code> 函数来到达这样的目的。它把接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对 象中。<br>只要把目标对象设置成一个空对象，我们就得到了一个新的对象。这种做法是拥抱 不变性的，因为没有任何源对象被改变。</p></blockquote><h3 id="React-中的使用："><a href="#React-中的使用：" class="headerlink" title="React 中的使用："></a><code>React</code> 中的使用：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    result: <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.state.result, &#123; <span class="attr">hits</span>: updatedHits &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="其他使用方法"><a href="#其他使用方法" class="headerlink" title="其他使用方法"></a>其他使用方法</h3><p><strong>复制一个对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p><strong>深拷贝问题:</strong></p><p>针对深拷贝，需要使用其他方法，因为 <code>Object.assign()</code>拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改 obj2.b.c 发现 obj1、obj2 的属性都被修改了，因为他们保存的是对象的同一个引用</span></span><br><span class="line">obj2.b.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// &#123; a: 1, b: &#123; c: 3&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">// &#123; a: 2, b: &#123; c: 3&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确实现深拷贝的方式</span></span><br><span class="line">obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">obj1.a = <span class="number">4</span>;</span><br><span class="line">obj1.b.c = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3)); <span class="comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>合并对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1);  <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure><p><strong>合并具有相同属性的对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="扩展操作符（…）"><a href="#扩展操作符（…）" class="headerlink" title="扩展操作符（…）"></a>扩展操作符（…）</h2><blockquote><p>由三个点组成: <code>...</code> 。当使用它时，数组 或对象中的每一个值都会被拷贝到一个新的数组或对象。</p></blockquote><p><strong><code>React</code> 中使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    result: &#123; ...this.state.result, <span class="attr">hits</span>: updatedHits &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="https://luoyec.cn/tags/React/"/>
    
      <category term="纯函数" scheme="https://luoyec.cn/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins NodeJS Plugin 插件安装使用</title>
    <link href="https://luoyec.cn/2018/02/10/cl4e29qd9003c989eyqt50wv2/"/>
    <id>https://luoyec.cn/2018/02/10/cl4e29qd9003c989eyqt50wv2/</id>
    <published>2018-02-10T03:33:37.000Z</published>
    <updated>2018-02-10T03:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins-NodeJS-Plugin-插件安装使用"><a href="#Jenkins-NodeJS-Plugin-插件安装使用" class="headerlink" title="Jenkins NodeJS Plugin 插件安装使用"></a>Jenkins NodeJS Plugin 插件安装使用</h1><h2 id="NodeJS-Plugin-插件"><a href="#NodeJS-Plugin-插件" class="headerlink" title="NodeJS Plugin 插件"></a>NodeJS Plugin 插件</h2><p>官方 <code>WIKI</code>： <a href="https://wiki.jenkins.io/display/JENKINS/NodeJS+Plugin" target="_blank" rel="noopener"><code>NodeJS Plugin</code></a></p><p>主要特性：</p><ul><li>提供 <code>NodeJS</code> 的自动安装，可以创建并使用不同版本的 <code>NodeJS</code></li><li>允许在每个项目安装全局的 <code>npm</code> 包</li><li>安装完成后可以执行 <code>NodeJS</code> 脚本</li><li>可以使用定制的 <code>NPM</code> 用户配置文件</li><li>支持 <code>DSL pipeline</code></li></ul><h2 id="Jenkins-中设置"><a href="#Jenkins-中设置" class="headerlink" title="Jenkins 中设置"></a>Jenkins 中设置</h2><p><code>Jenkins: 系统管理 ---&gt; 全局工具配置 ---&gt; NodeJS</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518233196765.jpg" alt=""></p><p>新增安装，选择 <code>Install from nodejs.org</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518233213892.jpg" alt=""></p><p>选择安装版本，建议安装稳定支持版，这里选择<code>v8.9.4</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518233278359.jpg" alt=""></p><blockquote><p>⚠️ 配置的时候注意，安装方式选择后，如果要更改方式，请删除安装后再重新选择！</p></blockquote><p>一个完整的配置：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518233143929.jpg" alt=""></p><h2 id="在项目中选择-NodeJS"><a href="#在项目中选择-NodeJS" class="headerlink" title="在项目中选择 NodeJS"></a>在项目中选择 NodeJS</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518233539380.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins-NodeJS-Plugin-插件安装使用&quot;&gt;&lt;a href=&quot;#Jenkins-NodeJS-Plugin-插件安装使用&quot; class=&quot;headerlink&quot; title=&quot;Jenkins NodeJS Plugin 插件安装使用&quot;&gt;&lt;/a&gt;Je
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Jenkins" scheme="https://luoyec.cn/tags/Jenkins/"/>
    
      <category term="ECS" scheme="https://luoyec.cn/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins publish over ssh 插件使用</title>
    <link href="https://luoyec.cn/2018/02/10/cl4e29qdd003i989ei11viuv9/"/>
    <id>https://luoyec.cn/2018/02/10/cl4e29qdd003i989ei11viuv9/</id>
    <published>2018-02-10T03:06:25.000Z</published>
    <updated>2018-02-10T03:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<br><a href="http://www.cnblogs.com/zipon/p/6206063.html" target="_blank" rel="noopener">jenkins publish over ssh 使用</a><br><a href="http://blog.csdn.net/jiang1986829/article/details/51275361" target="_blank" rel="noopener">Jenkins 常用插件之 Publish Over SSH</a></p><h1 id="Jenkins-publish-over-ssh-插件使用"><a href="#Jenkins-publish-over-ssh-插件使用" class="headerlink" title="Jenkins publish over ssh 插件使用"></a>Jenkins publish over ssh 插件使用</h1><p>系统：<code>CentOS Linux release 7.4.1708 (Core)</code><br>服务器：<code>阿里云ECS</code></p><h2 id="远程服务器上生成密钥"><a href="#远程服务器上生成密钥" class="headerlink" title="远程服务器上生成密钥"></a>远程服务器上生成密钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>ssh-keygen</span><br></pre></td></tr></table></figure><p>一直默认，如果对安全不是特别苛刻，可以不设置 <code>parsepass</code>， 在 <code>/root/.ssh</code>目录下生成 <code>id_rsa.pub id_rsa</code> 公钥和私钥。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518230437773.jpg" alt=""></p><p>复制公钥文件 <code>id_rsa.pub</code> 改名为 <code>authorized_keys</code>,只有这个公钥里用户（<code>这里是root</code>）可以连接。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518230634260.jpg" alt=""></p><h2 id="将密钥复制到-Jenkins"><a href="#将密钥复制到-Jenkins" class="headerlink" title="将密钥复制到 Jenkins"></a>将密钥复制到 Jenkins</h2><p>检查 <a href="http://wiki.jenkins-ci.org/display/JENKINS/Publish+Over+SSH+Plugin" target="_blank" rel="noopener"><code>Publish Over SSH</code></a> 插件是否已经安装。</p><p>该插件主要是通过 <code>SSH</code> 连接其他 <code>Linux</code> 机器，远程传输文件及执行 <code>Shell</code> 命令。</p><p>特性：<br>1、<code>SCP</code>—通过 <code>SSH</code> 发送文件<br>2、在远程服务器执行 <code>shell</code> 命令<br>3、<code>Passwords/passphrases</code> 在配置文件及 UI 界面是加密显示的<br>4、<code>SSH</code> 可在项目编译前或编译后执行，与是否编译成功无关</p><p><code>Jenkins: 系统管理 ---&gt; 系统设置 ---&gt; Publish over SSH</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518230916101.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518231131796.jpg" alt=""></p><p>在项目中选择 <code>SSH</code> 服务</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518231838612.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/zipon/p/6206063.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jenkins publish over ssh 使用&lt;/a&gt;&lt;br&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Jenkins" scheme="https://luoyec.cn/tags/Jenkins/"/>
    
      <category term="ECS" scheme="https://luoyec.cn/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>React 事件处理</title>
    <link href="https://luoyec.cn/2018/01/28/cl4e29qdy004l989eess2yapw/"/>
    <id>https://luoyec.cn/2018/01/28/cl4e29qdy004l989eess2yapw/</id>
    <published>2018-01-27T17:23:29.000Z</published>
    <updated>2018-01-27T17:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://doc.react-china.org/docs/handling-events.html#%E5%90%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">事件处理（React 文档）</a></p><p><a href="https://zhuanlan.zhihu.com/p/27713910" target="_blank" rel="noopener">从 React 绑定 this，看 JS 语言发展和框架设计</a></p><h1 id="React-事件处理"><a href="#React-事件处理" class="headerlink" title="React 事件处理"></a>React 事件处理</h1><p>事件包含了许多细节，在实际开发中容易忽略，造成不是我们期望的结果，本文包含了这部分的细节，解决开发中遇到的 <code>React</code> 事件的问题。</p><h2 id="对比传统-HTML"><a href="#对比传统-HTML" class="headerlink" title="对比传统 HTML"></a>对比传统 HTML</h2><p><code>React</code> 元素的事件处理和 <code>DOM</code> 元素的很相似。但是有一点语法上的不同:</p><ul><li><code>React</code> 事件绑定属性的命名采用驼峰式写法，而不是小写。</li><li>如果采用 <code>JSX</code> 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串( <code>DOM</code> 元素的写法)</li></ul><p>传统的 <code>HTML</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p><code>React</code> 中稍稍有点不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h3><p>不能使用返回 <code>false</code> 的方式阻止默认行为。你必须明确的使用 <code>preventDefault</code></p><p>传统 <code>HTML</code> 中可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span><br><span class="line">    Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>React</code> 中应该这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"The link was clicked."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">        &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里的参数 <code>e</code> 是合成事件，<code>React</code> 根据 <code>W3C spec</code> 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。</p><h2 id="在-ES6-中的事件处理"><a href="#在-ES6-中的事件处理" class="headerlink" title="在 ES6 中的事件处理"></a>在 ES6 中的事件处理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">isToggleOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This binding is necessary to make `this` work in the callback</span></span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">            isToggleOn: !prevState.isToggleOn</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>&#125;</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。</code></p></blockquote><blockquote><p><code>这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。</code></p></blockquote><h2 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h2><h3 id="React-createClass-自动绑定"><a href="#React-createClass-自动绑定" class="headerlink" title="React.createClass 自动绑定"></a>React.createClass 自动绑定</h3><p><code>React.createClass</code> 创建的组件，可以自动绑定 <code>this</code>。也就是说，<code>this</code> 这个关键字会自动绑定在组件实例上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This magically works with React.createClass</span></span><br><span class="line"><span class="comment">// because `this` is bound for you.</span></span><br><span class="line">onChange = &#123;<span class="keyword">this</span>.handleChange&#125;</span><br></pre></td></tr></table></figure><p>当然很遗憾，对于组件的创建，官方已经推荐使用 <code>class</code> 声明组件或使用 <code>functional</code> 无状态组件</p><h3 id="渲染时绑定"><a href="#渲染时绑定" class="headerlink" title="渲染时绑定"></a>渲染时绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange = &#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure><p>有一个潜在的性能问题： <strong>当组件每次重新渲染时，都会有一个新的函数被创建</strong>。但在正常开发场景中，可以忽略。</p><h3 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange = &#123;e =&gt; <span class="keyword">this</span>.handleChange(e)&#125;</span><br></pre></td></tr></table></figure><p><strong>同样存在潜在的性能问题</strong></p><h3 id="Constructor-内绑定"><a href="#Constructor-内绑定" class="headerlink" title="Constructor 内绑定"></a>Constructor 内绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复而累赘</p><h3 id="Class-属性中使用-和箭头函数"><a href="#Class-属性中使用-和箭头函数" class="headerlink" title="Class 属性中使用 = 和箭头函数"></a>Class 属性中使用 = 和箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// call this function from render</span></span><br><span class="line">    <span class="comment">// and this.whatever in here works fine.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式的优点：</p><ul><li>使用箭头函数，有效绑定了 <code>this</code>；</li><li>没有第二种方法和第三种方法的潜在性能问题；</li><li>避免了方法四的组件实例重复问题；</li><li>我们可以直接从 <code>ES5 createClass</code> 重构得来。</li></ul><blockquote><p>这个方法依赖于 ES next 的新特性， 请参考：<a href="https://tc39.github.io/proposal-class-public-fields/" target="_blank" rel="noopener">tc39.github.io</a> &gt; <a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus/" target="_blank" rel="noopener">http://babeljs.io/blog/2015/06/07/react-on-es6-plus/</a> &gt; <a href="http://babeljs.io/blog/2015/10/31/setting-up-babel-6/" target="_blank" rel="noopener">http://babeljs.io/blog/2015/10/31/setting-up-babel-6/</a></p></blockquote><p>好消息是在 create-react-app 等工具中已经默认开启。</p><h2 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过 <code>arrow functions</code> 和 <code>Function.prototype.bind</code> 来为特定事件类型添加事件处理程序。</p><p>上面两个例子中，参数 <code>e</code> 作为 <code>React</code> 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><p>值得注意的是，通过 <code>bind</code> 方式向监听函数传参，在类组件中定义的监听函数，事件对象 <code>e</code> 要排在所传递参数的后面，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Popper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">"Hello world!"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preventPop(name, e) &#123;</span><br><span class="line">        <span class="comment">//事件对象e要放在最后</span></span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;hello&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>* Pass params via bind() method. *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;a</span></span><br><span class="line"><span class="regexp">                    href="https:/</span><span class="regexp">/reactjs.org"</span></span><br><span class="line"><span class="regexp">                    onClick=&#123;this.preventPop.bind(this, this.state.name)&#125;</span></span><br><span class="line"><span class="regexp">                &gt;</span></span><br><span class="line"><span class="regexp">                    Click</span></span><br><span class="line"><span class="regexp">                &lt;/</span>a&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="事件自动执行了？"><a href="#事件自动执行了？" class="headerlink" title="事件自动执行了？"></a>事件自动执行了？</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onClick=&#123;<span class="keyword">this</span>.onLoadQR(text)&#125;&gt;</span><br><span class="line">    &lt;Icon type=<span class="string">"qrcode"</span> /&gt;下载</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>这种写法是直接执行了函数，所以每一次渲染都会执行<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1517071841840.jpg" alt=""></p><p>而正确的行为是，我们应该在这里进行事件绑定，因为 <code>React</code> 不会进行自动绑定，具体方法看前文 “绑定 <code>this</code>”</p><h3 id="不写-this-为什么找不到方法？"><a href="#不写-this-为什么找不到方法？" class="headerlink" title="不写 this 为什么找不到方法？"></a>不写 <code>this</code> 为什么找不到方法？</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch defaultChecked onChange=&#123;onChangeSwitch(text)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>省略了 <code>this</code>, 此时方法虽然写在了 <code>class</code> 内，但是缺无法获取到，此时如果将方法写到 <code>class</code> 外，作为一个全局变量，但这个方法内部的 <code>this</code> 指向缺为 <code>undefined</code>。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1517073353376.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/docs/handling-events.html#%E5%90%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="react" scheme="https://luoyec.cn/tags/react/"/>
    
      <category term="事件" scheme="https://luoyec.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="ES6" scheme="https://luoyec.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>高性能 Webpack3 配置</title>
    <link href="https://luoyec.cn/2018/01/10/cl4e29qh900aq989eqbtrzoxc/"/>
    <id>https://luoyec.cn/2018/01/10/cl4e29qh900aq989eqbtrzoxc/</id>
    <published>2018-01-09T16:17:00.000Z</published>
    <updated>2018-01-09T16:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://www.codementor.io/drewpowers/high-performance-webpack-config-for-front-end-delivery-90sqic1qa" target="_blank" rel="noopener">High-performance webpack config for front-end delivery</a><br><a href="https://doc.webpack-china.org/guides/" target="_blank" rel="noopener">webpack3 指南</a></p><h1 id="高性能-Webpack-配置"><a href="#高性能-Webpack-配置" class="headerlink" title="高性能 Webpack 配置"></a>高性能 Webpack 配置</h1><h2 id="Scope-Hoisting-（作用域提升）"><a href="#Scope-Hoisting-（作用域提升）" class="headerlink" title="Scope Hoisting （作用域提升）"></a>Scope Hoisting （作用域提升）</h2><p><a href="https://doc.webpack-china.org/plugins/module-concatenation-plugin/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">官方文档：ModuleConcatenationPlugin</a></p><blockquote><p><code>过去 webpack 打包时的一个取舍是将 bundle 中各个模块单独打包成闭包。这些打包函数使你的 JavaScript 在浏览器中处理的更慢。相比之下，一些工具像 Closure Compiler 和 RollupJS 可以提升(hoist)或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。</code></p></blockquote><p>在生产环境中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面放一张用户使用之后包体的对比，大概减少了50%，对于模块数量很多的项目来说提升较大。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515342859153.jpg" alt=""></p><h2 id="Minification-and-Uglification-（压缩和丑化）"><a href="#Minification-and-Uglification-（压缩和丑化）" class="headerlink" title="Minification and Uglification （压缩和丑化）"></a>Minification and Uglification （压缩和丑化）</h2><p>代码压缩和“丑化”是生产环境中必不可少的，然而偶尔的会遗忘，所以在部署到生产环境之前，首先要做的就是检查代码是否经过压缩和“丑化”</p><h3 id="错误的方式"><a href="#错误的方式" class="headerlink" title="错误的方式"></a>错误的方式</h3><p>直接运行 <code>webpack</code> 命令进行打包，查看包体积</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515343660807.jpg" alt=""></p><h3 id="正确的方式"><a href="#正确的方式" class="headerlink" title="正确的方式"></a>正确的方式</h3><p>只需要在 <code>webpack</code> 命令后面加上 <code>-p</code> 参数！</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515343749164.jpg" alt=""></p><p>通过对比可以发现，减少了整整 60% 的体积！没有压缩前，充斥着空格、换行、注释！</p><p>📌 <code>-p</code> 参数不会设置 <code>node</code> 环境变量为生产环境 <code>production</code>，当你需要在生产环境中执行时，可使用该命令行：<code>NODE_ENV=production PLATFORM=web webpack -p</code></p><p>📌 为了快速打包，可以将参数添加到 <code>package.json</code> 中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack -p"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="高级压缩方式"><a href="#高级压缩方式" class="headerlink" title="高级压缩方式"></a>高级压缩方式</h3><p>使用 <a href="https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin" target="_blank" rel="noopener">UglifyjsWebpackPlugin</a> 插件<br>安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的配置已经很好的满足大部分的项目需求，但如何你想更进一步压缩，减少一部分不必要的代码，可以使用 <code>Webpack</code> 版本 &gt; 3.0：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;<span class="comment">/* options here */</span>&#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="Dynamic-Imports-for-Lazy-loaded-Modules-（动态引入和懒加载）"><a href="#Dynamic-Imports-for-Lazy-loaded-Modules-（动态引入和懒加载）" class="headerlink" title="Dynamic Imports for Lazy-loaded Modules （动态引入和懒加载）"></a>Dynamic Imports for Lazy-loaded Modules （动态引入和懒加载）</h2><h3 id="生产环境下的使用"><a href="#生产环境下的使用" class="headerlink" title="生产环境下的使用"></a>生产环境下的使用</h3><p>使用动态引入的项目，编译时：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515345588585.jpg" alt=""></p><p>可以看到之前整个的 <code>bundle.js</code> 文件被拆分了多个，在 <code>index.html</code> 中只引入了 <code>index.bundle.js</code> 作为入口，按需加载其他被拆分的js文件</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515345741144.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515345762947.jpg" alt=""></p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装 <code>Babel</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><p>配置 <code>webpack.config.js</code>，允许 <code>Babel</code> 处理你的 <code>js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>完成以上设置后，可以安装处理动态引入的插件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure><p>创建或修改 <code>.babelrc</code> 在项目的根目录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"syntax-dynamic-import"</span>, <span class="string">"transform-react-jsx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造代码"><a href="#改造代码" class="headerlink" title="改造代码"></a>改造代码</h3><p>将需要被改造成懒加载的模块做简单的代替：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home'</span>;</span><br></pre></td></tr></table></figure><p>with<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="keyword">import</span>(<span class="string">'./components/Home'</span>);</span><br></pre></td></tr></table></figure></p><p>最终我们的 <code>index.js</code> 入口文件被改造成了这样，这种 <code>import</code> 的方式只是一种语法糖，在一些框架中如 <code>vue</code> 已经得到支持</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Async <span class="keyword">from</span> <span class="string">'react-code-splitting'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Nav = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">Async</span> <span class="attr">load</span>=<span class="string">&#123;import(</span>'<span class="attr">.</span>/<span class="attr">components</span>/<span class="attr">Nav</span>')&#125; /&gt;</span>);</span></span><br><span class="line">const Home = () =&gt; (&lt;Async load=&#123;import('./views/home')&#125; /&gt;);</span><br><span class="line">const Countdown = () =&gt; (&lt;Async load=&#123;import('./views/countdown')&#125; /&gt;);</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>配置文件的出口和出口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  index: <span class="string">'./index.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Deterministic-Hashes-for-Caching（对缓存使用确定的Hash值）"><a href="#Deterministic-Hashes-for-Caching（对缓存使用确定的Hash值）" class="headerlink" title="Deterministic Hashes for Caching（对缓存使用确定的Hash值）"></a>Deterministic Hashes for Caching（对缓存使用确定的Hash值）</h2><p><code>webpack</code> 在默认的情况下不会自动添加 <code>hash</code>，例如 <code>app.8087f8d9fed812132141.js</code>，这意味着，数据保存在缓存个中，当用户刷新时不会得到更新。</p><p>在 <code>webpack</code>  快速添加 hashes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 注意这里有一个陷阱，每一次的构建，不管文件有没有更改都会重新声场新的 <code>hash</code> 值，例如在使用 <code>webpack -p</code> 时，即使用户已经已经下载相关文件，那么讲不得不刷新！</p></blockquote><blockquote><p>⚠️ 使用哈希值构建，将会降低编译的速度，请在生产环境中使用！</p></blockquote><h3 id="Deterministic-Hashes-配置"><a href="#Deterministic-Hashes-配置" class="headerlink" title="Deterministic Hashes 配置"></a>Deterministic Hashes 配置</h3><blockquote><p>📌这里我们需要解决的一个问题是，当内容改变到时候用户才会刷新缓存，如果没有改变，则不会去刷新缓存。</p></blockquote><p>插件安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add chunk-manifest-webpack-plugin webpack-chunk-hash</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.npmjs.com/package/chunk-manifest-webpack-plugin" target="_blank" rel="noopener"><code>chunk-manifest-webpack-plugin</code></a>: 允许导出一个json文件，将id映射到其中，webpack 会读取该json，以确定需要刷新缓存的模块<br><code>webpack-chunk-hash</code>: 使用自定义的（md5）代替标准的webpack 生成的 hash</p></blockquote><p>修改 <code>webpack.config.js</code> ，用于生产环境 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> ChunkManifestPlugin = <span class="built_in">require</span>(<span class="string">'chunk-manifest-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> WebpackChunkHash = <span class="built_in">require</span>(<span class="string">'webpack-chunk-hash'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Shared Dev &amp; Production */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">/* … our webpack config up until now */</span></span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// /* other plugins here */</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// /* Uncomment to enable automatic HTML generation */</span></span><br><span class="line">    <span class="comment">// new HtmlWebpackPlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   inlineManifestWebpackName: 'webpackManifest',</span></span><br><span class="line">    <span class="comment">//   template: require('html-webpack-template'),</span></span><br><span class="line">    <span class="comment">// &#125;),</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Production 指定了生产环境中使用 */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  config.output.filename = <span class="string">'[name].[chunkhash].js'</span>;</span><br><span class="line">  config.plugins = [</span><br><span class="line">    ...config.plugins, <span class="comment">// ES6 array destructuring, available in Node 5+</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> WebpackChunkHash(),</span><br><span class="line">    <span class="keyword">new</span> ChunkManifestPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'chunk-manifest.json'</span>,</span><br><span class="line">      manifestVariable: <span class="string">'webpackManifest'</span>,</span><br><span class="line">      inlineManifest: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>🌚  <strong>Tip</strong><br>对于上面的例子，当你使用 <code>yarn add html-webpack-plugin html-webpack-template</code> 模板时，会自动的添加注释，如果没有使用 webpack 的 HTML 模板，则需要手动的引入，引入方式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//&lt;![CDATA[</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.webpackManifest = &#123; <span class="comment">/* contents of chunk-manifest.json */</span> &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//]]&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的 <code>manifest.js</code> 也需要引入，当你设置好了这两个文件，那么一切准备就绪。</p><h2 id="CommonsChunkPlugin-for-Vendor-Caching"><a href="#CommonsChunkPlugin-for-Vendor-Caching" class="headerlink" title="CommonsChunkPlugin for Vendor Caching"></a>CommonsChunkPlugin for Vendor Caching</h2><blockquote><p><a href="https://doc.webpack-china.org/plugins/commons-chunk-plugin/#-" target="_blank" rel="noopener">CommonsChunkPlugin</a> ： <code>CommonsChunkPlugin</code> 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 <code>chunk</code> 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p></blockquote><p>一行代码的简单配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./app.js'</span>,</span><br><span class="line">    vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-router'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后运行 <code>webpack -p</code> </p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515478187585.jpg" alt=""></p><p>但是这种配置有个问题，这里的 <code>&#39;react&#39;, &#39;react-dom&#39;, &#39;react-router&#39;</code>， 会同时打包到 <code>index.bundle.js</code> 和 <code>vendor.bundle.js</code> 中</p><p>要解决上述问题，我们需要使用 <a href="https://doc.webpack-china.org/plugins/commons-chunk-plugin/#-" target="_blank" rel="noopener">CommonsChunkPlugin</a> 插件，将文件分离出来，在 <code>webpack.config.js</code> 中的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">'vendor'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 需要注意的是，插件中的name 要是 入口的名字匹配</p></blockquote><p>配置完成之后，重新打包，发现包体被拆分了！</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515512073646.jpg" alt=""></p><h2 id="Offline-Plugin-for-webpack（PWA）"><a href="#Offline-Plugin-for-webpack（PWA）" class="headerlink" title="Offline Plugin for webpack（PWA）"></a>Offline Plugin for webpack（PWA）</h2><p><a href="https://segmentfault.com/a/1190000010669126" target="_blank" rel="noopener">使用offline-plugin搭配webpack轻松实现PWA</a></p><p>此插件用于实现PWA，新技术，是否需要使用和探索，这里记录配置的方法，这并不复杂</p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add offline-plugin</span><br></pre></td></tr></table></figure><p>添加到r= <code>webpack config</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OfflinePlugin = <span class="built_in">require</span>(<span class="string">'offline-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// Adding to vendor recommended, but optional</span></span><br><span class="line">    vendor: [<span class="string">'offline-plugin/runtime'</span>, <span class="comment">/* … */</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OfflinePlugin(&#123;</span><br><span class="line">      AppCache: <span class="literal">false</span>,</span><br><span class="line">      ServiceWorker: &#123; <span class="attr">events</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，在 <code>app</code> 中的入口文件，在开始渲染之前使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> runtime = <span class="built_in">require</span>(<span class="string">'offline-plugin/runtime'</span>);</span><br><span class="line"></span><br><span class="line">  runtime.install(&#123;</span><br><span class="line">    onUpdateReady() &#123;</span><br><span class="line">      runtime.applyUpdate();</span><br><span class="line">    &#125;,</span><br><span class="line">    onUpdated() &#123;</span><br><span class="line">      <span class="built_in">window</span>.location.reload();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-Bundle-Analyzer（包分析工具）"><a href="#webpack-Bundle-Analyzer（包分析工具）" class="headerlink" title="webpack Bundle Analyzer（包分析工具）"></a>webpack Bundle Analyzer（包分析工具）</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515513197354.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p>添加到开发环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">config = &#123; /* shared webpack config */ &#125;;</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; process.env.NODE_ENV !== &apos;test&apos;) &#123;</span><br><span class="line">  config.plugins = [</span><br><span class="line">    ...config.plugins,</span><br><span class="line">    new BundleAnalyzerPlugin(),</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行并监听 8888 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_module/.bin/webpack --profile --json &gt; stats.json</span><br></pre></td></tr></table></figure><h2 id="Multi-entry-Automatic-CommonsChunk-Plugin（多页面应用程序）"><a href="#Multi-entry-Automatic-CommonsChunk-Plugin（多页面应用程序）" class="headerlink" title="Multi-entry Automatic CommonsChunk Plugin（多页面应用程序）"></a>Multi-entry Automatic CommonsChunk Plugin（多页面应用程序）</h2><p>应用场景不多，只记录下来。</p><p>webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &apos;./src/pageOne/index.js&apos;,</span><br><span class="line">    pageTwo: &apos;./src/pageTwo/index.js&apos;,</span><br><span class="line">    pageThree: &apos;./src/pageThree/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图。</p><p>为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：</p><ul><li><code>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</code></li></ul><p>We can update CommonsChunk to just figure things out automatically:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Dev &amp; Production */</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;commons&apos;,</span><br><span class="line">  minChunks: 2,</span><br><span class="line">&#125;),</span><br><span class="line">/* Production */</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;manifest&apos;,</span><br><span class="line">  minChunks: Infinity,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://www.codementor.io/drewpowers/high-performance-webpack-config-for-front-end-delivery-90sqic1qa&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="webpack3" scheme="https://luoyec.cn/tags/webpack3/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript脚本化文档下</title>
    <link href="https://luoyec.cn/2018/01/07/cl4e29qd80039989e7rulmfm9/"/>
    <id>https://luoyec.cn/2018/01/07/cl4e29qd80039989e7rulmfm9/</id>
    <published>2018-01-07T14:31:53.000Z</published>
    <updated>2018-01-07T14:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript脚本化文档下"><a href="#JavaScript脚本化文档下" class="headerlink" title="JavaScript脚本化文档下"></a>JavaScript脚本化文档下</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>HTML</code> 元素由一个标签和一组称为属性<code>（attribute）</code>的键值对组成。例如 <code>a</code> 标签的 <code>href</code> 属性，<code>img</code> 标签 <code>src</code> 属性</p><h3 id="HTML-属性作为-Element-的属性"><a href="#HTML-属性作为-Element-的属性" class="headerlink" title="HTML 属性作为 Element 的属性"></a>HTML 属性作为 Element 的属性</h3><p>表示 <code>HTML</code> 文档元素的 <code>HTML Element</code> 对象定义了读\写属性，它们映射了元素的 <code>HTML</code> 属性。</p><p><code>HTMLElement</code> 定义了通用的 <code>HTTP</code> 属性（如 <code>id</code>、标题 <code>lang</code> 和 <code>dir</code>）等属性，以及事件处理程序属性（如 <code>onclick</code>）。并且特定的类型元素定义了特定的属性。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = documment.getElementById(<span class="string">"myiamge"</span>)</span><br><span class="line"><span class="keyword">var</span> imgurl = images.src<span class="comment">//src属性是图片的URL</span></span><br><span class="line">image.id === <span class="string">"myimage"</span>  <span class="comment">//判定是否是要查找的图片id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似的，也可以设定表单提交的URL */</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.forms[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">f.action = <span class="string">"http://XXX"</span></span><br></pre></td></tr></table></figure><p>表示 <code>HTML</code> 属性的值通常是字符串，如 <code>input</code> 输出文本的值。 需要注意的是，这个属性是通过 <code>API</code>  来获取和设置的，并不能删除该属性。设想一下，没有有输入值的输出框。</p><h3 id="非标准的HTML属性"><a href="#非标准的HTML属性" class="headerlink" title="非标准的HTML属性"></a>非标准的HTML属性</h3><p> <code>Element</code> 类型定义了 <code>getAttribute()</code>和<code>setAttribute()</code> 方法来查询和设置非标准的 <code>HTML</code> 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> witth = <span class="built_in">parseInt</span>(image.getAttribute(<span class="string">'WIDTH'</span>))</span><br><span class="line"></span><br><span class="line">image.和setAttribute(<span class="string">'class'</span>, <span class="string">'thumbnail'</span>)</span><br></pre></td></tr></table></figure><p>通常情况下<code>getAttribute()</code> 返回字符串，并不会返回数值、布尔值、对象。对于 <code>HTML</code> 元素来说，属性名字不会区分大小写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test1111.getAttribute(<span class="string">'class'</span>)</span><br><span class="line"><span class="string">"xxx"</span></span><br><span class="line">test1111.getAttribute(<span class="string">'CLASS'</span>)</span><br><span class="line"><span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><p> <code>Element</code> 类型 定了其他两个相关方法，<code>hasAttribute()</code> 和  <code>remove Attribute()</code> ，用来检查命名属性是否存在和完全删除。</p><h2 id="元素的内容"><a href="#元素的内容" class="headerlink" title="元素的内容"></a>元素的内容</h2><h3 id="inerHTML-与-outerHTML-⚠️"><a href="#inerHTML-与-outerHTML-⚠️" class="headerlink" title="inerHTML 与 outerHTML ⚠️"></a>inerHTML 与 outerHTML ⚠️</h3><ul><li><p><code>inerHTML</code><br>  在元素上设置该属性，用新字符串内容替换元素当前内容</p></li><li><p><code>outerHTML</code></p><ul><li>查询 <code>outerHTML</code> 时，返回的字符串包含被查询元素的开头和结尾标签</li><li>在设置 <code>outerHTML</code> 时，元素本身将会被新内容替换</li></ul></li></ul><h3 id="作为纯文本"><a href="#作为纯文本" class="headerlink" title="作为纯文本"></a>作为纯文本</h3><p>在文档中插入纯文本，标准的方法是用 <code>Node</code> 的 <code>textContent</code> 属性来实现。</p><blockquote><p>⚠️ IE的兼容性 <code>&gt;= IE9</code>，在 <code>IE</code> 中，可以用 <code>innerText</code> 属性替代</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementByTagName(<span class="string">"p"</span>)[<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = para.textContent</span><br><span class="line"></span><br><span class="line">para.textContent = <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><h3 id="作为Text节点的元素内容"><a href="#作为Text节点的元素内容" class="headerlink" title="作为Text节点的元素内容"></a>作为Text节点的元素内容</h3><blockquote><p>❓ 作用不是很明确，<code>详见犀牛书p381</code></p></blockquote><h2 id="创建、插入和删除节点"><a href="#创建、插入和删除节点" class="headerlink" title="创建、插入和删除节点"></a>创建、插入和删除节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从指定的URL，异步加载和执行脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">"head"</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line"></span><br><span class="line">s.src = url</span><br><span class="line"></span><br><span class="line">head.appendChild(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节节点"><a href="#创建节节点" class="headerlink" title="创建节节点"></a>创建节节点</h3><ul><li><p><code>createElement()</code></p><ul><li>创建新的 <code>Element</code> 节点可以使用 <code>Document</code> 对象的 <code>createElement()</code> 方法。</li><li>给方法传递元素的标签名：对 <code>HTML</code> 文档来说该名字不区分大小写，对 <code>XML</code> 文档来说则需要区分大小写。</li></ul></li><li><p>创建 <code>Text</code> 节点</p><ul><li><code>var newnode = document.createTextNode(&quot;text node content&quot;)</code></li></ul></li></ul><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>一旦有了一个新节点，可以用 <code>appendChild()</code> 或 <code>insertBefore()</code>。</p><p><code>appendChild()</code> 是在需要插入的 <code>Element</code> 节点删调用</p><p><code>insertBefore()</code> 类似于前者，它需要接受两个参数，第一个参数就是待插入的节点，第二个参数是已经存在的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将child节点插入到parent中，使其成为第n个子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAt</span>(<span class="params">parent, child, n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( n &lt; <span class="number">0</span> || n &gt; parent.childNodes.length) </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"invalid index"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( n == parent.childNodes.length)</span><br><span class="line">parent.appendChild(child)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> parent.insertBefore(child, paretn.childNodes[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除和替换节点"><a href="#删除和替换节点" class="headerlink" title="删除和替换节点"></a>删除和替换节点</h3><p><code>removeChild()</code> 方法是从文档中删除一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.removeChild(n)</span><br></pre></td></tr></table></figure><p><code>replaceChild()</code> 方法删除一个子节点并用一个新节点取而代之。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.replaceChild(<span class="built_in">document</span>.createTextNode(<span class="string">"[ REDACTED ]"</span>), n)</span><br></pre></td></tr></table></figure><h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515333839746.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515333852350.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515333866340.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515333877334.jpg" alt=""></p><h2 id="文档和元素的几何形状和滚动"><a href="#文档和元素的几何形状和滚动" class="headerlink" title="文档和元素的几何形状和滚动"></a>文档和元素的几何形状和滚动</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询窗口滚动条的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffsets</span>(<span class="params">w</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 使用指定窗口，如果不带参数则使用当前窗口</span></span><br><span class="line">w = w || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了IE8 及更早的版本，其他浏览器都能用</span></span><br><span class="line"><span class="keyword">if</span> (w.pageXOffset != <span class="literal">null</span>) </span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">x</span>: w.pageXOffset, <span class="attr">y</span>: w.pageYOffset&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对标准模式下的IE</span></span><br><span class="line"><span class="keyword">var</span> d  = w.document</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"css1Compat"</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">x</span>: d.documentElement.scrollLeft, <span class="attr">y</span>: d.documentElement.scrollTop&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对怪异模式下的浏览器</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">x</span>: d.body.scrollleft, <span class="attr">y</span>: d.body.scrollTop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得在视口坐标中的位置，返回left、right、top、bottom属性的对象</span></span><br><span class="line"><span class="keyword">var</span> box = e.getBoundingClientRect()</span><br></pre></td></tr></table></figure><h3 id="判断元素在某点"><a href="#判断元素在某点" class="headerlink" title="判断元素在某点"></a>判断元素在某点</h3><p><code>getBoundingClientRect()</code> 方法能确定元素在视口中的位置</p><p><code>elementFromPoint()</code> 方法判定视口指定位置有什么元素</p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得文档和视口的高度，offsetHeight会在下面解释</span></span><br><span class="line"><span class="keyword">var</span> documentHeight = <span class="built_in">document</span>.documentElement.offsetHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后滚动让最后一页在视口中可见</span></span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, documentheight - viewprotHeight)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript脚本化文档下&quot;&gt;&lt;a href=&quot;#JavaScript脚本化文档下&quot; class=&quot;headerlink&quot; title=&quot;JavaScript脚本化文档下&quot;&gt;&lt;/a&gt;JavaScript脚本化文档下&lt;/h1&gt;&lt;h2 id=&quot;属性&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="脚本文档化" scheme="https://luoyec.cn/tags/%E8%84%9A%E6%9C%AC%E6%96%87%E6%A1%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 服务器安装 Node.js</title>
    <link href="https://luoyec.cn/2018/01/06/cl4e29qc0000l989e8ysg4p1r/"/>
    <id>https://luoyec.cn/2018/01/06/cl4e29qc0000l989e8ysg4p1r/</id>
    <published>2018-01-06T06:51:49.000Z</published>
    <updated>2018-01-06T07:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://help.aliyun.com/document_detail/50775.html?spm=5176.11065259.1996646101.searchclickresult.684461bBxtQKv" target="_blank" rel="noopener">部署 Node.js 项目（CentOS）阿里云文档</a><br><a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a><br><a href="https://nodejs.org/dist/v8.9.4/" target="_blank" rel="noopener">Node.js 官方下载地址，可以通过wget下载</a></p><h1 id="CentOS7-服务器安装-Node-js"><a href="#CentOS7-服务器安装-Node-js" class="headerlink" title="CentOS7 服务器安装 Node.js"></a>CentOS7 服务器安装 Node.js</h1><p><code>wget</code> 命令下载 <code>Node.js</code> 安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>解压文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v8.9.4-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>创建软链接，使 <code>node</code> 和 <code>npm</code> 命令全局有效<br>⚠️ 注意一定要使用绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/node-v8.9.4-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line"></span><br><span class="line">ln -s /root/node-v8.9.4-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line"></span><br><span class="line">ln -s /root/node-v8.9.4-linux-x64/bin/npx /usr/local/bin/npx</span><br><span class="line"></span><br><span class="line">// ⚠️ 删除错误创建的软连接</span><br><span class="line"><span class="meta">#</span>rm /usr/local/bin/node</span><br></pre></td></tr></table></figure><p>查看<code>node、npm</code>版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>添加环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export NODE_PATH=/root/node-v8.9.4-linux-x64/bin</span><br><span class="line"></span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;NODE_PATH&#125;</span><br><span class="line"></span><br><span class="line">// ⚠️ 这里不输出到 ~/.profile ， 属于临时文件，配置不能持久</span><br><span class="line">echo "PATH=\$&#123;PATH&#125;:$&#123;NODE_PATH&#125;" &gt; /etc/profile</span><br></pre></td></tr></table></figure><p>安装 <code>cnpm</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/50775.html?spm=5176.11065259.1996646101.searchclickresult.684461bBxtQKv&quot; target=&quot;
      
    
    </summary>
    
      <category term="node" scheme="https://luoyec.cn/categories/node/"/>
    
    
      <category term="CentOS" scheme="https://luoyec.cn/tags/CentOS/"/>
    
      <category term="服务器" scheme="https://luoyec.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Node.js" scheme="https://luoyec.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 服务器安装 MySQL</title>
    <link href="https://luoyec.cn/2018/01/06/cl4e29qbx000f989evi9hay5x/"/>
    <id>https://luoyec.cn/2018/01/06/cl4e29qbx000f989evi9hay5x/</id>
    <published>2018-01-06T04:24:04.000Z</published>
    <updated>2018-01-06T04:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>扩展阅读：<br><a href="https://linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7/" target="_blank" rel="noopener">How to Install MySQL on CentOS 7</a><br><a href="https://help.aliyun.com/document_detail/25471.html?spm=5176.100241.0.0.50a98379QuiDtB" target="_blank" rel="noopener">云服务器 ECS &gt; 用户指南 &gt; 安全组 &gt; 添加安全组规则</a><br><a href="http://www.jb51.net/article/47727.htm" target="_blank" rel="noopener">MySQL安全配置向导mysql_secure_installation详解</a><br><a href="https://www.cnblogs.com/starof/p/4680083.html" target="_blank" rel="noopener">centos7 mysql数据库安装和配置</a></p><h1 id="CentOS7-服务器安装-MySQL"><a href="#CentOS7-服务器安装-MySQL" class="headerlink" title="CentOS7 服务器安装 MySQL"></a>CentOS7 服务器安装 MySQL</h1><blockquote><p>😯  本文档是基于非 root 用户的，需要 sudo 前缀以提升权限，如果是 root 用户，则可忽略该前缀。<br>使用阿里云ECS，需要配置安全组规则，详见文档具体章节。</p></blockquote><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>检查你的主机状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root]#</span> hostname// 短主机名</span><br><span class="line">iZwz97v8o1cbogw4uplc4dZ</span><br><span class="line"><span class="meta">[root]#</span> hostname -f// 同时带有主机名和域名的名称</span><br><span class="line">iZwz97v8o1cbogw4uplc4dZ</span><br></pre></td></tr></table></figure><p>更新系统的 <code>yum</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>安装 <code>wget</code> ，用以完成 <code>MySQL</code> 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><blockquote><p><code>Yum (全称为：Yellow dog Updater, Modified) 由Duke University团队，修改Yellow DogLinux的Yellow Dog Updater开发而成，是一个基于RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。被Yellow DogLinux本身，以及Fedora、Red Hat Enterprise Linux采用。</code></p></blockquote><blockquote><p><code>GNU Wget是一个在网络上进行下载的简单而强大的自由软件，其本身也是GNU计划的一部分。它的名字是“World WideWeb”和“Get”的结合，同时也隐含了软件的主要功能。目前它支持通过HTTP、HTTPS，以及FTP这三个最常见的TCP/IP协议协议下载。</code></p></blockquote><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>下载和安装仓库，并且使用yum更新它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><p>安装 <code>MySQL</code> 服务，遇到校验时，如果没有错误或匹配错误请选择 <code>y</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-server// 安装服务</span><br><span class="line"></span><br><span class="line">sudo systemctl start mysqld // 启动服务</span><br></pre></td></tr></table></figure><p><code>MySQL</code> 默认绑定 <code>localhost (127.0.0.1)</code>，了解使用 <code>ssh</code> 连接到数据库的信息。</p><p><a href="https://linode.com/docs/databases/mysql/create-an-ssh-tunnel-for-mysql-remote-access/" target="_blank" rel="noopener">MySQL remote access guide</a></p><blockquote><p>⚠️  <code>MySQL</code> 不建议不设限制地通过公共IP连接，你可以修改配置文件 <code>/etc/my.cnf</code>以更改监听地址，如果决定将MySQL绑定到公共IP，则应该实现只允许特定IP地址的连接的防火墙规则。</p></blockquote><h2 id="安全配置向导-Harden-MySQL-Server"><a href="#安全配置向导-Harden-MySQL-Server" class="headerlink" title="安全配置向导(Harden MySQL Server)"></a>安全配置向导(Harden MySQL Server)</h2><p>运行 <code>mysql_secure_installation</code> 设置默认的 <code>MySQL</code> 安全问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 第一次配置时，没有给 <code>root</code> 用户设置密码，直接回车可以设置初始密码。</p></blockquote><p>具体的设置规则：</p><ul><li>为 <code>root</code> 用户设置密码</li><li>删除匿名账号</li><li>取消 <code>root</code> 用户远程登录</li><li>删除 <code>test</code> 库和对 <code>test</code> 库的访问权限</li><li>刷新授权表使修改生效</li></ul><p>可以参考：<a href="http://www.jb51.net/article/47727.htm" target="_blank" rel="noopener">MySQL安全配置向导mysql_secure_installation详解</a></p><h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><h3 id="Root-用户登录"><a href="#Root-用户登录" class="headerlink" title="Root 用户登录"></a>Root 用户登录</h3><ul><li><code>root</code> 登录 <code>MySQL</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515209938448.jpg" alt=""></p><ul><li>生成 <code>MySQL</code> 命令提示列表  <code>\h</code><br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515210074360.jpg" alt=""></li></ul><h3 id="创建一个新的-MySQL-用户-和-仓库"><a href="#创建一个新的-MySQL-用户-和-仓库" class="headerlink" title="创建一个新的 MySQL 用户 和 仓库"></a>创建一个新的 MySQL 用户 和 仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// testdb 为数据库名</span><br><span class="line">create database testdb; </span><br><span class="line"></span><br><span class="line"> // testuser 用户名；password：密码</span><br><span class="line">create user 'testuser'@'localhost' identified by 'password'; </span><br><span class="line"></span><br><span class="line">// 赋予testuser用户所有权限</span><br><span class="line">grant all on testdb.* to 'testuser' identified by 'password';</span><br></pre></td></tr></table></figure><p>以上命令可以缩短为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database testdb;</span><br><span class="line"></span><br><span class="line">grant all on testdb.* to 'testuser' identified by 'password';</span><br></pre></td></tr></table></figure><p>完成后退出 <code>MySQL</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="创建一个简单表"><a href="#创建一个简单表" class="headerlink" title="创建一个简单表"></a>创建一个简单表</h3><p>使用之前创建的 <code>testuser</code> 用户登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u testuser -p</span><br></pre></td></tr></table></figure><p>创建简单的表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use testdb;</span><br><span class="line"></span><br><span class="line">create table customers (customer_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, first_name TEXT, last_name TEXT);enter code here</span><br></pre></td></tr></table></figure></p><h3 id="重设-ROOT-密码"><a href="#重设-ROOT-密码" class="headerlink" title="重设 ROOT 密码"></a>重设 ROOT 密码</h3><p><code>root</code> 用户登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>切换到mysql ，重置密码，并且刷新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">update user SET PASSWORD=PASSWORD("password") WHERE USER='root';</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>重启 <code>MySQL</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><h3 id="远程连接设置"><a href="#远程连接设置" class="headerlink" title="远程连接设置"></a>远程连接设置</h3><p>把在所有数据库的所有表的所有权限赋值给位于所有 <code>IP</code> 地址的 <code>root</code> 用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> grant all privileges on *.* to root@'%'identified by 'password';</span><br></pre></td></tr></table></figure><p>如果是新用户而不是root，则要先新建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span>create user 'username'@'%' identified by 'password';</span><br></pre></td></tr></table></figure><p>此时就可以进行远程连接了。</p><h3 id="⚠️-阿里云添加安全组规则"><a href="#⚠️-阿里云添加安全组规则" class="headerlink" title="⚠️ 阿里云添加安全组规则"></a>⚠️ 阿里云添加安全组规则</h3><p><a href="https://help.aliyun.com/document_detail/25471.html?spm=5176.100241.0.0.50a98379QuiDtB" target="_blank" rel="noopener">云服务器 ECS &gt; 用户指南 &gt; 安全组 &gt; 添加安全组规则</a></p><p>常用端口选择 <code>MySQL 3306</code> 授权对象为 <code>0.0.0.0/0</code></p><h3 id="Navicat-连接"><a href="#Navicat-连接" class="headerlink" title="Navicat 连接"></a><code>Navicat</code> 连接</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1515212296430.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;扩展阅读：&lt;br&gt;&lt;a href=&quot;https://linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to Instal
      
    
    </summary>
    
      <category term="mysql" scheme="https://luoyec.cn/categories/mysql/"/>
    
    
      <category term="CentOS" scheme="https://luoyec.cn/tags/CentOS/"/>
    
      <category term="MySQL" scheme="https://luoyec.cn/tags/MySQL/"/>
    
      <category term="服务器" scheme="https://luoyec.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>YEOMAN实践一</title>
    <link href="https://luoyec.cn/2018/01/02/cl4e29qep005y989e8dv9egi7/"/>
    <id>https://luoyec.cn/2018/01/02/cl4e29qep005y989e8dv9egi7/</id>
    <published>2018-01-02T01:16:45.000Z</published>
    <updated>2018-01-02T01:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>拓展阅读：<br><a href="http://yeoman.io/" target="_blank" rel="noopener"> YEOMAN 官方文档</a><br><a href="https://juejin.im/entry/58f41ccd61ff4b0058fc64f8" target="_blank" rel="noopener">用 node.js 开发一个可交互的命令行应用</a><br><a href="https://segmentfault.com/a/1190000005827971" target="_blank" rel="noopener">yeoman-generator 入门教程</a></p><hr><h1 id="YEOMAN实践"><a href="#YEOMAN实践" class="headerlink" title="YEOMAN实践"></a>YEOMAN实践</h1><h2 id="如何使用社区的-generator"><a href="#如何使用社区的-generator" class="headerlink" title="如何使用社区的 generator"></a>如何使用社区的 <code>generator</code></h2><p><a href="http://yeoman.io/generators/" target="_blank" rel="noopener">在这里查找社区 generator</a></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514731522486.jpg" alt=""></p><p><code>name</code> 代指选择的 <code>generator</code> </p><p>安装： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g generator-name</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo generator-name</span><br></pre></td></tr></table></figure><p>配置提示，一般情况选择 <code>overwrite</code>：<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514731653905.jpg" alt=""></p><blockquote><p>⚠️ 当发现安装的项目路径不是当前文件夹，是 <code>home</code> 目录或者其他，检查 父目录中的 <code>.yo-rc.json</code> ，并删除它</p></blockquote><h2 id="创建自己的-generator"><a href="#创建自己的-generator" class="headerlink" title="创建自己的 generator"></a>创建自己的 <code>generator</code></h2><p>参照这篇文档 <a href="https://segmentfault.com/a/1190000005827971" target="_blank" rel="noopener">yeoman-generator 入门教程</a></p><p>⚠️  需要注意几个点：</p><ul><li>项目文件名和 <code>generator</code> 名称要一致</li><li>目录层次可以有两种，但需要在 <code>package.json</code>  <code>files</code> 字段中加以区分</li><li>需要执行 <code>yo link</code> 建立软连接</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;拓展阅读：&lt;br&gt;&lt;a href=&quot;http://yeoman.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; YEOMAN 官方文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.im/entry/58f41ccd61f
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="脚手架" scheme="https://luoyec.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
      <category term="yeoman" scheme="https://luoyec.cn/tags/yeoman/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件处理下</title>
    <link href="https://luoyec.cn/2017/12/26/cl4e29qcz002p989el8ldd6ye/"/>
    <id>https://luoyec.cn/2017/12/26/cl4e29qcz002p989el8ldd6ye/</id>
    <published>2017-12-26T14:35:21.000Z</published>
    <updated>2017-12-26T15:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript注册事件处理下"><a href="#JavaScript注册事件处理下" class="headerlink" title="JavaScript注册事件处理下"></a>JavaScript注册事件处理下</h1><p>注册事件处理程序有两种基本方式，第一种是给目标对象或文档元素设置属性。第二种更为通用，是将事件处理程序传递给对象或元素的一个方法。</p><p>可以在 <code>JavaScript</code> 代码中设置事件处理程序的对象属性，或对于文档流元素，可以在 <code>HTML</code> 中直接设置相应属性。对于通过方法调用的处理程序注册，有个标准方法 <code>addEventListenter()</code>， <code>IE8</code> 及以前版本的之外都支持，在   <code>IE9</code> 之前有个另一个方法  <code>attachEvent()</code></p><h2 id="设置-JavaScript-对象属性为事件处理程序"><a href="#设置-JavaScript-对象属性为事件处理程序" class="headerlink" title="设置 JavaScript 对象属性为事件处理程序"></a>设置 JavaScript 对象属性为事件处理程序</h2><p>注册事件处理程序最简单的方式就是通过设置事件目标的属性为所需事件处理程序函数。区分大小写，并且都是小写，如 <code>onclick、onchange、onload、onmouseover</code> 等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置window 对象的 unload 属性为一个函数</span></span><br><span class="line"><span class="comment">//当文档加载完毕时调用它</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，所有广泛实现的 <code>Web API</code> 定义的事件都允许通过设置事件处理程序属性来注册事件处理程序。</p><p>缺点是每个事件目标对于每种事件类型将最多只有一个处理程序，如果想要编写能再任意文档中使用的脚本库代码，更好的方式是使用一种不修改或者覆盖任何已有注册事件程序的技术，例如 <code>addEventListenner()</code></p><h2 id="设置-HTML-标签属性为事件处理程序"><a href="#设置-HTML-标签属性为事件处理程序" class="headerlink" title="设置 HTML 标签属性为事件处理程序"></a>设置 HTML 标签属性为事件处理程序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"alert('THANK YOU!')"</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这里有几个特点：</p><ul><li>属性值是 <code>JavaScript</code> 代码字符串</li><li>这段代码是处理程序函数的主题，而非完整的函数声明</li><li>不应该使用大括号包裹和 <code>function</code> 关键字作为前缀</li><li>多条语句用 <code>;</code> 隔开</li></ul><h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h2><p>注意前面提到的兼容性问题。</p><p>Window对象、Document 对象和所有文档元素都可以使用 addEventListener()</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变t2的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modifyText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t2 = <span class="built_in">document</span>.getElementById(<span class="string">"t2"</span>);</span><br><span class="line">  <span class="keyword">if</span> (t2.firstChild.nodeValue == <span class="string">"three"</span>) &#123;</span><br><span class="line">    t2.firstChild.nodeValue = <span class="string">"two"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    t2.firstChild.nodeValue = <span class="string">"three"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为table添加事件监听器</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"outside"</span>);</span><br><span class="line">el.addEventListener(<span class="string">"click"</span>, modifyText, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h3><p>删除使用 <code>EventTarget.addEventListener()</code> 方法添加的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* do something here */</span></span><br><span class="line">&#125;;</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="attach……Event"><a href="#attach……Event" class="headerlink" title="attach……Event()"></a>attach……Event()</h2><p>这是早期IE浏览器（IE8及早期版本）的一个专有的替代性标准，替代 <code>EventTarget.addEventListener()</code> 方法</p><blockquote><p>⚠️  非标准 该特性是非标准的，请尽量不要在生产环境中使用它！<br>HEXO中不能出现此方法，会报错导致页面无法显示</p></blockquote><ul><li>因为IE 模型不支持事件捕获，所以只有两个参数：事件类型和处理函数</li><li>带on前缀，要给该方法传递 ‘onclick’</li><li>允许相同事件注册多次，也会被调用多次</li></ul><h1 id="事件处理程序的调用"><a href="#事件处理程序的调用" class="headerlink" title="事件处理程序的调用"></a>事件处理程序的调用</h1><p>本节也会说明事件的传播机制，即单个事件如何能在原始目标和文档容器上触发多个处理程序的调用。</p><h2 id="事件处理程序的参数"><a href="#事件处理程序的参数" class="headerlink" title="事件处理程序的参数"></a>事件处理程序的参数</h2><p>通常调用事件处理程序时会把事件对象作为它们的一个参数，提高有关事件的详细信息。</p><p>一个 <code>IE8</code> 以前版本中，获取事件对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">event = event || <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件处理程序的运行环境"><a href="#事件处理程序的运行环境" class="headerlink" title="事件处理程序的运行环境"></a>事件处理程序的运行环境</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* 处理程序代码 */</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>在事件处理程序中，<code>this</code> 关键字指的是事件目标</li><li>当使用 <code>addEventListener()</code> 注册时，也是一样</li><li>但对于 <code>attachEvent()</code>， <code>this</code> 却是 全局对象 <code>Window</code>，兼容的方法在书中有举例</li></ul><h2 id="事件处理程序返回值"><a href="#事件处理程序返回值" class="headerlink" title="事件处理程序返回值"></a>事件处理程序返回值</h2><p>通常情况下，返回 <code>false</code> 就是告诉浏览器不要执行这个事件相关的默认操作</p><p><code>window.onbeforeunload()</code> : 当浏览器将要跳转到新页面时触发，如果返回一个字符串，那么将会出现在询问用户是否离开当前页面的标准对话框中（有兼容性问题，并不是所有浏览器都可以自定义提示信息，更多是浏览器标准提示）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 兼容IE8和Firefox 4之前的版本</span></span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">    e.returnValue = <span class="string">'关闭提示'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'关闭提示'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514131995800.jpg" alt=""></p><h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><ul><li>通过设置对象属性或 <code>HTML</code> 属性注册的处理程序一直优先调用</li><li>使用 <code>addEventListener()</code> 注册的处理程序按照它们的注册顺序调用</li><li>使用 <code>attachEvent()</code> 注册的处理程序可能按照任何顺序调用，所有代码不应该依赖于调用顺序</li></ul><h1 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h1><p>当事件目标是 <code>Window</code> 对象或其他一些单独对象（比如 <code>XMLHttpRequest</code> ）时，浏览器简单通过调用对象上适当的处理程序响应事件。</p><p>但当事件目标是文档或文档元素时，情况较为复杂。</p><p>大部分的事件都会“冒泡”到 <code>DOM</code> 树根，层层向上传递，事件冒泡为在大量单独文档元素上注册处理程序提供了代替方案，即在共同的祖先元素上注册一个处理程序来处理所有事件。</p><h2 id="📍-事件传播的三个阶段："><a href="#📍-事件传播的三个阶段：" class="headerlink" title="📍 事件传播的三个阶段："></a>📍 事件传播的三个阶段：</h2><ul><li>第一阶段发生在目标处理程序调用之前，称为 “捕获”阶段，回顾上文 <code>addEventListener()</code> 的第三个参数，注意兼容性问题</li><li>第二阶段是目标对象本身的事件处理程序的调用</li><li>第三阶段是事件冒泡</li></ul><p>事件捕获提供了在事件没有送达目标之前查看他们的机会。能用于程序调试、事件取消技术过滤掉事件从而使目标事件程序绝不会被调用、处理鼠标拖放</p><h1 id="事件取消"><a href="#事件取消" class="headerlink" title="事件取消"></a>事件取消</h1><p>在支持 <code>addEventListener()</code> 的浏览器中，可以通过调用事件对象的 <code>preventDefaultDefault()</code> 方法取消事件的默认操作， <code>IE9</code> 之前，可以通过设置事件对象的 <code>returnValue</code> 属性为 <code>false</code> 达到相同效果。</p><p>在支持 <code>addEventListener()</code> 的浏览器中，<code>stopPropagation()</code> 方法阻止事件的继续传播，<code>IE9</code> 之前， 使用 <code>cancelBubble()</code> </p><h1 id="具体的事件类别"><a href="#具体的事件类别" class="headerlink" title="具体的事件类别"></a>具体的事件类别</h1><p>至此，已经学习了 <code>JavaScript</code> 事件处理的基本原理，针对于具体的事件，请查阅犀牛书相关章节</p><ul><li>文档加载事件</li><li>鼠标事件</li><li>鼠标滚轮事件</li><li>拖放事件</li><li>文本事件</li><li>键盘事件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript注册事件处理下&quot;&gt;&lt;a href=&quot;#JavaScript注册事件处理下&quot; class=&quot;headerlink&quot; title=&quot;JavaScript注册事件处理下&quot;&gt;&lt;/a&gt;JavaScript注册事件处理下&lt;/h1&gt;&lt;p&gt;注册事件处理程序有两
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://luoyec.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript脚本化文档上</title>
    <link href="https://luoyec.cn/2017/12/26/cl4e29qdb003f989ejhik7ys6/"/>
    <id>https://luoyec.cn/2017/12/26/cl4e29qdb003f989ejhik7ys6/</id>
    <published>2017-12-26T14:28:16.000Z</published>
    <updated>2017-12-26T14:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>《 <code>JavaScript</code> 权威指南 第十五章》</p><p>本文介绍了文档的概念，以及如何获取问题，Node 节点的属性，如何通过Node属性快速定位的相关节点。</p><h1 id="JavaScript脚本化文档"><a href="#JavaScript脚本化文档" class="headerlink" title="JavaScript脚本化文档"></a>JavaScript脚本化文档</h1><p>每个 <code>Window</code> 对象由一个 <code>document</code> 属性引用了 <code>Document</code> 对象，它是一个巨大的 <code>API</code> 中的核心对象，就做文档模型，它代表和操作文档的内容。<br>本章涉及到的知识点：</p><ul><li>如何在文档中查询或选取单独的元素</li><li>如何将文档作为节点树遍历，如何找到任何文档元素的祖先、兄弟和后台元素</li><li>如何查询和设置文档元素的属性</li><li>如何查询、设置和修改文档的内容</li><li>如何通过创建、插入和删除节点来修改文档结构</li><li>如何与HTML表单一起工作  </li><li>文档特性，<code>referrershuxing、write()</code>方法、和查询当前文档中选取的文档文本</li></ul><h2 id="DOM-概述"><a href="#DOM-概述" class="headerlink" title="DOM 概述"></a>DOM 概述</h2><p>DOM：文档对象模型</p><p>一个简单的 <code>HTML</code> 文档的 <code>DOM</code> 树状图：<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514159496869.jpg" alt=""></p><p>文档中的每一个节点，表示一个 <code>Node</code> 对象，每个 <code>Node</code> 对象由四大属性，详细请查阅相关章节：</p><ul><li><code>Document</code></li><li><code>CharaterData</code></li><li><code>Element</code></li><li><code>Attr</code></li></ul><h2 id="选取文档元素"><a href="#选取文档元素" class="headerlink" title="选取文档元素"></a>选取文档元素</h2><ul><li>用指定的 <code>ID</code> 属性</li><li>用指定的 <code>name</code> 属性</li><li>用指定的标签名字</li><li>用指定的 <code>CSS</code> 类</li><li>匹配指定的 <code>CSS</code> 选择器</li></ul><h3 id="通过-ID-选取元素"><a href="#通过-ID-选取元素" class="headerlink" title="通过 ID 选取元素"></a>通过 <code>ID</code> 选取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> section1 = <span class="built_in">document</span>.getElementById(<span class="string">'section1'</span>);</span><br></pre></td></tr></table></figure><p><code>id</code> 属性是 <code>HTML</code> 元素唯一的，这是最简单和常用的选取元素的方法。</p><p>通过 <code>id</code> 查找多个元素：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514160529427.jpg" alt=""></p><h3 id="通过名字选取元素"><a href="#通过名字选取元素" class="headerlink" title="通过名字选取元素"></a>通过名字选取元素</h3><p> <code>name</code> 属性不是必须唯一，但是只有少数 <code>HTML</code> 元素中有效，包括表单、表单元素、<code>&lt;ifarme&gt;、&lt;img&gt;</code>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radiobuttons = <span class="built_in">document</span>.getElementByName(<span class="string">'favorite_color'</span>);</span><br></pre></td></tr></table></figure><p>有些元素自动设置 <code>name</code> 属性到 <code>Window</code> 对象中，所有可以仅仅通过名字获取，但是最好显示的通过 <code>getElementByName()</code> 获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对  &lt;form name='shipping_address'&gt; 元素,获得Element对象</span></span><br><span class="line"><span class="keyword">var</span> form = docuemnt.shipping_address;</span><br></pre></td></tr></table></figure><h3 id="通过标签名选取元素"><a href="#通过标签名选取元素" class="headerlink" title="通过标签名选取元素"></a>通过标签名选取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementByTagName(<span class="string">'span'</span>);</span><br></pre></td></tr></table></figure><p>只能返回数组对象，并且排列顺序是文档中的顺序。<code>HTML</code> 标签是不区分大小写的。</p><p>传递通配符参数 <code>*</code> 将获取代表文档中所有元素的 <code>NodeList</code> 对象。</p><h3 id="通过-CSS-类选取元素"><a href="#通过-CSS-类选取元素" class="headerlink" title="通过 CSS 类选取元素"></a>通过 CSS 类选取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找其class属性值中包含“awrning”的所有元素</span></span><br><span class="line"><span class="keyword">var</span> warning = <span class="built_in">document</span>.getElementByClassName(<span class="string">'warning'</span>)</span><br></pre></td></tr></table></figure><p>参数可以是一个字符串，也可以是多个由空格隔开的标识符组成，只有当元素的 <code>class</code> 属性值包含所有指定的标识符时才会匹配，但是与标识符的顺序是无关的。</p><blockquote><p>现代Web浏览器中以&lt;!DOCTYPE&gt;声明的严格程度来选择“怪异模式”或者“标准模式”方式显示HTML文档。<br>怪异模式是为了向后兼容性而存在的。</p></blockquote><h3 id="通过-CSS-选择器选取元素"><a href="#通过-CSS-选择器选取元素" class="headerlink" title="通过 CSS 选择器选取元素"></a>通过 CSS 选择器选取元素</h3><p>选择器用来描述文档中的若干或多组元素，元素可以用ID、标签名或类来描述</p><p><a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">css选择器</a></p><p><code>querySelectorAll()</code> :返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的节点)。返回的对象是 NodeList 。需要注意的是，一些伪元素无法匹配，如 <code>:first-line  :first-letter</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="built_in">document</span>.querySelectorAll(<span class="string">"div.note, div.alert"</span>);</span><br></pre></td></tr></table></figure><p>📌  获取某个元素下包含的所有子元素，查看其属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'sub-form'</span>)</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(form)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> [input#sb_form_q.b_searchbox, input#sb_form_go.b_searchboxSubmit, input#sa_qs, input]</span></span><br><span class="line"><span class="comment">0:input#sb_form_q.b_searchbox</span></span><br><span class="line"><span class="comment">1:input#sb_form_go.b_searchboxSubmit</span></span><br><span class="line"><span class="comment">2:input#sa_qs</span></span><br><span class="line"><span class="comment">3:input  */</span></span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1514297111601.jpg" alt=""></p><h2 id="文档结构和遍历"><a href="#文档结构和遍历" class="headerlink" title="文档结构和遍历"></a>文档结构和遍历</h2><p>有时需要查找文档中与之结构上相关的部分（父亲、兄弟、子女）。</p><p>文档从概念上可以看做是一棵节点对象树。</p><h3 id="作为节点树的文档"><a href="#作为节点树的文档" class="headerlink" title="作为节点树的文档"></a>作为节点树的文档</h3><p><code>Document</code>对象、它的 <code>Element</code> 对象和文档中表示文本的 <code>Text</code> 对象都是 <code>Node</code> 对象（见上图），<code>Node</code> 定义了几个重要属性：</p><ul><li><p><code>parentNode</code></p><ul><li>节点的父节点</li></ul></li><li><p><code>childNodes</code></p><ul><li>只读的子节点数组对象</li></ul></li><li><p><code>firstChild、lastChild</code></p><ul><li>该节点的第一个和最后一个子节点</li></ul></li><li><p><code>nextSlibling、previpursSlibling</code> 📌 </p><ul><li>节点的兄弟节点中的前一个和下一个</li><li>具有相同父节点的两个节点为兄弟节点</li><li>节点的顺序反映了它们在文档中出现的顺序</li></ul></li><li><p><code>nodeType</code></p><ul><li>该节点的类型</li></ul></li><li><p><code>nodeValue</code></p><ul><li><code>Text</code> 节点或 <code>Comment</code> 节点的文本内容</li></ul></li><li><p><code>nodeName</code></p><ul><li>元素的标签名，以大写形式表示</li></ul></li></ul><p>快速获取元素的实践：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个子节点下面的第二个子节点</span></span><br><span class="line"><span class="built_in">document</span>.childNodes[<span class="number">0</span>].childNodes[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//第一个子节点下面的第一个子节点的前一个兄弟节点</span></span><br><span class="line"><span class="built_in">document</span>.firstChild.firstChild.nextSibling</span><br></pre></td></tr></table></figure></p><h3 id="作为元素树的文档"><a href="#作为元素树的文档" class="headerlink" title="作为元素树的文档"></a>作为元素树的文档</h3><p>etc… 似乎在开发中用不到</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《 &lt;code&gt;JavaScript&lt;/code&gt; 权威指南 第十五章》&lt;/p&gt;
&lt;p&gt;本文介绍了文档的概念，以及如何获取问题，Node 节点的属性，如何通过Node属性快速定位的相关节点。&lt;/p&gt;
&lt;h1 id=&quot;JavaScript脚本化文档&quot;&gt;&lt;a href=&quot;#Ja
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="脚本文档化" scheme="https://luoyec.cn/tags/%E8%84%9A%E6%9C%AC%E6%96%87%E6%A1%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件处理上</title>
    <link href="https://luoyec.cn/2017/12/24/cl4e29qcy002m989e73eqijzu/"/>
    <id>https://luoyec.cn/2017/12/24/cl4e29qcy002m989e73eqijzu/</id>
    <published>2017-12-24T14:54:12.000Z</published>
    <updated>2017-12-26T14:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript事件处理上"><a href="#JavaScript事件处理上" class="headerlink" title="JavaScript事件处理上"></a>JavaScript事件处理上</h1><p>客户端 <code>JavaScript</code> 程序采用了异步事件驱动编程模型，在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，<code>Web</code> 浏览器就会产生事件。</p><p>如果 <code>JavaScript</code> 关注特定类型的时间，那么它可以注册当这类时间发生时要调用的一个或多个函数。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>了解相关的术语，有助于继续深入学习事件和事件处理。</p><ul><li><p>事件类型<code>（event type）</code></p><ul><li>是一个用来说明发生什么事件的字符串，有时也被事件名字<code>（event name）</code></li></ul></li><li><p>事件目标<code>（event targe）</code></p><ul><li>是发生的事件或与之相关的对象，当将事件是，必须同时指明类型和目标。</li><li><code>Window、Document、Element</code>是最常见的事件目标</li></ul></li><li><p>事件处理程序<code>（event handler）</code></p><ul><li>事件处理程序<code>（event handler）</code>或事件监听程序<code>（event listener）</code> 是处理响应事件的函数。</li><li>当对象在注册的事件程序被调用时，我们有时会说浏览器“触发”和“派发”了事件</li></ul></li><li><p>事件对象<code>（event object）</code></p><ul><li>事件对象<code>（event object）</code>是与特定事件并且包含有关该事件详细信息的对象。</li><li>事件对象作为参数传递给事件处理程序</li><li>所有的事件对象都有用来指定事件类型的 <code>type</code> 属性和指定事件目标的 <code>targe</code> 属性。</li></ul></li><li><p>事件传播<code>（event propagation）</code></p><ul><li>事件传播<code>（event propagation）</code>是浏览器决定哪个对象触发其事件处理程序的过程。</li><li>当文档元素发生某个类型的事件时，他们会在文档树上向上传播或“冒泡”<code>（bubble）</code></li><li>事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播，这样能停止冒泡并将无法再容器元素上触发的处理程序。</li></ul></li><li><p>事件捕获<code>（event capturing）</code></p><ul><li>是事件传播的另一种形式，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前拦截（或“捕获”）它</li><li><code>IE8</code> 版本之前不支持事件捕获</li></ul></li><li><p>事件的默认操作</p><ul><li>例如在超链接的点击事件，浏览器的默认操作是按照超链接重新加载页面</li><li>事件处理程序可以通过返回一个适当的值、调用事件对象的某个方法设置事件对象的某个属性来阻止默认操作的发生。</li></ul></li></ul><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>随着 <code>Web</code> 平台发展到包含更强大的API，事件集合随之越来越大，这些新事件主要有三个来源：</p><ul><li>3级 <code>DOM</code> 事件规范</li><li><code>HTML5</code> 规范衍生规范的大量新API定义的事件</li><li>基于触摸和支持 <code>JavaScript</code> 的移动设备的出现</li></ul><p>事件大致可以分成几类，了解这些分类有助于理解和组织事件列表：</p><ul><li><p>依赖于设备的输入事件</p><ul><li>鼠标和键盘， <code>mousedown、mousemove、mouseup、keydown、keyup</code></li></ul></li><li><p>独立与设备的输入事件</p><ul><li>这些事件没有直接相关的特定输入设备，如 <code>click</code> 事件，可以通过鼠标点击发生也可以通过键盘或者其他设备触发</li></ul></li><li><p>用户界面事件</p><ul><li>用户界面事件，通常出现定义 <code>Web</code> 程序用户界面的 <code>HTML</code> 表单元素上。</li><li>包括文本输入域获取键盘焦点的 <code>focus</code> 事件、用户改变表单元格的 <code>change</code> 事件、表单提交 <code>submit</code> 事件</li></ul></li><li><p>状态变化事件</p><ul><li>不是由于用户活动而是由于网络或浏览器活动出发、用来标识某种声明周期或相关状态的变化</li><li>例如，<code>window</code> 的 <code>onload</code> 事件，<code>loadstart、progress、loadend</code>等 <code>I/O</code> 过程的异步通知</li></ul></li><li><p>特定的 <code>API</code> 事件</p><ul><li><code>HTML5</code> 及相关规范定义的大量 <code>Web API</code> 都有自己的事件类型</li><li>如拖放 <code>API</code>，<code>dragstart、dragenter，&lt;video /&gt;</code> 等</li></ul></li></ul><h3 id="传统事件类型"><a href="#传统事件类型" class="headerlink" title="传统事件类型"></a>传统事件类型</h3><ul><li><p>表单事件</p><ul><li>表单事件是所有事件类型中最稳定且得到最良好支持的那部分</li><li>表单提交和重置，会触发 <code>submit</code> 和 <code>reset</code> 事件</li><li>类按钮元素（如单选、复选）交互时，<code>click</code> 事件</li><li>用户通过文字、选择选项或选择复选框改变表单元素状态时，通常会触发 <code>change</code> 事件</li><li>对于文本输入域，只有当焦点移动到其他元素才会触发 <code>change</code> 事件</li><li>改变表单元素焦点时会触发，<code>focus</code> 和 <code>blur</code> 事件</li><li>通过事件处理程序能取消 <code>submit</code> 和 <code>reset</code> 事件的默认操作</li></ul></li><li><p><code>Window</code> 事件 </p><ul><li><code>Window</code> 事件是指事件的发生于浏览器窗口本身而非窗口中显示的任何特定文档内容相关</li><li><code>load</code> 事件，是当文档和其他所有的外部资源（比如图片）完全加载并显示给用户时才会触发</li><li><code>unload事件</code>，是当用户离开文档转向其他文档是触发它</li><li><code>resize</code>、<code>scroll事件</code>，当用户调整浏览器窗口大小、滚动时会被触发，但其事件对象时非常普通的 <code>Event</code> 对象，没有指定调整大小或发生滚动的详细信息属性</li></ul></li><li><p>鼠标事件</p><ul><li>当用户在文档上移动单击鼠标都会产生鼠标事件，这些事件在鼠标指针所对应的最深嵌套元素上触发， 但他们会冒泡直到文档的最顶层</li><li>事件对象中包含了，鼠标的位置和按键状态</li><li>对于 <code>click</code> 事件， <code>detail</code> 属性制定了其是单击、双击、还是三击</li><li><code>mousemove</code> 事件，当用户移动鼠标时触发，在该事件中，一定不能触发计算密集型任务</li><li><code>mouseover</code> 事件，当用户鼠标指针悬停到新元素上时触发，<code>mouseout</code>，不在悬停在某个对象上时触发</li><li><code>mousewhell</code> 事件，当用户鼠标滚轮时触发</li></ul></li><li><p>键盘事件</p><ul><li>用户每次按下或释放键盘上的按键时都会产生事件</li><li>传递给事件处理程序的对象中有 <code>keyCode</code> 字段 ， 它指定按下或释放的键是哪一个</li><li><code>keydown</code>、<code>keyup</code>、<code>keypress</code> 事件，键盘按下、释放，<code>keypress</code> 按住时可以产生连续多个相同的字符</li></ul></li></ul><h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a><code>DOM</code> 事件</h3><p><em>DOM的分级：根据W3C DOM规范，DOM是HTML与XML的应用编程接口（API），DOM将整个页面映射为一个由层次节点组成的文件。有1级、2级、3级共3个级别。</em></p><h4 id="1级DOM："><a href="#1级DOM：" class="headerlink" title="1级DOM："></a>1级DOM：</h4><p><em>1级DOM在1998年10月份成为W3C的提议，由DOM核心与DOM HTML两个模块组成。DOM核心能映射以XML为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML通过添加HTML专用的对象与函数对DOM核心进行了扩展。</em></p><h4 id="2级DOM"><a href="#2级DOM" class="headerlink" title="2级DOM"></a>2级DOM</h4><p><em>鉴于1级DOM仅以映射文档结构为目标，DOM 2级面向更为宽广。通过对原有DOM的扩展，2级DOM通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。同时也对DOM 1的核心进行了扩展，从而可支持XML命名空间。</em></p><p>*2级DOM引进了几个新DOM模块来处理新的接口类型：</p><ul><li>DOM视图：描述跟踪一个文档的各种视图（使用CSS样式设计文档前后）的接口；</li><li>DOM事件：描述事件接口；</li><li>DOM样式：描述处理基于CSS样式的接口；</li><li>DOM遍历与范围：描述遍历和操作文档树的接口；*</li></ul><h4 id="3级DOM"><a href="#3级DOM" class="headerlink" title="3级DOM"></a>3级DOM</h4><p><em>3级DOM通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展，DOM3包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包括XML Infoset、 XPath、和XML Base。</em></p><h4 id="“0级”DOM"><a href="#“0级”DOM" class="headerlink" title="“0级”DOM"></a>“0级”DOM</h4><p><em>当阅读与DOM有关的材料时，可能会遇到参考0级DOM的情况。需要注意的是并没有标准被称为0级DOM，它仅是DOM历史上一个参考点（0级DOM被认为是在Internet Explorer 4.0 与Netscape Navigator4.0支持的最早的DHTML）。</em></p><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a><code>HTML5</code> 事件</h3><p><code>HTML5</code> 及相关标准定义了大量新的 <code>Web</code> 应用 <code>API</code>，其中许多 <code>API</code> 都定义了事件。</p><ul><li>音频和视频 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code></li><li>拖放事件</li><li>表单的新特性，表单验证机制，包括验证失败时在表单元素上会触发 <code>invalid</code> 事件</li><li>离线 Web 应用的支持</li><li>许多新的API应用使用 <code>message</code> 事件进行异步通信。跨文档通信 <code>API</code> 允许一台服务器上的文档能通过和另一台服务器上的文档脚本交换消息。</li><li><code>XMLHttpRequest</code> 规范定义了一系列事件来追踪异步的 <code>I/O</code> 进度，<code>loadstart、progress、loadend</code></li></ul><h3 id="触摸屏和移动设备事件"><a href="#触摸屏和移动设备事件" class="headerlink" title="触摸屏和移动设备事件"></a>触摸屏和移动设备事件</h3><p>可以在 <code>Apple</code> <a href="http://developer.apple.com" target="_blank" rel="noopener">开发者中心</a> 查询更多信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript事件处理上&quot;&gt;&lt;a href=&quot;#JavaScript事件处理上&quot; class=&quot;headerlink&quot; title=&quot;JavaScript事件处理上&quot;&gt;&lt;/a&gt;JavaScript事件处理上&lt;/h1&gt;&lt;p&gt;客户端 &lt;code&gt;JavaScri
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://luoyec.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块</title>
    <link href="https://luoyec.cn/2017/12/16/cl4e29qco001y989e3jx4kp1q/"/>
    <id>https://luoyec.cn/2017/12/16/cl4e29qco001y989e3jx4kp1q/</id>
    <published>2017-12-15T17:03:11.000Z</published>
    <updated>2017-12-15T17:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-模块"><a href="#JavaScript-模块" class="headerlink" title="JavaScript 模块"></a>JavaScript 模块</h1><p><code>JavaScript</code> 模块在平时开发中都会接触到，但缺乏对模块整体理解，本文档试着从前端模块的发展历程作为切入点，以 ‘CommonJS’ 和 ‘ES6’ 模块作为深入学习的方向，深入理解和掌握 <code>JavaScript</code> 模块</p><h2 id="JS-模块发展史"><a href="#JS-模块发展史" class="headerlink" title="JS 模块发展史"></a>JS 模块发展史</h2><p><a href="https://huangxuan.me/js-module-7day/#/" target="_blank" rel="noopener"><code>JavaScript</code> 模块化七日谈</a><br><a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener">前端模块化开发那点历史</a><br><a href="https://segmentfault.com/a/1190000004873947" target="_blank" rel="noopener"><code>AMD, CMD, CommonJS 和 UMD</code></a></p><h2 id="CommonJS-模块系统"><a href="#CommonJS-模块系统" class="headerlink" title="CommonJS 模块系统"></a>CommonJS 模块系统</h2><p><a href="https://lyctea.github.io/2017/12/09/Node%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">Node.js 模块</a></p><p><code>CommonJs</code> 是一个由开源开发者组成的团队，主要围绕 <code>JavaScript</code> 实现一些 <code>API</code> 及开展研发实践。</p><p>该团队提出了一个 <code>avaScript</code> 模块规范。每个文件都可当作一个模块，并且每个文件可以访问两个对象：<code>require</code> 和 <code>export</code>。<code>require</code> 用来接收字符串（模块名），并返回该模块输出的对象。</p><p><code>export</code> 对象用来导出该模块的方法和变量。<code>require</code> 方法返回的就是 <code>export</code> 对象。模块同步加载。服务器端 <code>JavaScript</code> 引擎 <code>Node.js</code> 就是用的这个模块系统。</p><h2 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h2><p><code>AMD</code> 是一个采用异步方式加载依赖模块的模块系统。</p><p>如果模块在不同文件中，它们将采用 <code>XHR</code> 进行加载。某一模块将等其所依赖的模块一一加载后才会被执行。</p><p><code>AMD</code> 模块必须是一个函数，并作为参数传入<code>define</code> 函数中。函数的返回值将传输给所有依赖的模块，所获得返回值又将作为参数传给模块方法。<code>Require.js</code> 库中实现了 <code>AMD</code></p><blockquote><p><code>XHR</code> 英文全名 <code>XmlHttpRequest</code>，中文可以解释为可扩展超文本传输请求。Xml 可扩展标记语言，Http 超文本传输协议，Request 请求。XMLHttpRequest 对象可以在不向服务器提交整个页面的情况下，实现局部更新网页。</p><p><a href="https://baike.baidu.com/item/XMLHTTPRequest" target="_blank" rel="noopener">百度百科：XMLHTTPRequest</a></p></blockquote><h2 id="TypeScript-模块"><a href="#TypeScript-模块" class="headerlink" title="TypeScript 模块"></a>TypeScript 模块</h2><p><code>TypeScript</code>，作为 <code>JavaScript</code> 的超集，也提供了一个模块系统。</p><p>当它被编译时，便开始使用 <code>JavaScript</code> 模块模式。<code>TypeScript</code> 模块使用 <code>module</code> 关键字定义，<code>任何被输出的对象必须使用export</code> 关键字定义。</p><p><code>import</code> 关键字用来将其它模块加载入模块中，并捕捉该模块导出的对象。<code>TypeScript</code> 模块是同步加载的。</p><h2 id="ES6-模块系统"><a href="#ES6-模块系统" class="headerlink" title="ES6 模块系统"></a>ES6 模块系统</h2><p><a href="https://lyctea.github.io/2017/12/16/ES6%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">ES6 模块系统</a></p><p><code>ES6</code> 模块系统启发于上述现有模块系统，它具有以下特性：</p><ul><li><p>使用 <code>export</code> 关键词导出对象。这个关键字可以无限次使用</p></li><li><p>使用 <code>import</code> 关键字将其它模块导入某一模块中。它可用来导入任意数量的模块</p></li><li><p>支持模块的异步加载</p></li><li><p>为加载模块提供编程支持</p></li></ul><h2 id="阻塞非阻塞与同步异步"><a href="#阻塞非阻塞与同步异步" class="headerlink" title="阻塞非阻塞与同步异步"></a>阻塞非阻塞与同步异步</h2><p><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p><p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步关注的是消息通信机制 <code>(synchronous communication/ asynchronous communication)</code></p><p>所谓同步，就是在发出一个 _调用_ 时，在没有得到结果之前，该 _调用_ 就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由 <em>调用者</em> 主动等待这个 _调用_ 的结果。</p><p>而异步则是相反，_调用_ 在发出之后，这个调用就直接返回了，所以没有返回结果。</p><p>换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>典型的异步编程模型比如 <code>Node.js</code></p><p>举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。</p><p>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。</p><p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-模块&quot;&gt;&lt;a href=&quot;#JavaScript-模块&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 模块&quot;&gt;&lt;/a&gt;JavaScript 模块&lt;/h1&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 模块
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="模块" scheme="https://luoyec.cn/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>ES6 模块系统</title>
    <link href="https://luoyec.cn/2017/12/16/cl4e29qbt000b989eusm819uy/"/>
    <id>https://luoyec.cn/2017/12/16/cl4e29qbt000b989eusm819uy/</id>
    <published>2017-12-15T16:56:35.000Z</published>
    <updated>2017-12-15T16:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.csdn.net/article/2015-04-30/2824595-Modules-in-ES6" target="_blank" rel="noopener">【ES6专栏】全面解析 ECMAScript 6 模块系统</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">阮一峰：ECMAScript 6 入门</a></p><h1 id="ES6-模块系统"><a href="#ES6-模块系统" class="headerlink" title="ES6 模块系统"></a>ES6 模块系统</h1><p><code>ES6</code> 模块系统它具有以下特性：</p><ul><li><p>使用 <code>export</code> 关键词导出对象。这个关键字可以无限次使用</p></li><li><p>使用 <code>import</code> 关键字将其它模块导入某一模块中。它可用来导入任意数量的模块</p></li><li><p>支持模块的异步加载</p></li><li><p>为加载模块提供编程支持</p></li></ul><h2 id="导出对象"><a href="#导出对象" class="headerlink" title="导出对象"></a>导出对象</h2><p>在现有的模块系统中，每个 <code>JavaScript</code> 代码文件在 <code>ES6</code> 中都是一个模块。</p><p>只有模块中的对象需要被外部调用时，模块才会输出对象，其余则都是模块的私有对象。<br>该处理方式将细节进行封装，仅导出必要的功能。</p><p>从模块里导出对象，<code>ES6</code> 为我们提供了不同方法，见下面的讨论。</p><h3 id="内联导出"><a href="#内联导出" class="headerlink" title="内联导出"></a>内联导出</h3><p><code>ES6</code> 模块里的对象可在创建它们的声明中导出。<br>一个模块中可无数次使用 <code>export</code>，所有的对象将被一起导出。<br>请看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, name, dob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.dob = dob;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.dob.getYear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEmployee</span>(<span class="params">id, name, dob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Employee(id, name, dob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CONFIG = <span class="string">'10.0.0.1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp = <span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">'Rina'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1987</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line"><span class="comment">// console.log(emp);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 案例中的模块导出了两个对象： Employee类，getEmployee函数。因对象emp未被导出，所以其仍为模块私有。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="导出一组对象"><a href="#导出一组对象" class="headerlink" title="导出一组对象"></a>导出一组对象</h3><p>尽管内联导出很有效，但在大规模模块中，它就很难发挥作用了，因为我们可能无法追踪到模块导出来的对象。在这种情况下，更好的办法是，在模块的末尾单独进行导出声明，以导出该模块中的全部对象。</p><p>使用单独导出声明重写上一案例中的模块，结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, name, dob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.dob = dob;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getYear() - <span class="keyword">this</span>.dob.getYear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEmployee</span>(<span class="params">id, name, dob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Employee(id, name, dob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">'Rina'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1987</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Employee, getEmployee &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在导出时，重命名对象也是可以的。如下例所示，</span></span><br><span class="line"><span class="comment"> * Employee在导出时名字改为了Associate，</span></span><br><span class="line"><span class="comment"> * 函数GetEmployee改名为getAssociate。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// export &#123; Employee as Associate, getEmployee as getAssociate &#125;;</span></span><br></pre></td></tr></table></figure><h3 id="Default导出"><a href="#Default导出" class="headerlink" title="Default导出"></a>Default导出</h3><p>使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。它既可以用于内联导出，也可以用于一组对象导出声明中。</p><p>下面案例展示了在组导出语句中使用default：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">    Employee,  </span><br><span class="line">    getEmployee  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1513355728074.jpg" alt=""></p><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>现有模块可以使用关键字import导入到其它模块。一个模块可以被导入任意数量的模块中。下文展示了导入模块的不同方式。</p><h3 id="无对象导入"><a href="#无对象导入" class="headerlink" title="无对象导入"></a>无对象导入</h3><p>如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中。如下面案例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./es6_module/doSomethings'</span>;</span><br></pre></td></tr></table></figure><h3 id="导入默认对象"><a href="#导入默认对象" class="headerlink" title="导入默认对象"></a>导入默认对象</h3><p>采用Default导出方式导出对象，该对象在import声明中将直接被分配给某个引用，如下例中的“d”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> d <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="导入命名的对象"><a href="#导入命名的对象" class="headerlink" title="导入命名的对象"></a>导入命名的对象</h3><p>正如以上讨论的，一个模块可以导出许多命名对象。如果另一模块想导入这些命名对象，需要在导入声明中一一列出这些对象。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Employee, getEmployee&#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br></pre></td></tr></table></figure><p>当然也可在同一个声明中导入默认对象和命名对象。这种情况下，默认对象必须定义一个别名，如下例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> d, Employee&#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="导入所有对象"><a href="#导入所有对象" class="headerlink" title="导入所有对象"></a>导入所有对象</h3><p>以上几种情况，只有import声明中列举的对象才会被导入并被使用，而其它对象则无法在导入模块中使用。当然，这就要求用户了解哪些对象可以导出并加以利用。</p><p>如果模块导出大量对象，另一模块想引入所有导出的对象，就必须使用如下声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> allFromModule1 <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="可编程式的按需导入"><a href="#可编程式的按需导入" class="headerlink" title="可编程式的按需导入"></a>可编程式的按需导入</h3><p>如果想基于某些条件或等某个事件发生后再加载需要的模块，可通过使用加载模块的可编程<code>API（programmatic API）</code>来实现。使用 <code>System.import</code> 方法，可按程序设定加载模块。这是一个异步的方法，并返回 <code>Promise</code>。</p><p>该方法的语法示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.import(<span class="string">'./module1.js'</span>)  </span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//use module1  </span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//handle error  </span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>如果模块加载成功且将导出的模块成功传递给回调函数，<code>Promise</code> 将会通过。如果模块名称有误或由于网络延迟等原因导致模块加载失败，<code>Promise</code> 将会失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.csdn.net/article/2015-04-30/2824595-Modules-in-ES6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【ES6专栏】全面解析 ECMAScript 6 模块系统&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="模块" scheme="https://luoyec.cn/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基础 一</title>
    <link href="https://luoyec.cn/2017/12/12/cl4e29qdm003x989ejoltuxnz/"/>
    <id>https://luoyec.cn/2017/12/12/cl4e29qdm003x989ejoltuxnz/</id>
    <published>2017-12-11T23:56:10.000Z</published>
    <updated>2017-12-11T23:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库与关系型数据库"><a href="#数据库与关系型数据库" class="headerlink" title="数据库与关系型数据库"></a>数据库与关系型数据库</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库（<code>Database</code>）是按照数据结构来组织、存储和管理数据的仓库，<br>每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。</p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ul><li><p>数据库: 数据库是一些关联表的集合。</p></li><li><p>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p></li><li><p>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p></li><li><p>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p></li><li><p>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p></li><li><p>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</p></li><li><p>外键：外键用于关联两个表。</p></li><li><p>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</p></li><li><p>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</p></li><li><p>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p></li></ul><h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><p><code>MySQL</code> 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。<code>MySQL</code> 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>验证安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">luoyecs-iMac:~ luoyec$ mysqladmin --version</span><br><span class="line">mysqladmin  Ver 8.42 Distrib 5.7.20, for macos10.12 on x86_64</span><br></pre></td></tr></table></figure><p>检查 <code>MySql</code> 服务器是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">luoyecs-iMac:~ luoyec$ ps -ef | grep mysqld</span><br><span class="line">   74   856     1   0 10:17上午 ??         0:00.72 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring --early-plugin-load=keyring_file=keyring_file.so</span><br><span class="line">  501   959   635   0 10:26上午 ttys002    0:00.01 grep mysqld</span><br></pre></td></tr></table></figure><p>关闭目前运行的 <code>MySQL</code> 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mysqladmin -u root -p shutdown</span><br></pre></td></tr></table></figure><h2 id="基础SQL语句"><a href="#基础SQL语句" class="headerlink" title="基础SQL语句"></a>基础SQL语句</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p><code>SELECT</code> 语句用于从数据库中选取数据。<br>结果被存储在一个结果表中，称为结果集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,country <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure><h3 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h3><p><code>SELECT DISTINCT</code> 语句用于返回唯一不同的值, 也就是去掉列中重复值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT column_name,column_name</span><br><span class="line">FROM table_name;</span><br></pre></td></tr></table></figure></p><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><p><code>WHERE</code> 子句用于提取那些满足指定标准的记录。</p><p>下面的 <code>SQL</code> 语句从 “Websites” 表中选取国家为 “CN” 的所有网站：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> country=<span class="string">'CN'</span>;</span><br></pre></td></tr></table></figure></p><p>运算符：<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1513034722578.jpg" alt=""></p><h3 id="AND-amp-OR"><a href="#AND-amp-OR" class="headerlink" title="AND &amp; OR"></a>AND &amp; OR</h3><blockquote><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p></blockquote><blockquote><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。<br>如果第一个条件和第二个条件中只要有一个成立，则 OR运算符显示一条记录。</p></blockquote><p>下面的 <code>SQL</code> 语句从 “Websites” 表中选取国家为 “CN” 且id排名大于 2” 的所有网站：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> country=<span class="string">'CN'</span> <span class="keyword">AND</span> <span class="keyword">id</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>选取 id 等于2或者等于3的所有数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">OR</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>您也可以把 <code>AND</code> 和 <code>OR</code> 结合起来（使用圆括号来组成复杂的表达式）。<br>“Websites” 表中选取 alexa 排名大于 “15” 且国家为 “CN” 或 “USA” 的所有网站：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> alexa &gt; <span class="number">15</span></span><br><span class="line"><span class="keyword">AND</span> (country=<span class="string">'CN'</span> <span class="keyword">OR</span> country=<span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><blockquote><p>ORDER BY 关键字用于对结果集进行排序。</p></blockquote><blockquote><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。<br>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name,column_name <span class="keyword">ASC</span>|<span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>选取所有网站，按id降序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Websites <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><blockquote><p>ORDER BY 多列的时候，先按照第一个column name排序，在按照第二个column name排序；如上述教程最后一个例子：</p></blockquote><blockquote><ul><li>先将country值这一列排序，同为CN的排前面，同属USA的排后面； </li><li>然后在同属CN的这些多行数据中，再根据alexa值的大小排列。</li><li>ORDER BY 排列时，不写明ASCDESC的时候，默认是ASC。</li></ul></blockquote><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><p><code>INSERT INTO</code> 语句可以有两种编写形式。</p><p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>第二种形式需要指定列名及被插入的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>向表中插入一个新行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id是自动更新的，可以省略</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (<span class="keyword">id</span>, app_name, <span class="keyword">url</span>, country) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'bilibili'</span>, <span class="string">'wwww.bb.com'</span>, <span class="string">'JP'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只在url, country列插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (<span class="keyword">url</span>, country) <span class="keyword">VALUES</span> (<span class="string">'wwww.bib.com'</span>, <span class="string">'JP'</span>);</span><br></pre></td></tr></table></figure><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><code>UPDATE</code> 语句用于更新表中已存在的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1=value1,column2=value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️   请注意 SQL UPDATE 语句中的 WHERE 子句！ WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE子句，所有的记录都将被更新！</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新ID大于3的数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> Websites <span class="keyword">SET</span> country=<span class="string">'CN'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><code>DELETE</code> 语句用于删除表中的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 请注意 SQL DELETE 语句中的 WHERE 子句！ WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除app_name为''，且id&gt;3的行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> app_name=<span class="string">''</span> <span class="keyword">AND</span> <span class="keyword">id</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库与关系型数据库&quot;&gt;&lt;a href=&quot;#数据库与关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库与关系型数据库&quot;&gt;&lt;/a&gt;数据库与关系型数据库&lt;/h2&gt;&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;header
      
    
    </summary>
    
      <category term="mysql" scheme="https://luoyec.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://luoyec.cn/tags/mysql/"/>
    
      <category term="关系型数据库" scheme="https://luoyec.cn/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="nodejs" scheme="https://luoyec.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 模块</title>
    <link href="https://luoyec.cn/2017/12/09/cl4e29qdr0046989ebnhjh8hr/"/>
    <id>https://luoyec.cn/2017/12/09/cl4e29qdr0046989ebnhjh8hr/</id>
    <published>2017-12-09T06:40:43.000Z</published>
    <updated>2017-12-09T06:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nodeapp.cn/modules.html" target="_blank" rel="noopener">Node.js 中文文档 modules</a><br><a href="https://book.douban.com/subject/25870705/" target="_blank" rel="noopener">《Node.js 实战》</a><br><a href="https://www.processon.com" target="_blank" rel="noopener">流程图工具 processon</a></p><h2 id="Node-功能的组织及重用"><a href="#Node-功能的组织及重用" class="headerlink" title="Node 功能的组织及重用"></a>Node 功能的组织及重用</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512749506954.jpg" alt=""></p><blockquote><p>用目录和单独的文件组织起来的代码找起来要比整个程序代码都放在一个长文件中找起来更容易。</p></blockquote><h3 id="重用的问题"><a href="#重用的问题" class="headerlink" title="重用的问题"></a>重用的问题</h3><blockquote><p>在某些语言中，例如<br><code>PHP</code>和<code>Ruby</code>，整合另一个文件（我们称之为“<code>include</code>”文件）中的逻辑，可能意味着在被引入文件中执行的逻辑会影响全局作用域。</p></blockquote><blockquote><p>也就是说被引入文件常见的任何变量，以及声明的任何函数都可能会覆盖包含它的应用程序所创建的变量和声明的函数。</p></blockquote><blockquote><p>在 <code>PHP</code> 中可以使用命名空间避免这个问题，<code>Ruby</code> 通过模块也提供了类似的功能。</p></blockquote><h3 id="Node的重用"><a href="#Node的重用" class="headerlink" title="Node的重用"></a>Node的重用</h3><p><code>Node</code> 的做法不会让开发者有机会在不经意间污染全局命名空间。</p><p>  <code>Node.js</code> 有一个简单的模块加载系统。 在 <code>Node.js</code> 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。</p><p><code>Node</code> 模块允许你从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变量不值一个，那么它通过设定 <code>exports</code> 对象的属性来指明它们。如果模块只返回一个函数或变量，则可以设定 <code>module.exports</code> 属性。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512750503884.jpg" alt=""></p><h2 id="exports"><a href="#exports" class="headerlink" title="exports"></a><code>exports</code></h2><p>假设有一个名为 <code>foo.js</code> 的文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是 <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在第一行中，<code>foo.js</code> 加载了同一目录下的 <code>circle.js</code> 模块。</p><p><code>circle.js</code> 文件的内容为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//circle.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r;</span><br></pre></td></tr></table></figure><p><code>circle.js</code> 模块导出了 <code>area()</code> 和 <code>circumference()</code> 两个函数。 通过在特殊的 <code>exports</code> 对象上指定额外的属性，函数和对象可以被添加到模块的根部。</p><p>模块内的本地变量是私有的，因为模块被 <code>Node.js</code> 包装在一个函数中。</p><h2 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a><code>module.exports</code></h2><p>如下，<code>bar.js</code> 会用到 <code>square</code> 模块，<code>square</code> 导出一个构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="built_in">require</span>(<span class="string">'./square.js'</span>);</span><br><span class="line"><span class="keyword">const</span> mySquare = square(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`正方形的面积是 <span class="subst">$&#123;mySquare.area()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>square 模块定义在 square.js 中：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`</span><br><span class="line">module.exports = (width) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    area: () =&gt; width ** 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>如果只需要从模块中得到一个函数，那么从 <code>require</code> 中返回一个函数的代码要比返回一个对象的代码更优雅。</p><p>实例，以下是一个货币转换函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test-currency.js</span></span><br><span class="line"><span class="keyword">var</span> Currency = <span class="built_in">require</span>(<span class="string">'./currency'</span>);</span><br><span class="line"><span class="keyword">var</span> canadianDollar = <span class="number">0.91</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currency = <span class="keyword">new</span> Currency(canadianDollar);</span><br><span class="line"><span class="built_in">console</span>.log(currency.canadianToUS(<span class="number">50</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//currency.js</span></span><br><span class="line"><span class="keyword">var</span> Currency = <span class="function"><span class="keyword">function</span>(<span class="params">canadianDollar</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.canadianDollar = canadianDollar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机一个两位小数</span></span><br><span class="line">Currency.prototype.roundTwoDecimals = <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(amount * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加元转美元</span></span><br><span class="line">Currency.prototype.canadianToUS = <span class="function"><span class="keyword">function</span>(<span class="params">candian</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.roundTwoDecimals(candian * <span class="keyword">this</span>.canadianDollar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//美元转加元</span></span><br><span class="line">Currency.prototype.USToCanadian = <span class="function"><span class="keyword">function</span>(<span class="params">us</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.roundTwoDecimals(us / <span class="keyword">this</span>.canadianDollar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Currency;</span><br></pre></td></tr></table></figure><p>另一个实例，搜索二叉树。</p><h2 id="用-node-modules重用模块"><a href="#用-node-modules重用模块" class="headerlink" title="用 node_modules重用模块"></a>用 node_modules重用模块</h2><p><code>Node</code> 中有一个独特的模块引入机制，可以不必知道模块在文件系统中具体位置，这个机制就是 <code>node_modules</code> 目录。</p><p>例如前面的 <code>var Currency = require(&#39;./currency&#39;);</code>，不写 ./, <code>node</code> 会遵照几个规则来寻找这个模块。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512754922116.jpg" alt=""></p><p>用环境变量 <code>NODE_PATH</code> 可以改变 <code>Node</code> 模块的默认路径。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>如果模块式目录，在木块目录中定义模块文件必须被命名为 <code>index.js</code> ，除非你在这个目录下 <code>packjson.json</code> 文件里特别指明。</p></li><li><p><code>Node</code> 能把模块作为对象缓存起来。如果程序中两个文件引入了相同模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。</p></li><li><p><code>require</code> 是 <code>Node</code> 中少数几个同步 <code>I/O</code> 操作，在 <code>I/O</code> 密集的地方尽量不要用 <code>require</code>， 所有同步调动都会阻塞 <code>Node</code>，直到调用完成才能做其他事情。所以通常只在程序最初加载时才使用 <code>require</code> 和其他同步操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.nodeapp.cn/modules.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js 中文文档 modules&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com
      
    
    </summary>
    
      <category term="node" scheme="https://luoyec.cn/categories/node/"/>
    
    
      <category term="模块" scheme="https://luoyec.cn/tags/%E6%A8%A1%E5%9D%97/"/>
    
      <category term="node" scheme="https://luoyec.cn/tags/node/"/>
    
      <category term="module" scheme="https://luoyec.cn/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>React路由过渡动画</title>
    <link href="https://luoyec.cn/2017/12/04/cl4e29qdz004o989eiztw8jpb/"/>
    <id>https://luoyec.cn/2017/12/04/cl4e29qdz004o989eiztw8jpb/</id>
    <published>2017-12-04T05:40:18.000Z</published>
    <updated>2017-12-04T05:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-路由过渡动画"><a href="#React-路由过渡动画" class="headerlink" title="React 路由过渡动画"></a><code>React</code> 路由过渡动画</h1><blockquote><p>Animated page transitions with React Router 4, ReactTransitionGroup and<br>Animated</p></blockquote><p><a href="https://segmentfault.com/a/1190000010539892" target="_blank" rel="noopener">中文翻译：</a> <a href="https://hackernoon.com/animated-page-transitions-with-react-router-4-reacttransitiongroup-and-animated-1ca17bd97a1a" target="_blank" rel="noopener">英文原文：</a> <a href="http://animatedjs.github.io/interactive-docs/" target="_blank" rel="noopener"><code>Animated.template</code>文档</a> <a href="https://github.com/mhaagens/animated_routes_react" target="_blank" rel="noopener">演示 Demo</a></p><p>原文中使用 <code>create-react-app</code> 从头构建路由动画，本文档只在如何在实际项目中使用路<br>由过渡动画。</p><h2 id="安装-react-transition-group"><a href="#安装-react-transition-group" class="headerlink" title="安装 react-transition-group"></a>安装 <code>react-transition-group</code></h2><p>需要注意的是开源作者修改了 V2 版本的 API，目前只能使用 V1 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yarn add react-transition-group@^1.2.0</span><br></pre></td></tr></table></figure><h2 id="lt-TransitionGroup-gt"><a href="#lt-TransitionGroup-gt" class="headerlink" title="&lt;TransitionGroup /&gt;"></a><code>&lt;TransitionGroup /&gt;</code></h2><p>接下来只需简单的几个步骤</p><ul><li><p>替换路由默认的渲染方式，使用 <code>&lt;TransitionGroup /&gt;</code> 包裹路由组件并使用其中的路<br>由渲染方法来渲染我们的组件。</p><pre><code>在路由入口文件 `src/App.js` 或是 `App.js` 中引入 `TransitionGroup`<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TransitionGroup <span class="keyword">from</span> <span class="string">'react-transition-  group/TransitionGroup'</span>;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>为 <code>Transition Group</code> 渲染 添加一个特殊的方法，其只渲染单个 child，在 <code>classApp extends ...</code> 之前添加。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> firstChild = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> childrenArray =      React.Children.toArray(props.children);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> childrenArray[<span class="number">0</span>] || <span class="literal">null</span>; &#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>修改原有的路由，并用 <code>TransitionGroup</code> 包裹</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &lt;Route</span><br><span class="line"></span><br><span class="line">exact path=<span class="string">"/"</span> children=&#123;(&#123; match, ...rest &#125;) =&gt; (</span><br><span class="line">&lt;TransitionGroup component=&#123;firstChild&#125;&gt; &#123;match &amp;&amp; &lt;Home &#123;...rest&#125; /&gt;&#125;</span><br><span class="line">&lt;/TransitionGroup&gt; )&#125;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Route</span><br><span class="line"></span><br><span class="line">path=<span class="string">"/subpage"</span> children=&#123;(&#123; match, ...rest &#125;) =&gt; (</span><br><span class="line">&lt;TransitionGroup component=&#123;firstChild&#125;&gt; &#123;match &amp;&amp; &lt;Subpage &#123;...rest&#125; /&gt;&#125;</span><br><span class="line">&lt;/TransitionGroup&gt; )&#125;/&gt;</span><br></pre></td></tr></table></figure></code></pre><p>  附：实际项目中的配置：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Root = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &#123;routeList.mainRoute.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;Route</span><br><span class="line">                            path=&#123;item.path&#125;</span><br><span class="line">                            key=&#123;item.path&#125;</span><br><span class="line">                            children=&#123;(&#123; match, ...rest &#125;) =&gt; (</span><br><span class="line">&lt;TransitionGroup component=&#123;firstChild&#125;&gt;</span><br><span class="line">                                    &#123;match &amp;&amp; (</span><br><span class="line">                                        &lt;item.component</span><br><span class="line">                                            &#123;...rest&#125;</span><br><span class="line">                                            match=&#123;match&#125;</span><br><span class="line">                                        /&gt;</span><br><span class="line">                                    )&#125;</span><br><span class="line">                                &lt;<span class="regexp">/TransitionGroup&gt;</span></span><br><span class="line"><span class="regexp">                            )&#125;</span></span><br><span class="line"><span class="regexp">                        /</span>&gt;</span><br><span class="line">                    );</span><br><span class="line">                &#125;)&#125;</span><br><span class="line"></span><br><span class="line">                &#123;&lt;Redirect <span class="keyword">from</span>=<span class="string">"/"</span> to=&#123;routePath.App&#125; /&gt;&#125;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Router&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="新的生命周期方法"><a href="#新的生命周期方法" class="headerlink" title="新的生命周期方法"></a>新的生命周期方法</h2><p>完成上面的工作，现在你有全访问新的生命周期方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillAppear() , componentWillEnter() and componentWillLeave()</span><br></pre></td></tr></table></figure><h2 id="创建高阶Animated组件"><a href="#创建高阶Animated组件" class="headerlink" title="创建高阶Animated组件"></a>创建高阶<code>Animated</code>组件</h2><p>创建 <code>AnimatedWrapper.js</code> 组件代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Animated <span class="keyword">from</span> <span class="string">'animated/lib/targets/react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> TransitionGroup <span class="keyword">from</span> <span class="string">'react-transition-group/TransitionGroup'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AnimatedWrapper = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimatedWrapper</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">            <span class="keyword">super</span>(props);</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                animate: <span class="keyword">new</span> Animated.Value(<span class="number">0</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        componentWillAppear(cb) &#123;</span><br><span class="line">            <span class="comment">// console.log('componentWillAppear');</span></span><br><span class="line">            Animated.spring(<span class="keyword">this</span>.state.animate, &#123; <span class="attr">toValue</span>: <span class="number">1</span> &#125;).start();</span><br><span class="line">            cb();</span><br><span class="line">        &#125;</span><br><span class="line">        componentWillEnter(cb) &#123;</span><br><span class="line">            <span class="comment">// console.log('componentWillEnter');</span></span><br><span class="line">            setTimeout(</span><br><span class="line">                () =&gt;</span><br><span class="line">                    Animated.spring(<span class="keyword">this</span>.state.animate, &#123; <span class="attr">toValue</span>: <span class="number">1</span> &#125;).start(),</span><br><span class="line">                <span class="number">250</span></span><br><span class="line">            );</span><br><span class="line">            cb();</span><br><span class="line">        &#125;</span><br><span class="line">        componentWillLeave(cb) &#123;</span><br><span class="line">            <span class="comment">// console.log('componentWillLeave');</span></span><br><span class="line">            Animated.spring(<span class="keyword">this</span>.state.animate, &#123; <span class="attr">toValue</span>: <span class="number">0</span> &#125;).start();</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> cb(), <span class="number">175</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> style = &#123;</span><br><span class="line">                opacity: Animated.template<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.state.animate&#125;</span>`</span>,</span><br><span class="line">                transform: Animated.template<span class="string">`</span></span><br><span class="line"><span class="string">translate3d(0,<span class="subst">$&#123;<span class="keyword">this</span>.state.animate.interpolate(&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                    inputRange: [<span class="number">0</span>, <span class="number">1</span>],</span></span></span><br><span class="line"><span class="string"><span class="subst">                    outputRange: [<span class="string">'12px'</span>, <span class="string">'0px'</span>]</span></span></span><br><span class="line"><span class="string"><span class="subst">                &#125;</span>)&#125;,0)</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">                height: Animated.template<span class="string">`100%`</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;Animated.div style=&#123;style&#125; className=<span class="string">"animated-page-wrapper"</span>&gt;</span><br><span class="line">                    &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                &lt;<span class="regexp">/Animated.div&gt;</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default AnimatedWrapper;</span></span><br></pre></td></tr></table></figure><p>上述代码主要做了这几件事</p><ul><li>创建一个组件包裹我们的路由组件</li><li>从 <code>TransitionGroup</code> 接收声明周期方法，用以完成<code>animation</code></li><li>使用 <code>Animated</code> 创建一个变量，可以用它来对封装的子组件中的 div 的不同样式属性<br>实现动画效果</li></ul><h2 id="在路由组件中的使用"><a href="#在路由组件中的使用" class="headerlink" title="在路由组件中的使用"></a>在路由组件中的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AnimatedWrapper <span class="keyword">from</span> <span class="string">'./AnimatedWrapper'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"page"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Home&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;Hello from the home page!&lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const Home = AnimatedWrapper(HomeComponent);</span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><p>当路由切换的的时候，我们就能看到过渡效果了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-路由过渡动画&quot;&gt;&lt;a href=&quot;#React-路由过渡动画&quot; class=&quot;headerlink&quot; title=&quot;React 路由过渡动画&quot;&gt;&lt;/a&gt;&lt;code&gt;React&lt;/code&gt; 路由过渡动画&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Anim
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="React" scheme="https://luoyec.cn/tags/React/"/>
    
      <category term="路由动画" scheme="https://luoyec.cn/tags/%E8%B7%AF%E7%94%B1%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://luoyec.cn/2017/12/04/cl4e29qfa0073989eu8500ssx/"/>
    <id>https://luoyec.cn/2017/12/04/cl4e29qfa0073989eu8500ssx/</id>
    <published>2017-12-03T19:30:51.000Z</published>
    <updated>2017-12-03T19:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p><a href="https://book.douban.com/subject/26639401/" target="_blank" rel="noopener">《学习JavaScri数据结构与算法》</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">百度百科：数据结构</a></p></blockquote><ul><li>为什么要学习数据结构？<br>程序=算法+数据结构，计算机程序设计的本质是将业务逻辑转换成数理逻辑，通过逻辑推理以及数理运算解决客观世界存在的困难，而算法和数据解结构就是数理逻辑的推演模式和展现方式。</li></ul><h2 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512327709415.jpg" alt=""></p><blockquote><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">百度百科：二叉搜索树</a></p></blockquote><h2 id="一些名词概念"><a href="#一些名词概念" class="headerlink" title="一些名词概念"></a>一些名词概念</h2><p>一个节点可以有祖先及诶单和后台，一个节点的祖先（除了根节点）包括父节点、祖父节点、曾祖父节点…</p><ul><li><p>子树：子树由节点和它的后台组成</p></li><li><p>节点的深度：节点的深度取决于它的祖先节点的数量</p></li><li><p>树的高度：高度取决于所有节点深度的最大值</p></li></ul><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><ul><li>前序遍历<br>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512328183074.jpg" alt=""><br>前序遍历结果：ABDECF</li></ul><p>前序遍历可用于复制一棵已有的二叉树，或是打印一个结构化的文档。</p><ul><li>中序遍历<br>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512328582853.jpg" alt=""></li></ul><p>以从最小到最大的顺序访问所有节点，中序遍历的一种应用就是排序操作。</p><ul><li>后序遍历<br>指先访问子树，然后访问根的遍历方式。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1512328799677.jpg" alt=""><br>其中的一种应用是计算文件系统中一个目录和它的子目录中所有文件所占空间的大小。</li></ul><h2 id="JavaScript-实现搜索树"><a href="#JavaScript-实现搜索树" class="headerlink" title="JavaScript 实现搜索树"></a><code>JavaScript</code> 实现搜索树</h2><h3 id="创建一棵树"><a href="#创建一棵树" class="headerlink" title="创建一棵树"></a>创建一棵树</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryBree</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">           <span class="comment">//构造节点方法</span></span><br><span class="line">           <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.key = key</span><br><span class="line">               <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">               <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//二叉树根节点</span></span><br><span class="line">           <span class="keyword">var</span> root = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//二叉树插入接口实现</span></span><br><span class="line">           <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">                       node.left = newNode</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       insertNode(node.left, newNode)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">                       node.right = newNode</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       insertNode(node.right, newNode)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodes = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>]</span><br><span class="line">       <span class="keyword">var</span> binaryBree = <span class="keyword">new</span> BinaryBree()</span><br><span class="line"></span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">           binaryBree.insert(key)</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历接口</span></span><br><span class="line">          <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">              inOrderTraverseNode(root, callback)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//中序遍历接口实现方法</span></span><br><span class="line">          <span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">                  inOrderTraverseNode(node.left, callback)</span><br><span class="line"></span><br><span class="line">                  callback(node.key)</span><br><span class="line"></span><br><span class="line">                  inOrderTraverseNode(node.right, callback)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历接口</span></span><br><span class="line">         <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">             preOrderTraverseNode(root, callback)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//前序遍历接口实现</span></span><br><span class="line">         <span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">                 callback(node.key)</span><br><span class="line">                 preOrderTraverseNode(node.left, callback)</span><br><span class="line">                 preOrderTraverseNode(node.right, callback)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后续遍历接口</span></span><br><span class="line">          <span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">              postOrderTraverseNode(root, callback)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//前序遍历接口实现</span></span><br><span class="line">          <span class="keyword">var</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">                  postOrderTraverseNode(node.left, callback)</span><br><span class="line">                  postOrderTraverseNode(node.right, callback)</span><br><span class="line">                  callback(node.key)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最小值</span></span><br><span class="line">         <span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> minNode(root)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                 <span class="comment">//如果当前节点存在左节点，继续执行循环</span></span><br><span class="line">                 <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">                     node = node.left</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> node.key</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//查找最大值</span></span><br><span class="line">         <span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> maxNode(root)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                 <span class="comment">//如果当前节点存在右节点，继续执行循环</span></span><br><span class="line">                 <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">                     node = node.right</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> node.key</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//查找指定数值</span></span><br><span class="line">         <span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> searchNode(root, key)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (node &lt; node.key) &#123;</span><br><span class="line">                 <span class="keyword">return</span> searchNode(node.left, key)</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">                 <span class="keyword">return</span> searchNode(node.right, key)</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定指定节点接口</span></span><br><span class="line">          <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">              root = removeNode(root, key)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//查找排序二叉树中最小节点</span></span><br><span class="line">          <span class="keyword">var</span> finMinNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                  <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">                      node = node.left</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> node</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//删除指定指定节点实现</span></span><br><span class="line">          <span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">                  node.left = removeNode(node.left, key)</span><br><span class="line">                  <span class="keyword">return</span> node</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">                  node.right = removeNode(node.right, key)</span><br><span class="line">                  <span class="keyword">return</span> node</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//左右都没有节点则为叶子节点，可直接删除</span></span><br><span class="line">                  <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">                      node = <span class="literal">null</span></span><br><span class="line">                      <span class="keyword">return</span> node</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//只有右节点，将当前节点替换成右节点</span></span><br><span class="line">                  <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">                      node = node.right</span><br><span class="line">                      <span class="keyword">return</span> node</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//只有左节点，将当前节点替换成做左节点</span></span><br><span class="line">                      node = node.left</span><br><span class="line">                      <span class="keyword">return</span> node</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//拥有左右节点的情况</span></span><br><span class="line">                  <span class="keyword">var</span> aux = finMinNode(node.right)</span><br><span class="line">                  node.key = aux.key</span><br><span class="line">                  node.right = removeNode(node.right, aux.key)</span><br><span class="line">                  <span class="keyword">return</span> node</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h3 id="完整项目文件"><a href="#完整项目文件" class="headerlink" title="完整项目文件"></a><a href="https://github.com/lyctea/arithmetic/blob/master/binaryBree.html" target="_blank" rel="noopener">完整项目文件</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26639401/&quot; target
      
    
    </summary>
    
      <category term="JS数据结构与算法" scheme="https://luoyec.cn/categories/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://luoyec.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="算法与数据结构" scheme="https://luoyec.cn/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>All About React Router 4</title>
    <link href="https://luoyec.cn/2017/11/19/cl4e29qbs000a989e5kcgwdvh/"/>
    <id>https://luoyec.cn/2017/11/19/cl4e29qbs000a989e5kcgwdvh/</id>
    <published>2017-11-18T16:08:35.000Z</published>
    <updated>2018-02-27T02:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://css-tricks.com/react-router-4/" target="_blank" rel="noopener">All About React Router 4</a></p><p><a href="https://codepen.io/bradwestfall/project/editor/XWNWge" target="_blank" rel="noopener">示例代码</a></p><p><code>React Router 4</code> 带来新的API以及新的心智模型</p><h2 id="Inclusive-Routing-引入路由"><a href="#Inclusive-Routing-引入路由" class="headerlink" title="Inclusive Routing 引入路由"></a>Inclusive Routing 引入路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> PrimaryLayout = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div className=<span class="string">"primary-layout"</span>&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      Our React Router <span class="number">4</span> App</span><br><span class="line">      &lt;Route path=<span class="string">"/users"</span> component=&#123;UsersMenu&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">    &lt;main&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Route path="/</span><span class="string">" exact component=&#123;HomePage&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/users<span class="string">" component=&#123;UsersPage&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/main&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><code>UsersMenu</code> 和 <code>UsersPage</code> 可以通过同一个路由被渲染到当前页面中，</p><p><code>exact</code> 精确匹配路由 <code>&#39;/&#39;</code></p><h2 id="Switch-路由组"><a href="#Switch-路由组" class="headerlink" title="Switch 路由组"></a>Switch 路由组</h2><p>当你需要将路由匹配到一个路由组时，使用 <code>Switch</code> 可以匹配到唯一路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PrimaryLayout = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div className=<span class="string">"primary-layout"</span>&gt;</span><br><span class="line">    &lt;PrimaryHeader /&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/users/add"</span> component=&#123;UserAddPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/users"</span> component=&#123;UsersPage&#125; /&gt;</span><br><span class="line">        &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/m</span>ain&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>当使用 <code>Switch</code> 时，只有一个路由会被渲染。</p><p>我们仍然需要使用 <code>exact</code> 当设  <code>HomePage</code>  为首选被渲染的组件。否则等浏览到 <code>/users</code> 或则会使 ‘/users/add’ 时，<code>HomePage</code> 组件仍然会被渲染，如果发生同时渲染，那么先渲染的组件排在最前面。</p><p>当路由匹配 <code>/users/add</code> 时，也会同时匹配到 <code>/users</code> 路由，为确保优先渲染<code>UserAddPage</code> 可以将这个组件写到 <code>UsersPage</code> 前面，如果相反，则调换顺序。<br>当然也可以将所有路由设置为 <code>exact</code> 精确匹配，这样就不存在先后问题。</p><h2 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h2><p>当 <code>Switch</code> 没有匹配到任意一个路由的时候，将会发生路由重定向。</p><h2 id="“Index-Routes”-and-“Not-Found”-（已移除）"><a href="#“Index-Routes”-and-“Not-Found”-（已移除）" class="headerlink" title="“Index Routes” and “Not Found” （已移除）"></a>“Index Routes” and “Not Found” （已移除）</h2><p>在 V4 中不在使用 <code>&lt;IndexRoute&gt;</code>,  而是使用 <code>&lt;Route exact&gt;</code> 精确匹配路由。</p><p>如果没有路由被匹配，可以使用 <code>&lt;Switch&gt;</code> 和  <code>&lt;Redirect&gt;</code> 去重定向到默认路由，或者重定向到 <code>404页面</code></p><h2 id="Nested-Layouts-嵌套布局"><a href="#Nested-Layouts-嵌套布局" class="headerlink" title="Nested Layouts 嵌套布局"></a>Nested Layouts 嵌套布局</h2><p>这里展示两种不同的写法，以及为什么第二种是更好的写法</p><p>第一种采用 <code>exact</code> 精确匹配路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PrimaryLayout = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"primary-layout"</span>&gt;</span><br><span class="line">      &lt;PrimaryHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/"</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/users"</span> exact component=&#123;BrowseUsersPage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/users/:userId"</span> component=&#123;UserProfilePage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/products"</span> exact component=&#123;BrowseProductsPage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/products/:productId"</span> component=&#123;ProductProfilePage&#125; /&gt;</span><br><span class="line">          &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/m</span>ain&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这种写法在技术上是可行的，但是问题在于，<code>props.match</code> 是通过 <code>&lt;Route&gt;</code> 组件传递的。组件     <code>BrowseUsersPage</code> 的子组件并不是通过 <code>&lt;Route&gt;</code> 嵌套路路由中，子组件是不能直接拿到 <code>props.match</code>的。</p><p>当然这里可以通过高阶组件的方式将子组件包装：<a href="https://reacttraining.com/react-router/web/api/withRouter" target="_blank" rel="noopener">withRouter()</a></p><p>第二种写法在第一种写法的基础上做了修改，通过路由嵌套的方式布局组件，并且不再需要使用 <code>exact</code> 精确匹配路由，也不必使用 <a href="https://reacttraining.com/react-router/web/api/withRouter" target="_blank" rel="noopener">withRouter()</a> 加工组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PrimaryLayout = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div className=<span class="string">"primary-layout"</span>&gt;</span><br><span class="line">        &lt;PrimaryHeader /&gt;</span><br><span class="line">        &lt;main&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/"</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/users"</span> component=&#123;UserSubLayout&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/products"</span> component=&#123;ProductSubLayout&#125; /&gt;</span><br><span class="line">                &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/m</span>ain&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const UserSubLayout = () =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;div className="user-sub-layout"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;aside&gt;</span></span><br><span class="line"><span class="regexp">            &lt;UserNav /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/aside&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="primary-content"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Route path="/u</span>sers<span class="string">" exact component=&#123;BrowseUsersPage&#125; /&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/users/:userId<span class="string">" component=&#123;UserProfilePage&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const UserSubLayout = props =&gt; (</span></span><br><span class="line"><span class="string">    &lt;div className="</span>user-sub-layout<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;aside&gt;</span></span><br><span class="line"><span class="string">            &lt;UserNav /&gt;</span></span><br><span class="line"><span class="string">        &lt;/aside&gt;</span></span><br><span class="line"><span class="string">        &lt;div className="</span>primary-content<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;Route</span></span><br><span class="line"><span class="string">                    path=&#123;props.match.path&#125;</span></span><br><span class="line"><span class="string">                    exact</span></span><br><span class="line"><span class="string">                    component=&#123;BrowseUsersPage&#125;</span></span><br><span class="line"><span class="string">                /&gt;</span></span><br><span class="line"><span class="string">                &lt;Route</span></span><br><span class="line"><span class="string">                    path=&#123;`$&#123;props.match.path&#125;/:userId`&#125;</span></span><br><span class="line"><span class="string">                    component=&#123;UserProfilePage&#125;</span></span><br><span class="line"><span class="string">                /&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure><h2 id="Match-匹配对象"><a href="#Match-匹配对象" class="headerlink" title="Match 匹配对象"></a>Match 匹配对象</h2><p><code>Match</code> 对象提供了一下几种属性</p><ul><li><em>params - (object) Key/value pairs parsed from the URL corresponding to the dynamic segments of the path</em></li><li><em>isExact - (boolean) true if the entire URL was matched (no trailing characters)</em></li><li><em>path - (string) The path pattern used to match. Useful for building nested <route>s</route></em></li><li>url - (string) The matched portion of the URL. Useful for building nested <link>s</li></ul><p><code>match.path vs match.url</code></p><p>当路由不携带参数是两者的输出是相同的字符串，尝试打印这两者。</p><p>当路由匹配到例如 <code>/users/5</code> 时，<code>match.ur</code>l 将会输出 <em>“/users/5”</em> ; 而 <code>match.path</code> 输出 <em>“/users/:userId”</em>.</p><h2 id="Avoiding-Match-Collisions-避免匹配冲突"><a href="#Avoiding-Match-Collisions-避免匹配冲突" class="headerlink" title="Avoiding Match Collisions 避免匹配冲突"></a>Avoiding Match Collisions 避免匹配冲突</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSubLayout = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div className=<span class="string">"user-sub-layout"</span>&gt;</span><br><span class="line">    &lt;aside&gt;</span><br><span class="line">      &lt;UserNav /&gt;</span><br><span class="line">    &lt;<span class="regexp">/aside&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div className="primary-content"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Route exact path=&#123;props.match.path&#125; component=&#123;BrowseUsersPage&#125; /</span>&gt;</span><br><span class="line">        &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/add`</span>&#125; component=&#123;AddUserPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/:userId/edit`</span>&#125; component=&#123;EditUserPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/:userId`</span>&#125; component=&#123;UserProfilePage&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/pillarjs/path-to-regexp#custom-match-parameters" target="_blank" rel="noopener">path-to-regexp</a> 用于校验路由参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = pathToRegexp(<span class="string">'/:foo(\\d+)'</span>)</span><br><span class="line"><span class="comment">// keys = [&#123; name: 'foo', ... &#125;]</span></span><br><span class="line"></span><br><span class="line">re.exec(<span class="string">'/123'</span>)</span><br><span class="line"><span class="comment">//=&gt; ['/123', '123']</span></span><br><span class="line"></span><br><span class="line">re.exec(<span class="string">'/abc'</span>)</span><br><span class="line"><span class="comment">//=&gt; null</span></span><br></pre></td></tr></table></figure><h2 id="Authorized-Route-路由认证、权限管理"><a href="#Authorized-Route-路由认证、权限管理" class="headerlink" title="Authorized Route 路由认证、权限管理"></a>Authorized Route 路由认证、权限管理</h2><p>根据用户登录状态管理其浏览路由的权限是应用中很常见的功能</p><p><a href="https://reacttraining.com/react-router/web/example/auth-workflow" target="_blank" rel="noopener">with the help of v4 docs</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/auth"</span> component=&#123;UnauthorizedLayout&#125; /&gt;</span><br><span class="line">            &lt;AuthorizedRoute path=<span class="string">"/app"</span> component=&#123;PrimaryLayout&#125; /&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>BrowserRouter&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以结合 <code>react redux</code>设计权限管理功能，<code>&lt;AuthorizedRoute&gt;</code> 组件先检测当前的登录状态，<br>如果是正在登录，则显示 Loading… </p><p>如果已经登录则，则跳转到到 <code>&lt;PrimaryLayout&gt;</code> 组件中</p><p>如果未登录，则跳转到登录页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class AuthorizedRoute extends React.Component &#123;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    getLoggedUser()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; component: Component, pending, logged, ...rest &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;Route &#123;...rest&#125; render=&#123;props =&gt; &#123;</span><br><span class="line">        if (pending) return &lt;div&gt;Loading...&lt;/div&gt;</span><br><span class="line">        return logged</span><br><span class="line">          ? &lt;Component &#123;...this.props&#125; /&gt;</span><br><span class="line">          : &lt;Redirect to=&quot;/auth/login&quot; /&gt;</span><br><span class="line">      &#125;&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stateToProps = (&#123; loggedUserState &#125;) =&gt; (&#123;</span><br><span class="line">  pending: loggedUserState.pending,</span><br><span class="line">  logged: loggedUserState.logged</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default connect(stateToProps)(AuthorizedRoute)</span><br></pre></td></tr></table></figure><h2 id="Other-mentions-其他"><a href="#Other-mentions-其他" class="headerlink" title="Other mentions 其他"></a>Other mentions 其他</h2><p><code>&lt;Link&gt; vs &lt;NavLink&gt;</code></p><p>这两个功能一样，都是路由跳转，但是NavLink有一个属性用来显示跳转选中的样式，activeStyle属性，写显示高亮样式的，接收一个对象{}</p><p>在我们路由导航有一个to属性</p><p>to属性是我们路由的要跳转的路径:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PrimaryHeader = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;header className=<span class="string">"primary-header"</span>&gt;</span><br><span class="line">    &lt;h1&gt;Welcome to our app!&lt;/h1&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;NavLink to=<span class="string">"/app"</span> exact activeClassName=<span class="string">"active"</span>&gt;Home&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">      &lt;NavLink to="/</span>app/users<span class="string">" activeClassName="</span>active<span class="string">"&gt;Users&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">      &lt;NavLink to="</span>/app/products<span class="string">" activeClassName="</span>active<span class="string">"&gt;Products&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">    &lt;/nav&gt;</span></span><br><span class="line"><span class="string">  &lt;/header&gt;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default PrimaryHeader</span></span><br></pre></td></tr></table></figure><h2 id="Dynamic-Routes-动态路由"><a href="#Dynamic-Routes-动态路由" class="headerlink" title="Dynamic Routes 动态路由"></a>Dynamic Routes 动态路由</h2><p>在 V4中最好的一部分改变是可以在所有地方包含 <code>&lt;Route&gt;</code> ， 它只是一个 React 组件。</p><p>路由将不再是神奇的东西，我们可以用在任何地方，试想一下，当满足条件时，整个路由都可以被路由到。</p><p>在这些条件不满足时，我们可以移除那些路由，甚至，可以嵌套路由。</p><p><code>React Router 4</code> 变得更好用是因为这只是一个 <a href="https://www.youtube.com/watch?v=Mf0Fy8iHp8k&amp;feature=youtu.be&amp;t=3m22s" target="_blank" rel="noopener"> Just Components™</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/react-router-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;All About React Router 4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="react" scheme="https://luoyec.cn/tags/react/"/>
    
      <category term="react-router" scheme="https://luoyec.cn/tags/react-router/"/>
    
      <category term="声明式路由" scheme="https://luoyec.cn/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://luoyec.cn/2017/11/18/cl4e29qdt004a989epo41tuoe/"/>
    <id>https://luoyec.cn/2017/11/18/cl4e29qdt004a989epo41tuoe/</id>
    <published>2017-11-18T01:46:05.000Z</published>
    <updated>2018-06-11T09:07:45.309Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：</p><p><a href="http://www.jianshu.com/p/630e2e1ca57f" target="_blank" rel="noopener">Nginx 从听说到学会</a></p><p><a href="http://www.jianshu.com/p/cc65354a0874" target="_blank" rel="noopener">Mac Nginx 安装（Brew）</a></p><p><a href="http://www.cnblogs.com/gabrielchen/p/5066120.html" target="_blank" rel="noopener">用 nginx 的反向代理机制解决前端跨域问题</a></p><h2 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h2><blockquote><p>==Nginx== 是一款轻量级的 ==Web== 服务器/反向代理服务器及电子邮件 ==（IMAP/POP3）== 代理服务器，并在一个 ==BSD-like == 协议下发行。<br>其特点是占有内存少，并发能力强，事实上 ==nginx== 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 ==nginx== 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。<br>——百度词条</p></blockquote><ul><li><p>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接</p></li><li><p>高度的模块化和自由软件许可证是的第三方模块层出不穷</p></li><li><p>Nginx 是一个跨平台服务器，可以运行在 Linux, FreeBSD, Solaris, AIX, Mac OS, Windows 等操作系统上</p></li><li><p>这些优秀的设计带来的极大的稳定性。</p></li></ul><h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><h3 id="lighttpd"><a href="#lighttpd" class="headerlink" title="lighttpd"></a>lighttpd</h3><blockquote><p>Lighttpd 是一个具有非常低的内存开销，cpu 占用率低，效能好，以及丰富的模块等特点。lighttpd 是众多 OpenSource 轻量级的 web<br>server 中较为优秀的一个。支持 FastCGI, CGI, Auth, 输出压缩(output compress), URL 重写,<br>Alias 等重要功能。</p></blockquote><blockquote><p>Lighttpd 使用 fastcgi 方式运行 PHP,它会使用很少的 PHP 进程响应很大的并发量。</p></blockquote><blockquote><p>Fastcgi 的优点在于：</p></blockquote><blockquote><ul><li>从稳定性上看, fastcgi 是以独立的进程池运行来 cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑.</li></ul></blockquote><blockquote><ul><li>从安全性上看, fastcgi 和宿主的 server 完全独立, fastcgi 怎么 down 也不会把 server 搞垮,</li></ul></blockquote><blockquote><ul><li>从性能上看, fastcgi 把动态逻辑的处理从 server 中分离出来, 大负荷的 IO 处理还是留给宿主 server, 这样宿主 server 可以一心一意作 IO,对于一个普通的动态网页来说, 逻辑处理可能只有一小部分,<br>大量的图片等静态 IO 处理完全不需要逻辑程序的参与</li></ul></blockquote><blockquote><ul><li>从扩展性上讲, fastcgi 是一个中立的技术标准, 完全可以支持任何语言写的处理程序 php,Java,Python</li></ul></blockquote><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><blockquote><p>apache 是世界排名第一的 web 服务器, 根据 netcraft 所作的调查,世界上百分之五十以上的 web 服务器在使用 apache.</p></blockquote><blockquote><p>1995 年 4 月, 最早的 apache(0.6.2 版)由 apache group 公布发行. apache group<br>是一个完全通过 internet 进行运作的非盈利机构, 由它来决定 apache web 服务器的标准发行版中应该包含哪些内容.<br>准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给 apache group 时,<br>该团体审核它的具体内容, 进行测试 如果认为满意, 该代码就会被集成到 apache 的主要发行版中。</p></blockquote><blockquote><p>apache 的特性:</p></blockquote><blockquote><p>几乎可以运行在所有的计算机平台上<br>支持最新的 http/1.1 协议 简单而且强有力的基于文件的配置(httpd.conf)<br>支持通用网关接口(cgi)<br>支持虚拟主机<br>支持 http 认证<br>集成 perl<br>集成的代理服务器<br>可以通过 web 浏览器监视服务器的状态,<br>可以自定义日志<br>支持服务器端包含命令(ssi)<br>支持安全 socket 层(ssl)<br>具有用户会话过程的跟踪能力<br>支持 fastcgi<br>支持 Java</p></blockquote><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><blockquote><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，<br>是一个高性能的 HTTP 和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器．Nginx 是由俄罗斯人 Igor<br>Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发.</p></blockquote><blockquote><p>Nginx 以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配<br>Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。但是 Nginx 并不支持 cgi 方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用 FastCGI 方式来执行 PHP 程序。</p></blockquote><blockquote><p>nginx 做为 HTTP 服务器，有以下几项基本特性：</p></blockquote><blockquote><p>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲 无缓存的反向代理加速，简单的负载均衡和容错 FastCGI，简单的负载均衡和容错<br>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及<br>SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。<br>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达<br>50,000 个并发连接数。</p></blockquote><blockquote><p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web 响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 nginx 来说基本上是毫无用处的。就稳定性而言,nginx 比 lighthttpd 更胜一筹。</p></blockquote><blockquote><p>Nginx 支持热部署。它的启动特别容易,<br>并且几乎可以做到 7X24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p></blockquote><h3 id="三种服务器比较"><a href="#三种服务器比较" class="headerlink" title="三种服务器比较"></a>三种服务器比较</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510929883976.jpg" alt=""></p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><p><a href="http://www.jianshu.com/p/cc65354a0874" target="_blank" rel="noopener">Mac Nginx 安装（Brew）</a></p><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><code>Homebrew</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> man brew</span><br></pre></td></tr></table></figure><p>安装 <code>Homebrew</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)"</span><br></pre></td></tr></table></figure><p>其他常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:~ wany$ brew --version  (查看当前电脑所安装的brew版本)</span><br><span class="line"></span><br><span class="line">localhost:~ wany$ brew update (更新电脑中的brew版本)</span><br></pre></td></tr></table></figure><p>通过 <code>brew</code> 安装 <code>Nginx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo /usr/local/sbin/nginx</span><br></pre></td></tr></table></figure><p>注意事项：<br>安装 <code>nignx, brew</code> 所安装的软件都保存在 <code>:/usr/local/Cellar/</code><br><code>nginx</code> 配置文件保存到了：<code>/usr/local/etc/nginx/nginx.conf</code></p><p>建立软连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ln -s /usr/local/bin/nginx  /usr/local/bin/nginx</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo nginx</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h2><p><a href="http://www.cnblogs.com/gabrielchen/p/5066120.html" target="_blank" rel="noopener">用 nginx 的反向代理机制解决前端跨域问题</a></p><h3 id="什么是跨域以及产生的原因"><a href="#什么是跨域以及产生的原因" class="headerlink" title="什么是跨域以及产生的原因"></a>什么是跨域以及产生的原因</h3><p>跨域是指 a 页面想获取 b 页面资源，如果 a、b 页面的协议、域名、端口、子域名不同，或是 a 页面为 ip 地址，b 页面为域名地址，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。</p><p>跨域情况如下：<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510961386869.jpg" alt=""></p><h3 id="跨域常见的解决方法"><a href="#跨域常见的解决方法" class="headerlink" title="跨域常见的解决方法"></a>跨域常见的解决方法</h3><p>目前来讲没有不依靠服务器端来跨域请求资源的技术</p><ul><li><p>1.jsonp 需要目标服务器配合一个 callback 函数。</p></li><li><p>2.window.name+iframe 需要目标服务器响应 window.name。</p></li><li><p>3.window.location.hash+iframe 同样需要目标服务器作处理。</p></li><li><p>4.html5 的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。</p></li><li><p>5.CORS 需要服务器设置 header ：Access-Control-Allow-Origin。</p></li><li><p>6.nginx 反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转 nginx 服务器，用于转发请求。</p></li></ul><h3 id="Nginx-反向代理解决跨域"><a href="#Nginx-反向代理解决跨域" class="headerlink" title="Nginx 反向代理解决跨域"></a>Nginx 反向代理解决跨域</h3><p>修改配置文件：</p><p>路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">luoyecs-iMac:nginx luoyec$ pwd</span><br><span class="line">/usr/local/etc/nginx</span><br></pre></td></tr></table></figure><p>修改 <code>nginx.conf</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">listen </span>      <span class="string">9000;</span><span class="comment">#监听9000端口号，</span></span><br><span class="line">     <span class="string">server_name </span> <span class="string">localhost;</span><span class="comment">#当前服务器域名，一般是开发者本地电脑</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">     <span class="string">location </span>/ &#123;</span><br><span class="line">        <span class="comment"># root   html;# 根路径</span></span><br><span class="line">        <span class="comment"># index  index.html index.htm; #根路径下的入口文件</span></span><br><span class="line">      <span class="string">proxy_pass </span><span class="string">http:</span>//<span class="string">localhost:3000;</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="string">location </span>/<span class="string">mobile/</span> &#123;<span class="comment"># 注意这里可以写正则表达式，（匹配规则，用于拦截请求，匹配任何以 /proxy/html/开头的地址，匹配符合以后，停止往下搜索正则）</span></span><br><span class="line">         <span class="string">rewrite </span>^/<span class="string">mobild/</span>(.*)$ /$1 <span class="string">break;</span> <span class="comment">#代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如www.c.com/proxy/html/api/msg?method=1&amp;para=2重写。只对/proxy/html/api/msg重写。</span></span><br><span class="line">         <span class="string">proxy_pass </span><span class="string">http:</span>//<span class="string">www.</span><span class="string">daolimen.</span><span class="string">com;</span> <span class="comment"># 既是把请求代理到其他主机</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>重启 nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<br><code>http://localhost:9000/</code></p><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>首先找到 nginx.conf 或者 nginx.conf.default 或者是 default 里面的这部份</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510968845375.jpg" alt=""></p><p>其中 server 代表启动的一个服务，location 是一个定位规则。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /｛   #所有以/开头的地址，实际上是所有请求</span><br><span class="line"></span><br><span class="line">root  <span class="selector-tag">html</span>     ＃去请求../html文件夹里的文件,其中..的路径在nginx里面有定义，安装的时候会有默认路</span><br><span class="line"></span><br><span class="line">index  index<span class="selector-class">.html</span> index<span class="selector-class">.htm</span>  ＃首页响应地址</span><br></pre></td></tr></table></figure><p>从上面可以看出 location 是 nginx 用来路由的入口，所以我们接下来要在 location 里面完成我们的反向代理。</p><p>假如我们我们是 <a href="http://www.a.com/html/msg.html" target="_blank" rel="noopener">www.a.com/html/msg.html</a> 想请求 <a href="http://www.b.com/api/?method=1&amp;para=2；" target="_blank" rel="noopener">www.b.com/api/?method=1&amp;para=2；</a></p><p>我们的 ajax：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://www.b.com/api/msg?method=1&amp;para=2'</span>；</span><br><span class="line">&lt;br&gt;$.ajax(&#123;</span><br><span class="line">type: <span class="string">"GET"</span>,</span><br><span class="line">url:url,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;..&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的请求必然会遇到跨域问题，这时我们需要修改一下我们的请求 url，让请求发在 nginx 的一个 url 下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://www.b.com/api/msg?method=1&amp;para=2&apos;；</span><br><span class="line">var proxyurl ＝ &apos;msg?method=1&amp;para=2&apos;；</span><br><span class="line">//假如实际地址是 www.c.com/proxy/html/api/msg?method=1&amp;para=2; www.c.com是nginx主机地址</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">type: &quot;GET&quot;,</span><br><span class="line">url:proxyurl,</span><br><span class="line">success: function(res)&#123;..&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再在刚才的路径中匹配到这个请求，我们在 location 下面再添加一个 location。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ^~/proxy/html/&#123;</span><br><span class="line">rewrite ^/proxy/html/(.*)$ /$1 break;</span><br><span class="line">proxy_pass http://www.b.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下做一个解释：</p><ul><li><code>&#39;^~ /proxy/html/ &#39;</code></li></ul><p>就像上面说的一样是一个匹配规则，用于拦截请求，匹配任何以 /proxy/html/开头的地址，匹配符合以后，停止往下搜索正则。</p><ul><li><code>rewrite ^/proxy/html/(.*)$ /$1 break;</code></li></ul><p>代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <a href="http://www.c.com/proxy/html/api/msg?method=1&amp;para=2" target="_blank" rel="noopener">www.c.com/proxy/html/api/msg?method=1&amp;para=2</a> 重写。只对/proxy/html/api/msg 重写。</p><p>rewrite 后面的参数是一个简单的正则 ^/proxy/html/(.*)$ ,$1 代表正则中的第一个(),$2 代表第二个()的值,以此类推。</p><p>break 代表匹配一个之后停止匹配。</p><ul><li>proxy_pass</li></ul><pre><code>既是把请求代理到其他主机，其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下:</code></pre><p>不带/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /html/</span><br><span class="line">&#123;</span><br><span class="line">　　proxy_pass http://b.com:8300;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /html/</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://b.com:8300/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种配置，区别只在于 proxy_pass 转发的路径后是否带 “/”。</p><p>针对情况 1，如果访问 url = <a href="http://server/html/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/html/test.jsp，将test/" target="_blank" rel="noopener">http://server/html/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/html/test.jsp，将test/</a> 作为根路径，请求 test/路径下的资源。</p><p>针对情况 2，如果访问 url = <a href="http://server/html/test.jsp，则被nginx代理后，请求路径会变为" target="_blank" rel="noopener">http://server/html/test.jsp，则被nginx代理后，请求路径会变为</a> <a href="http://proxy_pass/test.jsp，直接访问server的根资源。" target="_blank" rel="noopener">http://proxy_pass/test.jsp，直接访问server的根资源。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/630e2e1ca57f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx 从听说到学会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.j
      
    
    </summary>
    
      <category term="工程化" scheme="https://luoyec.cn/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Nginx" scheme="https://luoyec.cn/tags/Nginx/"/>
    
      <category term="反向代理" scheme="https://luoyec.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="跨域" scheme="https://luoyec.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Eslint代码检查及格式化</title>
    <link href="https://luoyec.cn/2017/11/11/cl4e29qc4000w989ehls8g657/"/>
    <id>https://luoyec.cn/2017/11/11/cl4e29qc4000w989ehls8g657/</id>
    <published>2017-11-11T15:31:18.000Z</published>
    <updated>2017-11-11T15:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>资源列表：<br><a href="http://eslint.cn/" target="_blank" rel="noopener">Eslint官网（中文）</a></p><p><a href="https://hackernoon.com/configure-eslint-prettier-and-flow-in-vs-code-for-react-development-c9d95db07213" target="_blank" rel="noopener">Configure ESLint, Prettier, and Flow in VS Code for React Development</a></p><p><a href="http://www.zcfy.cc/article/configure-eslint-prettier-and-flow-in-vs-code-for-react-development-2962.html" target="_blank" rel="noopener">React开发，在VS Code中配置ESLint, Prettier, and Flow（上篇译文）</a></p><p><a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb#eslint-config-airbnb-1" target="_blank" rel="noopener">Airbnb’s JavaScript Github Repo</a></p><p><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb es6 官方文档</a></p><p><a href="https://github.com/yuche/javascript" target="_blank" rel="noopener">airbnb es6 规范文档（中文）</a></p><p><a href="https://prettier.io/" target="_blank" rel="noopener">Prettier官网</a></p><p><a href="https://www.npmjs.com/package/babel-eslint" target="_blank" rel="noopener">babel-esling npm库</a></p><h1 id="代码规范及格式化"><a href="#代码规范及格式化" class="headerlink" title="代码规范及格式化"></a>代码规范及格式化</h1><p>本文档使用create-react-app脚手架创建一个新项目，从零开始继承所需要的工具，并完成所有的配置。操作系统为<code>macOS</code>，<code>Windows</code>下快捷键及安装方式可能有差异，不过不影响工具集成。</p><p>采用<code>eslint-config-airbnb</code> es6版，具有完整的中英文文档（详见资源列表），以及在此基础上定制规则。</p><h2 id="VSCode扩展插件安装"><a href="#VSCode扩展插件安装" class="headerlink" title="VSCode扩展插件安装"></a>VSCode扩展插件安装</h2><p>请自行安装一下扩展插件，暂时不必添加任何配置</p><ul><li>Eslint</li><li>Prettier JavaScript Formatter</li><li>Babel ES6/ES7</li></ul><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><blockquote><p>ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas<br>于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。</p></blockquote><blockquote><p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript代码错误通常需要在执行过程中不断调适。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。</p></blockquote><blockquote><p>ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。为了便于人们使用，ESLint内置了一些规则，当然，你可以在使用过程中自定义规则。</p></blockquote><blockquote><p>ESLint 使用 Node.js 编写，这样既可以有一个快速的运行环境的同时也便于安装。</p></blockquote><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><blockquote><p>Prettier 一个 JavaScript 格式化工具. 它的灵感来源于 refmt，它对于 ES6、ES7、 JSX 和 Flow的语言特性有着高级的支持。通过将 JavaScript 解析为 AST 并且基于 AST 美化和打印，Prettier会丢掉几乎全部的原始的代码风格，从而保证 JavaScript 代码风格的一致性。</p></blockquote><h3 id="解析器-babel-eslint"><a href="#解析器-babel-eslint" class="headerlink" title="解析器(babel-eslint)"></a>解析器(babel-eslint)</h3><p>Specifying Parser<br>ESLint 默认使用Espree作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：</p><ul><li>它必须是本地安装的一个 npm 模块。</li><li>它必须有兼容 Esprima 的接口（它必须输出一个 parse() 方法）</li><li>它必须产出兼容 Esprima 的 AST 和 token 对象。</li><li>注意，即使满足这些兼容性，也不能保证一个外部解析器可以与 ESLint 正常工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。</li></ul><p>为了表明使用该 npm 模块作为你的解析器，你需要在你的 .eslintrc 文件里指定 parser 选项。例如，下面的配置指定了 Esprima 作为解析器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"parser"</span>: <span class="string">"esprima"</span>,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: <span class="string">"error"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下解析器与 ESLint 兼容：</p><ul><li><p>Esprima</p></li><li><p>Babel-ESLint - 对Babel解析器的包装使其与 ESLint 兼容。</p></li><li><p>typescript-eslint-parser(实验) - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样就它就可以在 ESLint 中使用了。这样的目的是允许通过 ESLint （尽管不一定要通过所有的 ESLint 规则）来解析 TypeScript 文件。</p></li></ul><p>注意，当使用自定义解析器时，为了使 ESLint 在非 ECMAScript 5 特性下正常工作，配置属性 parserOptions 仍然是必须的。解析器被传入 parserOptions，可能会也可能不会使用它们来决定开启哪个特征。</p><h2 id="项目初始化及模块安装"><a href="#项目初始化及模块安装" class="headerlink" title="项目初始化及模块安装"></a>项目初始化及模块安装</h2><p>创建项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>create-react-app eslint_test</span><br><span class="line"><span class="meta">$</span>cd eslint_test</span><br></pre></td></tr></table></figure><p>全局安装 <code>eslint</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g eslint</span><br></pre></td></tr></table></figure><p>查看当前<code>eslint-config-airbnb</code> 所依赖的最新包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm info "eslint-config-airbnb@latest" peerDependencies</span><br><span class="line"></span><br><span class="line">&#123; eslint: '^4.9.0',</span><br><span class="line">  'eslint-plugin-import': '^2.7.0',</span><br><span class="line">  'eslint-plugin-jsx-a11y': '^6.0.2',</span><br><span class="line">  'eslint-plugin-react': '^7.4.0' </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>建议手动的方式安装，需要注意的是<code>eslint-plugin-jsx-a11y</code>指定<code>5.1.1</code>版本，在更好版本中，存在bug，详见<a href="https://github.com/facebookincubator/create-react-app/pull/2930" target="_blank" rel="noopener">#2930</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yarn add eslint-plugin-import</span><br><span class="line"><span class="meta">$</span> yarn add eslint-plugin-jsx-a11y@5.1.1</span><br><span class="line"><span class="meta">$</span> yarn add eslint-plugin-react</span><br><span class="line"><span class="meta">$</span> yarn add eslint-config-airbnb</span><br></pre></td></tr></table></figure><p>安装<code>$ yarn add babel-eslint</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yarn add babel-eslint</span><br></pre></td></tr></table></figure><p>安装 <code>prettier-eslint</code><br><code>yarn add prettier-eslint</code></p><p>创建<code>.eslintrc</code>文件，其配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"react"</span>, <span class="string">"jsx-a11y"</span>, <span class="string">"import"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VSCode通用设置"><a href="#VSCode通用设置" class="headerlink" title="VSCode通用设置"></a>VSCode通用设置</h2><p>在使用prettier时，默认table宽度是两空格，这里设置成四空格</p><ul><li><p>打开设置，mac下快捷键为<code>cmd + ,</code></p></li><li><p><code>&quot;prettier.tabWidth&quot;: 4</code>//Table宽度设为四个空格</p></li><li><p><code>&quot;editor.formatOnSave&quot;: true,</code>//保存时自动格式化代码</p></li><li><p><code>&quot;javascript.format.enable&quot;: false,</code>//禁用自带的js格式化</p></li><li><p><code>&quot;prettier.eslintIntegration&quot;: true,</code>//使用<code>&#39;prettier-eslint&#39;</code> 代替 <code>&#39;prettier&#39;</code></p></li></ul><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>红色下划线波浪，是eslint的提示，将鼠标移到该出可以看到具体的信息提示。</p><p>提示是因为<code>eslint-config-airbnb</code>推荐采用的是.jsx作为jsx文件的后缀名以及<br>当前的组件可以采用纯函数的写法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510187608990.jpg" alt=""></p><p>在自定义规则中，我们忽略文件后缀以及缩进宽度设置为4空格，当缩进不满足要求时，eslint提示为error。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"react"</span>, <span class="string">"jsx-a11y"</span>, <span class="string">"import"</span>],</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"indent"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"SwitchCase"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"VariableDeclarator"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"outerIIFEBody"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"FunctionDeclaration"</span>: &#123;</span><br><span class="line">                    <span class="attr">"parameters"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"body"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"FunctionExpression"</span>: &#123;</span><br><span class="line">                    <span class="attr">"parameters"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"body"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"CallExpression"</span>: &#123;</span><br><span class="line">                    <span class="attr">"arguments"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"ArrayExpression"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"ObjectExpression"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"ImportDeclaration"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"flatTernaryExpressions"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"ignoredNodes"</span>: [<span class="string">"JSXElement"</span>, <span class="string">"JSXElement *"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"react/jsx-filename-extension"</span>: [<span class="number">1</span>, &#123; <span class="attr">"extensions"</span>: [<span class="string">".js"</span>, <span class="string">".jsx"</span>] &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当eslint正常工作的时候，更多优点等待挖掘</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510194297107.jpg" alt=""></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>采用的<code>eslint-config-airbnb</code> 有完整的规则文档，但在实际生产中，具体的规则需要重新配置，这部分需要大家参与了，反馈提交，然后补充完善规则。</p><p><code>git commit</code> 时执行脚本，自动格式化代码并检查不符合eslint规则，不能提交。</p><p><code>git commit</code> 规范化，并输出成文档，集成 emoji 表情，这是下一个议题了。</p><h2 id="Flow工作流"><a href="#Flow工作流" class="headerlink" title="Flow工作流"></a>Flow工作流</h2><blockquote><p>Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.</p></blockquote><p><a href="https://flow.org/en/" target="_blank" rel="noopener">官网</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 <code>create react app</code> 中使用，详见官方文档。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510122624051.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1510105059916.jpg" alt=""></p><p>鉴于目前项目的复杂度，暂不集成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源列表：&lt;br&gt;&lt;a href=&quot;http://eslint.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eslint官网（中文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/configure-esl
      
    
    </summary>
    
      <category term="Eslint" scheme="https://luoyec.cn/categories/Eslint/"/>
    
    
      <category term="工具" scheme="https://luoyec.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="代码检查" scheme="https://luoyec.cn/tags/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"/>
    
      <category term="vs code" scheme="https://luoyec.cn/tags/vs-code/"/>
    
  </entry>
  
  <entry>
    <title>58脚手架分享讲义</title>
    <link href="https://luoyec.cn/2017/11/10/cl4e29qbq0008989epgyox1b2/"/>
    <id>https://luoyec.cn/2017/11/10/cl4e29qbq0008989epgyox1b2/</id>
    <published>2017-11-09T17:08:09.000Z</published>
    <updated>2017-11-09T17:08:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/lyctea/learning-step" target="_blank" rel="noopener">转自</a></p><h2 id="目录大纲"><a href="#目录大纲" class="headerlink" title="目录大纲"></a>目录大纲</h2><h3 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>假设，接到一个新的项目：演唱会售票系统，在做系统之前，要考虑很多问题<ul><li>项目目录如何组织</li><li>使用何种类库</li><li>dev和prod环境如何搞</li><li>团队内部其他系统都用了什么</li><li>多人合作开发，团队环境和代码规范问题怎么解决</li><li>是否需要出文档，教其他团队成员配置环境，安装依赖等</li><li>每一个项目皆是如此，效率何在</li></ul></li><li>我们这次脚手架是以react为例，主要是讲解开发思路，当然用vue的团队也可模仿，或者 后面我们的开源脚手架可以提供创建vue项目的功能</li></ul><h4 id="为什么不用create-react-app"><a href="#为什么不用create-react-app" class="headerlink" title="为什么不用create-react-app"></a>为什么不用create-react-app</h4><ul><li>不满足当前团队需求</li><li>不可以定制化，需要二次修改配置</li><li>没有开发组件的能力（后续有讲解组件开发的重要性）</li><li>为何不自己开发一个类似于 create-react-app 或者 vue-cli的工具呢</li></ul><h4 id="yeoman简单介绍"><a href="#yeoman简单介绍" class="headerlink" title="yeoman简单介绍"></a>yeoman简单介绍</h4><ul><li>yeoman 提供了一个我们开发脚手架的能力</li><li>按照yeoman的规范，我们开发一个npm包，yeoman就会帮我们执行这个npm的功能（其实就是拿node操作一些相关的文件）</li><li><p>yeoman的安装</p><ul><li><figure class="highlight plain"><figcaption><span>install yo -g``` 会生成一个yo的全局命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 最最基础的脚手架功能</span><br><span class="line">- 把全局环境node_modules包下面的模板工程 copy 到你的当前项目路径文件夹下</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://oyoee89se.bkt.clouddn.com/A4C21ECA-C440-4BF7-9E24-96C85A8FA4E6.png&quot; width=&quot;500&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- 下面讲一下yo这个命令 是怎么生成到全局命令里面去的</span><br><span class="line"></span><br><span class="line">#### 启动命令原理示例</span><br><span class="line">- ```mkdir flash-cli &amp;&amp; cd ./flash-cli/</span><br></pre></td></tr></table></figure></li></ul></li><li><figure class="highlight plain"><figcaption><span>init``` 初始化package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 添加 index.js 文件</span><br><span class="line">- ```#!/usr/bin/env node``` </span><br><span class="line">- linux的 \*shell* 脚本，需在开头一行指定脚本的解释程序，此地规定的解释程序为node</span><br><span class="line">- env的作用：因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量</span><br><span class="line">- Mac系统下执行 ```env``` 可以看到log</span><br><span class="line"></span><br><span class="line">``` javascript</span><br><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">console.log(&quot;Hello Flash!&quot;)</span><br></pre></td></tr></table></figure></li><li><p>package.json 修改</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"flash-cli"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"flash"</span>: <span class="string">"index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"战楼"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目录结构</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/D8047137-8A5F-4C2F-B1FB-A9CD1EAF3D7A.png" width="500"></p></li><li><figure class="highlight plain"><figcaption><span>link```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 将此工程包 添加到 全局node-modules 下进行本地调试 （npm link 相当于 npm install flash-cli -g ，npm link 将当前包 以软链接的形式 放在全局node_modules环境下）</span><br><span class="line">- ```npm unlink``` 可以取消此软链接</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://oyoee89se.bkt.clouddn.com/7DDD68E3-E8FF-4470-915F-67C1AA819D0C.png&quot; width=&quot;500&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- ```/usr/local/bin/flash -&gt; /usr/local/lib/node_modules/flash-cli/index.js</span><br></pre></td></tr></table></figure><ul><li><figure class="highlight plain"><figcaption><span>-></span><a href="/Users/fengdewang/myApp/water-wheel/flash-cli```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 任意目录下执行 ```flash</span><br></pre></td></tr></table></figure><p><img src="http://oyoee89se.bkt.clouddn.com/EC230FF9-9749-4EF6-81FD-E62633BE6419.png" width="500"></p></li></ul></li><li><p>下面我们进一步的完善此工具        </p></li></ul><h4 id="简单的shell交互和文件操作"><a href="#简单的shell交互和文件操作" class="headerlink" title="简单的shell交互和文件操作"></a>简单的shell交互和文件操作</h4><ul><li>实现目标功能<ul><li>打印欢迎语</li><li>用户输入姓名、选择性别、选择爱好标签、输入创建文件的文件名</li><li>根据模板生成html文件</li><li>浏览器自动打开生成的文件</li><li>打印结束语</li></ul></li><li>实现效果预览</li></ul><p><img src="http://oyoee89se.bkt.clouddn.com/2017-10-31-16_48_31.gif" width="500"></p><ul><li>dependencies介绍<ul><li>colors: 可以在terminal打印自定义样式的字</li><li>ejs: 模板渲染工具</li><li>inquirer: 提供terminal和用户交互的能力</li><li>mkdirp: 生成文件夹 or 生成指定路径的文件夹(语法糖)</li><li>shelljs: 提供给node运行shell命令的能力</li></ul></li><li><p>其他node的知识点</p><ul><li><figure class="highlight plain"><figcaption><span>当前模块的完整绝对路径</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- ```fs.readFileSync(filename, [encoding])``` 同步读取文件</span><br><span class="line">- ```fs.writeFileSync(filename, data, [options])``` 同步写入文件</span><br><span class="line">- ```process``` node进程对象</span><br><span class="line">- ```process.platform``` 获取当前操作系统识别符</span><br><span class="line">- ```darwin、win32、linux``` 等系统</span><br><span class="line">- ```path``` node路径解析模块</span><br><span class="line">- ```open &lt;filePath&gt;``` mac下使用默认工具打开文件</span><br><span class="line">- ```start &lt;filePath&gt;``` windows下使用默认工具打开文件</span><br><span class="line">- 安装依赖</span><br><span class="line">- ```npm i colors ejs inquirer mkdirp shelljs --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于已有目录结构新建tpl.html模板文件</p></li><li>当前目录结构</li></ul><p><img src="http://oyoee89se.bkt.clouddn.com/923AC3E6-4048-41C4-B66E-343D068C8137.png" width="500"></p><ul><li><p>index.js修改如下</p><ul><li><p>引入node模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'colors'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>);</span><br><span class="line"><span class="keyword">const</span> shelljs = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</span><br></pre></td></tr></table></figure></li><li><p>打印欢迎语</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">//欢迎语</span><br><span class="line">console.log(&quot;\n&quot; + &quot;Hello World, I&apos;m flash-cli&quot;.magenta + &quot;\n&quot;);</span><br><span class="line">console.log(&quot;It&apos;s just a test&quot;.red + &quot;\n&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常量声明</p><ul><li><p>同一个字符串 尽量不要出现两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">const</span> ENCODE = <span class="string">'utf-8'</span>;</span><br><span class="line"><span class="keyword">const</span> BUILD_PATH = <span class="string">'./build'</span>;</span><br><span class="line"><span class="keyword">const</span> BUILD_FILE_TYPE = <span class="string">'.html'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用户交互 inquirer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户交互问题列表</span></span><br><span class="line"><span class="keyword">const</span> question = [</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">'input'</span>,</span><br><span class="line">name: <span class="string">'fileName'</span>,</span><br><span class="line"><span class="keyword">default</span>: <span class="string">'index'</span>,</span><br><span class="line">message: <span class="string">'请输入你要生成文件的名字'</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//交互</span></span><br><span class="line">inquirer.prompt(question).then(<span class="function"><span class="params">answer</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">`<span class="subst">$&#123;answer.fileName&#125;</span><span class="subst">$&#123;BUILD_FILE_TYPE&#125;</span>`</span>;<span class="comment">//文件名</span></span><br><span class="line">createFile(answer, fileName);<span class="comment">//创建文件</span></span><br><span class="line">openFile(<span class="string">`<span class="subst">$&#123;BUILD_PATH&#125;</span>/<span class="subst">$&#123;fileName&#125;</span>`</span>);<span class="comment">//打开创建的文件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createFile = <span class="function">(<span class="params">data, fileName</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> tpl = fs.readFileSync(__dirname + <span class="string">'/tpl.html'</span>, ENCODE);<span class="comment">//读取模板文件</span></span><br><span class="line">mkdirp.sync(BUILD_PATH);<span class="comment">//生成build目录文件夹</span></span><br><span class="line">fs.writeFileSync(<span class="string">`<span class="subst">$&#123;BUILD_PATH&#125;</span>/<span class="subst">$&#123;fileName&#125;</span>`</span>, ejs.render(tpl, data), ENCODE); <span class="comment">//写入index.html文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>打开所创建的文件    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> openFile = <span class="function"><span class="params">buildFilePath</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//mac </span></span><br><span class="line"><span class="keyword">if</span>(process.platform == <span class="string">'darwin'</span>)&#123;</span><br><span class="line">shelljs.exec(<span class="string">`open <span class="subst">$&#123;buildFilePath&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(process.platform == <span class="string">'win32'</span>) &#123; <span class="comment">//windows</span></span><br><span class="line">shelljs.exec(<span class="string">`start <span class="subst">$&#123;buildFilePath&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'This platform is '</span> + process.platform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endTip(buildFilePath);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>打印结束语</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> endTip = <span class="function"><span class="params">buildFilePath</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"\n"</span> + <span class="string">"build file: "</span> + (path.resolve(buildFilePath)).magenta + <span class="string">"\n"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>教程代码：<a href="https://github.com/water-wheel/flash-cli" target="_blank" rel="noopener">https://github.com/water-wheel/flash-cli</a></li><li>至此，我们已经从步行阶段到了骑自行车阶段了</li></ul><h4 id="generator-flash的简单介绍"><a href="#generator-flash的简单介绍" class="headerlink" title="generator-flash的简单介绍"></a>generator-flash的简单介绍</h4><ul><li><p>下面我们先看下用yo开发出来的flash框架的效果</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/2017-11-06-15_11_57_ya.gif" width="800"></p><p>  <img src="http://oyoee89se.bkt.clouddn.com/2017-11-06-15_21_35_ya.gif" width="800"></p></li><li><p>flash github地址: <a href="https://github.com/water-wheel/generator-flash" target="_blank" rel="noopener">https://github.com/water-wheel/generator-flash</a></p></li></ul><h4 id="yeoman-generator的使用"><a href="#yeoman-generator的使用" class="headerlink" title="yeoman generator的使用"></a>yeoman generator的使用</h4><ul><li>yeoman: <a href="http://yeoman.io/" target="_blank" rel="noopener">http://yeoman.io/</a></li><li>yeoman是什么？    <ul><li>明河说 如果前端项目是工厂的产品的话，yeoman就像工厂的流水线，标准化、傻瓜化、批量化产品生产，生产过程乏味了，但效率提高了。</li><li>yeoman是定义了一套用于提高前端工程师效率规范的工作流工具</li></ul></li><li><p>yeoman的使用</p><ul><li><p>创建一个项目</p><ul><li><figure class="highlight plain"><figcaption><span>generator-generator``` 创建</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ```mkdir generator-flash &amp;&amp; cd generator-flash &amp;&amp; npm init</span><br></pre></td></tr></table></figure></li></ul></li><li><p>dependencies</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- package.json</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;generator-flash&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;generators&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;keywords&quot;: [&quot;yeoman-generator&quot;],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;yeoman-generator&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;generator-flash&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;app&quot;,</span><br><span class="line">    &quot;project&quot;,</span><br><span class="line">    &quot;component&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;keywords&quot;: [&quot;yeoman-generator&quot;],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;yeoman-generator&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持两种目录结构</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├───package.json</span><br><span class="line">└───generators/</span><br><span class="line"><span class="code">    ├───app/</span></span><br><span class="line"><span class="code">    │   └───index.js</span></span><br><span class="line"><span class="code">    └───router/</span></span><br><span class="line"><span class="code">        └───index.js</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        </span></span><br><span class="line">├───package.json</span><br><span class="line">├───app/</span><br><span class="line">│   └───index.js</span><br><span class="line">└───router/</span><br><span class="line"><span class="code">    └───index.js</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><figcaption><span>name```的使用 和 ```yo name:router```的使用 将直接唤起并运行 其下的index.js文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- 如果是第二种目录结构，则需要在package.json的files中添加多个app目录和router目录</span><br><span class="line">- yeoman规定files必须是数组形式</span><br><span class="line">- app/index.js</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const Generator = require(&apos;yeoman-generator&apos;);</span><br><span class="line">module.exports = class extends Generator &#123;</span><br><span class="line"></span><br><span class="line">method1() &#123;</span><br><span class="line">    this.log(&apos;method 1 just ran&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method2() &#123;</span><br><span class="line">    this.log(&apos;method 2 just ran&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line">- method 按照顺序执行 </span><br><span class="line">- Yeoman是按照优先级顺序依次执行所定义的方法。当你定义的函数名字是Yeoman定义的优先级函数名时，会自动将该函数列入到所在优先级队列中，否则就会列入到 default 优先层级队列中。</span><br><span class="line">- ```initializing、prompting、configuring 、default 、writing 、conflicts 、install 、end</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Prefix method name by an underscore  (e.g. _private_method).</p></li><li><p>异步流程控制</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">asyncTask() &#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</span><br><span class="line"></span><br><span class="line">  getUserEmail(<span class="function"><span class="keyword">function</span> (<span class="params">err, name</span>) </span>&#123;</span><br><span class="line">    done(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- The prompt module is provided by Inquirer.js</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">prompting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt([&#123;</span><br><span class="line">      type    : <span class="string">'input'</span>,</span><br><span class="line">      name    : <span class="string">'name'</span>,</span><br><span class="line">      message : <span class="string">'Your project name'</span>,</span><br><span class="line">      <span class="keyword">default</span> : <span class="keyword">this</span>.appname <span class="comment">// Default to current folder name</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type    : <span class="string">'confirm'</span>,</span><br><span class="line">      name    : <span class="string">'cool'</span>,</span><br><span class="line">      message : <span class="string">'Would you like to enable the Cool feature?'</span></span><br><span class="line">    &#125;]).then(<span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.log(<span class="string">'app name'</span>, answers.name);</span><br><span class="line">      <span class="keyword">this</span>.log(<span class="string">'cool feature'</span>, answers.cool);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>generator.composeWith()</p><ul><li><p>执行另一个generator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.composeWith(<span class="string">'name:route'</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自动安装依赖</p><ul><li>this.npmInstall</li><li>this.yarnInstall</li><li>this.bowerInstall</li><li>合并安装this.installDependencies({npm: false, bower: true, yarn: true})</li></ul></li><li>Template context<ul><li>this.sourceRoot() // returns ‘./templates’</li><li>this.templatePath(‘index.js’);// returns ‘./templates/index.js’</li></ul></li><li>copy template<ul><li>this.fs.copyTpl(src, output, data)</li><li>using ejs template syntax</li></ul></li></ul></li></ul><h3 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h3><ul><li>整体架构分析</li><li>模板工程的分类</li><li>generator-flash的执行流程</li><li>暴露尽可能少量的配置文件</li><li>扩展一般webpack配置的兼容性</li><li>为模板工程添加语法糖</li><li>数据mock功能的开发</li><li>组件中关于readme的统一化</li><li>黑科技</li></ul><h4 id="整体架构分析"><a href="#整体架构分析" class="headerlink" title="整体架构分析"></a>整体架构分析</h4><ul><li>团队目的<ul><li>解决复杂的且重复的问题，给团队带来效率提升</li><li>从团队leader的角度看：我们每个团队成员，应该尽快的去完成业务需求，而不是天天配置开发环境，如果有现成的代码可用，就不要重复造轮子，拿来即用就好。</li><li>我们的目的就是要那一堆零件过来，然后拼装成一辆汽车，而不需要了解零件的制作工艺</li></ul></li><li>剥离组件<ul><li>组件剥离项目是非常重要的一个事情，它使得项目依赖清晰，开发更快捷</li><li>代码解耦、可复用性强、维护方便单一</li><li>组件最好维护到公司的npm私服上，没有npm私服的建议组件名 加个前缀，发到npm上</li></ul></li><li>减少开发者的学习成本<ul><li>项目的配置项越少 对开发人员的上手成本就越低</li><li>把webpack的配置内敛至npm包中，仅留下几个路径配置项</li></ul></li><li><p>架构对比</p><ul><li><p>传统架构设计</p><p><img src="http://oyoee89se.bkt.clouddn.com/%E4%BC%A0%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" width="600"></p></li><li><p>新架构设计</p><p><img src="http://oyoee89se.bkt.clouddn.com/%E6%96%B0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" width="600"></p></li></ul></li></ul><h4 id="模板工程的分类"><a href="#模板工程的分类" class="headerlink" title="模板工程的分类"></a>模板工程的分类</h4><ul><li>根据前端框架分类<ul><li>React</li><li>Vue</li><li>JQuery</li></ul></li><li>根据功能拆分<ul><li>project</li><li>component</li><li>common</li></ul></li><li><p>根据使用的主要功能插件分</p><ul><li>react + router</li><li>react + router + redux</li><li>react + mobx + typescript</li></ul></li><li><p>究其结果，都是要进行模板文件的copy，只不过 根据用户的选择不同，copy的内容不同罢了<br>  <img src="http://oyoee89se.bkt.clouddn.com/A4C21ECA-C440-4BF7-9E24-96C85A8FA4E6.png" width="500"></p></li></ul><ul><li>下面先带大家过一遍 generator-flash 的执行流程，然后再从平时遇到的比较多的问题上开始看，一系列的影响效率的问题，然后去解决他们</li></ul><h4 id="generator-flash的执行流程"><a href="#generator-flash的执行流程" class="headerlink" title="generator-flash的执行流程"></a>generator-flash的执行流程</h4><ul><li>流程 (/app/index.js)<ul><li>检测当前脚手架版本 (/_libs/logo.js)<ul><li>打印欢迎语 </li></ul></li><li>选择创建工程类型 (project、component)</li><li>选择技术栈</li><li>项目名、描述、作者名、作者邮箱、gitlab group、version</li><li>react的项目 是否使用redux</li><li>是否自动安装依赖</li><li>根据用户选择 copy 模板工程 至 项目目录</li><li>安装依赖</li><li>打印结束语</li></ul></li></ul><h4 id="暴露尽可能少量的配置文件出来"><a href="#暴露尽可能少量的配置文件出来" class="headerlink" title="暴露尽可能少量的配置文件出来"></a>暴露尽可能少量的配置文件出来</h4><ul><li><p>问题：项目的webpack配置复杂，通常是有从入门到放弃一说的，可见它的复杂度之高，而暴露出来的配置项越多，开发者自己改动的可能性就越大，而脚手架就越不可控</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/FC73C83C-4C03-4927-B5E1-DFE8034E1EBC.png" width="500"></p></li><li><p>解决：</p><ul><li>webpack通用配置 和 个性化配置分离</li><li>版本锁定、依赖内敛至npm<ul><li>版本锁定：整个团队技术框架统一</li><li>依赖内敛：团队技术升级方便</li></ul></li></ul></li></ul><h4 id="扩展一般webpack配置的兼容性"><a href="#扩展一般webpack配置的兼容性" class="headerlink" title="扩展一般webpack配置的兼容性"></a>扩展一般webpack配置的兼容性</h4><ul><li>webpack 具体配置不细讲了哈，推荐给大家看一个webpack的视频课程：<a href="https://m.qlchat.com/live/channel/channelPage/2000000172777118.htm" target="_blank" rel="noopener">https://m.qlchat.com/live/channel/channelPage/2000000172777118.htm</a></li><li><p>问题：webpack在多页应用开发时候，会出现 entry 多入口路径的配置问题，相信很多前端同学，没有玩过webpack时候，或者对webpack一知半解时候，配置此多页面入口路径是相当麻烦的一件事儿</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/8510E9A8-467B-4FBB-B519-1C81A3B4523D.png" width="400"></p></li><li><p>我们自己的脚手架完全可以解决这个问题</p></li><li><p>解决：</p><ul><li>原理：按照定义的规范去写目录结构，在运行代码之前，先用node解析一遍，当前的路径，自动计算出当前的 entry map，完美解决</li><li><p>代码：<a href="https://github.com/water-wheel/flash-scripts/blob/master/config/paths.js#L26" target="_blank" rel="noopener">https://github.com/water-wheel/flash-scripts/blob/master/config/paths.js#L26</a></p><p>  <img src="http://oyoee89se.bkt.clouddn.com/3CCF5438-5270-4FA3-AD10-8947724E5C0C.png" width="500"></p></li></ul></li></ul><h4 id="为模板工程添加语法糖"><a href="#为模板工程添加语法糖" class="headerlink" title="为模板工程添加语法糖"></a>为模板工程添加语法糖</h4><ul><li>问题：在团队中，有多个业务线，每个业务线也都有多个项目，每个项目都会用到的功能，都需要开发人员开发一遍，或者从其他项目中copy一份出来，导致了业务代码乱七八糟，而且代码质量参差不一</li><li><p>解决：我们通过脚手架，为每个项目都内置一些工具方法，</p><ul><li><p>例如一些工具函数：获取url的参数、判断当前容器类型、监听页面回退、获取cookie值等</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/FEBD6976-6BAA-4FC8-B494-0EEE1B3769DA.png" width="500"></p></li><li><p>reset.css</p></li><li><p>scss mixin：兼容性flex方案、1像素线边框、单行（多行）文本截断、渐变、rem计算函数等</p><p>  <img src="http://oyoee89se.bkt.clouddn.com/BC456FB8-FCCA-4424-AB73-09AA6C293612.png" width="500"></p></li></ul></li><li><p>当然如果你们团队是hybrid开发时候，里面还可以内置一些 jsBridge 进去</p></li><li>flash脚手架的语法糖代码：<a href="https://github.com/water-wheel/generator-flash/tree/master/common" target="_blank" rel="noopener">https://github.com/water-wheel/generator-flash/tree/master/common</a></li></ul><h4 id="数据mock功能的开发"><a href="#数据mock功能的开发" class="headerlink" title="数据mock功能的开发"></a>数据mock功能的开发</h4><ul><li>问题：前后端分离的项目，后端接口开发缓慢，前端业务依赖后端接口数据，如若是写一个常量的数据来mock，则上线前 需要更换接口的url，需要前端开发重新进行自测，才能交付</li><li>解决：<ul><li>启一个本地服务来作为接口服务器</li><li>建一个mock文件夹 来放置 mock的接口数据，和mock的config配置(type: get | post | delay 等)</li><li>监听mock文件夹，如果有modify，则重启mock服务来更新接口数据</li></ul></li><li><p>具体解决方案：</p><ul><li><p>在npm start时候，我们fork一个进程，把mock server跑起来，然后监听mock文件夹，当mock文件夹发生修改时候，则重启这个进程</p><ul><li><p>代码地址：<a href="https://github.com/water-wheel/flash-scripts/blob/master/scripts/mock.js" target="_blank" rel="noopener">https://github.com/water-wheel/flash-scripts/blob/master/scripts/mock.js</a></p><p><img src="http://oyoee89se.bkt.clouddn.com/DE09069D-40E3-4444-A047-9C841F0B9BD6.png" width="500"></p></li></ul></li><li><p>mock接口服务 (读取本地mock文件的配置内容 和 配置列表，缓存起来，然后启动服务)</p><ul><li><p>代码展示：<a href="https://github.com/water-wheel/flash-scripts/blob/master/mock/worker.js" target="_blank" rel="noopener">https://github.com/water-wheel/flash-scripts/blob/master/mock/worker.js</a></p><p><img src="http://oyoee89se.bkt.clouddn.com/CA8B871C-A24C-43E5-B0E6-0F93117DF386.png" width="500"></p></li></ul></li></ul></li></ul><h4 id="组件中关于readme的统一化"><a href="#组件中关于readme的统一化" class="headerlink" title="组件中关于readme的统一化"></a>组件中关于readme的统一化</h4><ul><li>问题：即使有了脚手架 帮我们把组件的工程创建好，但我们还是经常遇到其他人开发的组件，我们无法快速使用的问题<ul><li>例如我们知道有loading这个组件，但是props的入参是什么，我们只能通过代码找到，有好一点儿的，作者在readme里面 写了loading的使用方式，但是可能下个dialog的组件 就在readme里面 以另一种风格去写dialog的组件使用了，这是一件很蛋疼的事儿</li></ul></li><li><p>解决方案：</p><ul><li>让readme风格 和 规范统一化</li><li>让使用者 在第一时间能找到 最简单的使用示例 和 配置参数，只需要copy过来就能用，不需要关心源码是怎么开发的，如果遇到问题，小窗下作者，立马能得到解决方法</li><li><p>我们readme的模板</p><p><img src="http://oyoee89se.bkt.clouddn.com/D4306A1C-0AF4-4FB2-BBE9-C4749C8AEC57.png" width="500"></p></li><li><p>示例：</p><ul><li><p>toast：<a href="https://github.com/water-wheel/toast" target="_blank" rel="noopener">https://github.com/water-wheel/toast</a></p><p>  <img src="http://oyoee89se.bkt.clouddn.com/417372B5-427E-4CDA-A1AD-7196FFC4FD9B.png" width="500"></p></li><li><p>loading：<a href="https://github.com/water-wheel/loading" target="_blank" rel="noopener">https://github.com/water-wheel/loading</a></p><p>  <img src="http://oyoee89se.bkt.clouddn.com/2DC84157-DA0E-46D8-8B56-06E9D4A91A6F.png" width="500"></p></li></ul></li></ul></li></ul><h4 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h4><ul><li><p>figlet 生成字符字 </p><ul><li><figure class="highlight plain"><figcaption><span>i figlet-cli -g```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ```figlet OK FLASH</span><br></pre></td></tr></table></figure></li></ul></li><li><p>tree 生成目录结构</p><ul><li><figure class="highlight plain"><figcaption><span>i tree-cli -g```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- ```tree</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/lyctea/learning-step&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录大纲&quot;&gt;&lt;a href=&quot;#目录大纲&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="脚手架" scheme="https://luoyec.cn/categories/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
    
      <category term="脚手架" scheme="https://luoyec.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
      <category term="分享" scheme="https://luoyec.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="工具" scheme="https://luoyec.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:Promise</title>
    <link href="https://luoyec.cn/2017/11/09/cl4e29qcw002h989eldjtvc43/"/>
    <id>https://luoyec.cn/2017/11/09/cl4e29qcw002h989eldjtvc43/</id>
    <published>2017-11-09T05:28:18.000Z</published>
    <updated>2017-11-09T05:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>调表达程序异步和管理并发的两个主要缺陷:缺乏顺序性 和可信任性。</p></blockquote><p>实际上，绝大多数 JavaScript/DOM 平台新增的异步 API 都是基于 Promise 构建的。</p><h1 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h1><p>从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成(组合)，而不 用关心时序或底层的结果。</p><h2 id="反控制反转"><a href="#反控制反转" class="headerlink" title="反控制反转"></a>反控制反转</h2><p>回调本身就表达了一种控制反转，所以对回调模式的反转实际就是对反转的反转。 所以反控制反转—-把控制返还给调用代码。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB" target="_blank" rel="noopener">维基百科：关注点分离</a></p><blockquote><p>关注点分离（Separation of concerns，SOC）是对只与“特定概念、目标”（关注点）相关联的软件组成部分进行“标识、封装和操纵”的能力，即标识、封装和操纵关注点的能力。是处理复杂性的一个原则。由于关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。<br>关注点分离是面向对象的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用（将针对特定领域问题代码抽象化成较少的程式码，例如将代码封装成function或是class），业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好的管理起来。</p></blockquote><h1 id="具有-then-方法的鸭子类型"><a href="#具有-then-方法的鸭子类型" class="headerlink" title="具有 then 方法的鸭子类型"></a>具有 then 方法的鸭子类型</h1><blockquote><p>根据一个值的形态(具有哪些属性)对这个值的类型做出一些假定。这种类型检查(type check)一般用术语鸭子类型(duck typing)来表示——“如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子”</p></blockquote><p>在 ES6 之前，社区已经有一些著名的非 Promise 库恰好有名为 then(..) 的方 法。这些库中有一部分选择了重命名自己的方法以避免冲突(这真糟糕!)。而其他的那 些库只是因为无法通过改变摆脱这种冲突，就很不幸地被降级进入了“与基于 Promise 的 编码不兼容”的状态。</p><h1 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h1><h2 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..) 构造器"></a>new Promise(..) 构造器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123; </span><br><span class="line"><span class="comment">// resolve(..)用于决议/完成这个promise</span></span><br><span class="line"><span class="comment">// reject(..)用于拒绝这个promise</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><h2 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then(..) 和 catch(..)"></a>then(..) 和 catch(..)</h2><p>then(..) 接受一个或两个参数:第一个用于完成回调，第二个用于拒绝回调。</p><p>个拒绝回调作为参数，并自动替换默认完成 回调。换句话说，它等价于 then(null,..):</p><h2 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all([ .. ]) 和 Promise.race([ .. ])"></a>Promise.all([ .. ]) 和 Promise.race([ .. ])</h2><p>对 Promise.all([ .. ]) 来说，只有传入的所有 promise 都完成，返回 promise 才能完成。 如果有任何 promise 被拒绝，返回的主 promise 就立即会被拒绝</p><p>对 Promise.race([ .. ]) 来说，只有第一个决议的 promise(完成或拒绝)取胜，并且其 决议结果成为返回 promise 的决议。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Promise 非常好，请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。</p><p>它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。</p><p>Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法，这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;调表达程序异步和管理并发的两个主要缺陷:缺乏顺序性 和可信任性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，绝大多数 JavaScript/DOM 平台新增的异步 API 都是基于 Promise 构建的。&lt;/p&gt;
&lt;h1 id=&quot;什么是P
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="Promise" scheme="https://luoyec.cn/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>2017-10-21表驱动法</title>
    <link href="https://luoyec.cn/2017/10/23/cl4e29qh200a9989ev7agwv9s/"/>
    <id>https://luoyec.cn/2017/10/23/cl4e29qh200a9989ev7agwv9s/</id>
    <published>2017-10-23T13:51:02.000Z</published>
    <updated>2017-11-09T17:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>表驱动法是一种编程模式(scheme)–从表里面查找信息而不使用逻辑语句（if和case），事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。</p></blockquote><h1 id="表驱动法使用总则"><a href="#表驱动法使用总则" class="headerlink" title="表驱动法使用总则"></a>表驱动法使用总则</h1><p>在适当的环境下，采用表驱动法，所生成的代码会比复杂的逻辑代码更简单、更容易修改，而且效率更高。</p><h2 id="使用表驱动法的两个问题"><a href="#使用表驱动法的两个问题" class="headerlink" title="使用表驱动法的两个问题"></a>使用表驱动法的两个问题</h2><ul><li>必须要回答的是怎样从表中查询条目的问题？（从表里查询记录的方法：直接访问、索引访问、阶梯访问）</li><li>你应该在表里存些什么？(数据或者动作)</li></ul><h1 id="直接访问表"><a href="#直接访问表" class="headerlink" title="直接访问表"></a>直接访问表</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508758356713.jpg" alt=""></p><ul><li>计算每个月中的天数，把每个月的天数存在一张表里</li><li>计算保险费率，费率随着年龄、性别、婚姻以及吸烟与否的不同情况而变化。使用逻辑控制结构，代码变得很复杂与繁琐<br>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508760643279.jpg" alt=""><br>  更好的做法是把这些费率存入所有因素索引的数组里<br>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508760709197.jpg" alt=""></li></ul><h2 id="灵活的消息格式"><a href="#灵活的消息格式" class="headerlink" title="灵活的消息格式"></a>灵活的消息格式</h2><p>在基于逻辑的方法中，其消息阅读子程序包含一个循环，用来读入消息、解释其ID，以及根据该ID调用20个子程序中的某一个。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508763048795.jpg" alt=""></p><p>采用面向对象的方法，那么问题的逻辑可言被隐藏在对象继承结构里，但是基本结构还是同样复杂。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508763108470.jpg" alt=""></p><p>采用表驱动法：<br>采用此方法，比前面两种都更经济，其中消息的阅读子程序由一个循环组成，该循环复杂读入每一个消息头，对其ID解码，在Message数组中查询其消息描述，然后每次调用同一个子程序来解释该消息。</p><h2 id="构造键值对"><a href="#构造键值对" class="headerlink" title="构造键值对"></a>构造键值对</h2><p>构造键值对的方法：</p><ul><li>复制信息从而能够直接使用键值</li></ul><ul><li>转换键值以使其能够直接使用：用一个函数将age转换成另一个数值</li></ul><ul><li>把键值转换提取成独立的子程序：如果必须构造一些数据来让它们像表键值一样使用，那么就把数据到键值的转换操作提取成独立的子程序。</li></ul><h1 id="索引访问表"><a href="#索引访问表" class="headerlink" title="索引访问表"></a>索引访问表</h1><p>当使用索引的时候，先用一个基本类型从一张索引表中查出一个键值，然后再利用这一键值查出感兴趣的主数据。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508766120913.jpg" alt=""></p><h1 id="阶梯访问表"><a href="#阶梯访问表" class="headerlink" title="阶梯访问表"></a>阶梯访问表</h1><p>阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508766253557.jpg" alt=""></p><p>举例，等级区间：<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1508766278126.jpg" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，那么问问自己是否通过一个差选表来加以简化</p></li><li><p>使用表的一项关键决策时决定如果去访问表。你可以采取直接访问、索引访问或者阶梯访问。</p></li><li><p>使用表达另一项关键决策时决定应该把什么内容放入表中。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;表驱动法是一种编程模式(scheme)–从表里面查找信息而不使用逻辑语句（if和case），事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;表驱动法使用总则&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="代码大全" scheme="https://luoyec.cn/categories/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
    
      <category term="表驱动发" scheme="https://luoyec.cn/tags/%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%8F%91/"/>
    
      <category term="查询表" scheme="https://luoyec.cn/tags/%E6%9F%A5%E8%AF%A2%E8%A1%A8/"/>
    
      <category term="索引访问" scheme="https://luoyec.cn/tags/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE/"/>
    
      <category term="阶梯访问" scheme="https://luoyec.cn/tags/%E9%98%B6%E6%A2%AF%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript回调</title>
    <link href="https://luoyec.cn/2017/10/13/cl4e29qd3002w989e2bapk5az/"/>
    <id>https://luoyec.cn/2017/10/13/cl4e29qd3002w989e2bapk5az/</id>
    <published>2017-10-13T12:19:25.000Z</published>
    <updated>2017-10-13T12:19:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序与异步"><a href="#顺序与异步" class="headerlink" title="顺序与异步"></a>顺序与异步</h1><blockquote><p>回调是编写和处理 JavaScript 程序异步逻辑的最常用 方式。确实，回调是这门语言中最基础的异步模式</p></blockquote><blockquote><p>所以，如果说同步的大脑计划能够很好地映射到同步代码语句，那么我们的大脑在规划异 步代码方面又是怎样的呢?<br>答案是代码(通过回调)表达异步的方式并不能很好地映射到同步的大脑计划行为。</p></blockquote><h2 id="嵌套回调与链式回调"><a href="#嵌套回调与链式回调" class="headerlink" title="嵌套回调与链式回调"></a>嵌套回调与链式回调</h2><p>一种典型的回调地狱：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">listen( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">         setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             ajax( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">handler(); &#125;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">                     request();</span><br><span class="line">&#125; &#125; );</span><br><span class="line">&#125;, <span class="number">500</span>) ; &#125; );</span><br></pre></td></tr></table></figure><p>复杂的回调，对于程序的调试和追踪代理来很高的复杂度。</p><p>这就是回调方式最主要的缺陷:对于它们在代码中表达异步的方式，我们的大脑 需要努力才能同步得上。</p><h2 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h2><p>也就是把自己程序一部分的执行控制交给某 个第三方。在你的代码和第三方工具(一组你希望有人维护的东西)之间有一份并没有明 确表达的契约。</p><p>利用代码的执行依赖于，ajax(..)返回的结果。</p><h1 id="省点回调"><a href="#省点回调" class="headerlink" title="省点回调"></a>省点回调</h1><p>为了更优雅地处理错误，有些 API 设计提供了分离回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( data );</span><br><span class="line">&#125;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">failure</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.error( err );</span><br><span class="line">     &#125;</span><br><span class="line">     ajax( <span class="string">"http://some.url.1"</span>, success, failure );</span><br></pre></td></tr></table></figure><p>S6 Promise API使用的就是这种分离回调设计。</p><p>还有一种常见的回调模式叫作“error-first 风格”（node风格），第一个参数保留用作错误对象，如果成功，这个参数会被清空或者置假（后面的参数就是成功数据）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">err,data</span>) </span>&#123; <span class="comment">// 出错?</span></span><br><span class="line">         <span class="keyword">if</span> (err) &#123;</span><br><span class="line">             <span class="built_in">console</span>.error( err );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则认为成功 else &#123;</span></span><br><span class="line">             <span class="built_in">console</span>.log( data );</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ajax( <span class="string">"http://some.url.1"</span>, response );</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流 程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码，会导致坏 bug。</p><p>第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。这种控制转移导 致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序与异步&quot;&gt;&lt;a href=&quot;#顺序与异步&quot; class=&quot;headerlink&quot; title=&quot;顺序与异步&quot;&gt;&lt;/a&gt;顺序与异步&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;回调是编写和处理 JavaScript 程序异步逻辑的最常用 方式。确实，回调是这门语言中
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="回调" scheme="https://luoyec.cn/tags/%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步：现在与未来</title>
    <link href="https://luoyec.cn/2017/10/13/cl4e29qd40030989ebreix4y5/"/>
    <id>https://luoyec.cn/2017/10/13/cl4e29qd40030989ebreix4y5/</id>
    <published>2017-10-13T11:46:32.000Z</published>
    <updated>2017-10-13T11:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。</p></blockquote><h1 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h1><p>在开发中，会把程序拆分成多个.js文件，这种拆分，意味着只有一个是现在执行的，其余的要等到将来才能执行。<br>考虑使用Ajax请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..)是某个库中提供的某个Ajax函数</span></span><br><span class="line">     <span class="keyword">var</span> data = ajax( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">     <span class="built_in">console</span>.log( data );</span><br><span class="line"><span class="comment">// 啊哦!data通常不会包含Ajax结果</span></span><br></pre></td></tr></table></figure><p>标准的Ajax请求不是同步完成的，意味着 ajax(..) 函数还没有返回 任何值可以赋给变量 data； 如果ajax(..)能够阻塞到响应返回，那么这种赋值是可以工作的。实际上并不是。</p><p>使用回调函数的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..)是某个库中提供的某个Ajax函数</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span> <span class="title">myCallbackFunction</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( data ); <span class="comment">// 耶!这里得到了一些数据! &#125; );</span></span><br></pre></td></tr></table></figure><h2 id="异步控制台"><a href="#异步控制台" class="headerlink" title="异步控制台"></a>异步控制台</h2><blockquote><p>尤其要提出的是，在某些条件下，某些浏览器的 console.log(..) 并不会把传入的内容立 即输出。出现这种情况的主要原因是，在许多程序(不只是 JavaScript)中，I/O 是非常低 速的阻塞部分。</p></blockquote><p>console.log 是异步的，最好的选择是在JavaScript调试器中使用断点，而不要依赖于控制台输出。次优的方案是把对象序列化到一个字符串中，以强 制执行一次“快照”，比如通过 JSON.stringify(..)</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><blockquote><p>JavaScript 引擎本身所做的只 不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块!!</p></blockquote><p>JavaScript进入了其他环境，比如nodejs， 在这些环境中都用一个共同的点（thread，线程）即它们都提供了一种机制来处理程序中多个块的执行，且执行每 块时调用 JavaScript 引擎，这种机制被称为事件循环。</p><p>简单代码模式事件循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventLoop是一个用作队列的数组 //(先进，先出)</span></span><br><span class="line"><span class="keyword">var</span> eventLoop = [ ];</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line"><span class="comment">//“永远”执行 while (true) &#123;</span></span><br><span class="line"><span class="comment">// 一次tick</span></span><br><span class="line"><span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 拿到队列中的下一个事件 event = eventLoop.shift();</span></span><br><span class="line"><span class="comment">// 现在，执行下一个事件 try &#123;</span></span><br><span class="line">event(); &#125;</span><br><span class="line">              <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                  reportError(err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的每一轮称为一个 tick。 对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这 些事件就是你的回调函数。</p><h1 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h1><blockquote><p>异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。</p></blockquote><blockquote><p>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行:在不同<br>的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。</p></blockquote><p>在程序中多线程的共享内容，同时访问同一块内容，会造成程序的中断和交错运行，可能得到出乎意料、不确定的行为。</p><p>在JavaScript中不允许跨线程共享数据，这意味着不需要考虑因为线程竞争内存引起的中断和交错行为。当不同的先后执行顺序（例如异步函数的执行先后顺序不同）也会导致结果的不同。</p><h2 id="完整运行"><a href="#完整运行" class="headerlink" title="完整运行"></a>完整运行</h2><p>举例说明什么是完整性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         a = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中提供的某个Ajax函数 ajax( "http://some.url.1", foo );</span></span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure><p>函数foo()开始执行后，它的所有代码都会在bar() 中的任意代码运行之前完成，或者相反。这被称为完整性运行（run-to-completion）特性</p><p>但是这不能消除全都的不确定性，依旧有两种可能的执行结果。</p><blockquote><p>但是，这种不确定性是在函数(事 件)顺序级别上，而不是多线程情况下的语句顺序级别(</p></blockquote><p>在 JavaScript 的特性中，这种函数顺序的不确定性就是通常所说的竞态条件(race condition)，foo() 和 bar() 相互竞争，看谁先运行。具体来说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><blockquote><p>这里的“进程”之所以打上引号，是因为这并不是计算机科学意义上的真正 操作系统级进程。这是虚拟进程，或者任务，表示一个逻辑上相关的运算序 列。</p></blockquote><h2 id="非交互"><a href="#非交互" class="headerlink" title="非交互"></a>非交互</h2><blockquote><p>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务 彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接 受的。</p></blockquote><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><blockquote><p>更常见的情况是，并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。正如前 面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。</p></blockquote><h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>还有一种并发合作方式，称为并发协作(cooperative concurrency)。这里的重点不再是通过 共享作用域中的值进行交互(尽管显然这也是允许的!)。这里的目标是取到一个长期运 行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己 的运算插入到事件循环队列中交替运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="comment">// response(..)从Ajax调用中取得结果数组 function response(data) &#123;</span></span><br><span class="line"><span class="comment">// 添加到已有的res数组 res = res.concat(</span></span><br><span class="line"><span class="comment">// 创建一个新的变换数组把所有data值加倍 data.map( function(val)&#123;</span></span><br><span class="line"><span class="keyword">return</span> val * <span class="number">2</span>; &#125;)</span><br><span class="line">); &#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中提供的某个Ajax函数 ajax( "http://some.url.1", response ); ajax( "http://some.url.2", response );</span></span><br></pre></td></tr></table></figure><p> 这里的问题在于如果返回的data数组很庞大，那么需要一段时间用于执行res数组写入操作，这过程中发生了阻塞。</p><p> 那么，可以创建一种协调性更友好且不会霸占时间循环队列的并发系统，这样可以异步处理这些结果，每次处理之后返回事件循环，让其他事件有机会进行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="comment">// response(..)从Ajax调用中取得结果数组 function response(data) &#123;</span></span><br><span class="line"><span class="comment">// 一次处理1000个</span></span><br><span class="line"><span class="keyword">var</span> chunk = data.splice( <span class="number">0</span>, <span class="number">1000</span> );</span><br><span class="line"><span class="comment">// 添加到已有的res组 res = res.concat(</span></span><br><span class="line"><span class="comment">// 创建一个新的数组把chunk中所有值加倍 chunk.map( function(val)&#123;</span></span><br><span class="line"><span class="keyword">return</span> val * <span class="number">2</span>; &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 还有剩下的需要处理吗? if (data.length &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">// 异步调度下一次批处理 setTimeout( function()&#123;</span></span><br><span class="line">                 response( data );</span><br><span class="line">             &#125;, <span class="number">0</span> );</span><br><span class="line">&#125; &#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中提供的某个Ajax函数 ajax( "http://some.url.1", response ); ajax( "http://some.url.2", response );</span></span><br></pre></td></tr></table></figure><p>我们把数据集合放在最多包含 1000 条项目的块中。这样，我们就确保了“进程”运行时 间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高 站点 /App 的响应(性能)。</p><blockquote><p>setTimeout(..0)：可以模拟异步调度，但并不直接把项目插入到事件循环队列。当有两个定时器为0时，并不能顺序处理。</p></blockquote><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><blockquote><p>在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列(job queue)。这个<br>概念给大家带来的最大影响可能是 Promise 的异步特性。</p></blockquote><blockquote><p>while 循环实现的持续运行的循环，循环的每一轮称为一个 tick。 对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这 些事件就是你的回调函数。</p></blockquote><p>任务队列的概念：</p><p>在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件 添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目(一个任务)。</p><blockquote><p>Promise 的异步特性是基于任务的</p></blockquote><h1 id="语句顺序"><a href="#语句顺序" class="headerlink" title="语句顺序"></a>语句顺序</h1><p>由于JavaScript引擎需要编译代码，所以语句的执行顺序并不总是按顺序的，在正常情况下，这种优化对于程序的执行并没有影响。</p><blockquote><p>编译器语句重排序几乎就是并发和交互的微型隐喻。</p></blockquote><p> 这可以理解为最小单元的异步执行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> 尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访 问，所以对状态的修改都是在之前累积的修改之上进行的。</p><p> 一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。</p><p>任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一 个或多个后续事件。</p><p>并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时 在运行(尽管在任意时刻只处理一个事件)。</p><p>通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块，以便其他“进程”插入进来。</p><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><p>在实际开发中，经常遇到数据重复改写的问题，这种状态的竞争往往很难预见，处理对业务逻辑的梳理之外，还需要对语言的底层有较好的理解。以便于修复一些难以解决的BUG。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;分块的程序&quot;&gt;&lt;a href=&quot;#分块的程序&quot; class=&quot;headerlink&quot; title=&quot;分块的程序&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="异步" scheme="https://luoyec.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 原生函数</title>
    <link href="https://luoyec.cn/2017/10/11/cl4e29qci001l989e9x6y7uy0/"/>
    <id>https://luoyec.cn/2017/10/11/cl4e29qci001l989e9x6y7uy0/</id>
    <published>2017-10-11T14:50:14.000Z</published>
    <updated>2017-10-11T14:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h1><p>常用的原生函数有：</p><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object()</li><li>Function()</li><li>RegExp()</li><li>Data()</li><li>Error()</li><li>Symbol()</li></ul><h2 id="封装对象"><a href="#封装对象" class="headerlink" title="封装对象"></a>封装对象</h2><p>通过构造函数（如 new String(‘abc’)）创建出来的是封装了的基本类型值（如 “abc”）的封装对象。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507731095158.jpg" alt=""></p><h1 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br><span class="line">    <span class="comment">// "[object Array]"</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> );</span><br><span class="line">    <span class="comment">// "[object RegExp]"</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Object</span>.prototype.toString.call( <span class="literal">null</span> );</span><br><span class="line">    <span class="comment">// "[object Null]"</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call( <span class="literal">undefined</span> );</span><br><span class="line">    <span class="comment">// "[object Undefined]"</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Object</span>.prototype.toString.call( <span class="string">"abc"</span> );</span><br><span class="line">    <span class="comment">// "[object String]"</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call( <span class="number">42</span> );</span><br><span class="line">    <span class="comment">// "[object Number]"</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call( <span class="literal">true</span> );</span><br><span class="line">    <span class="comment">// "[object Boolean]"</span></span><br></pre></td></tr></table></figure><h1 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h1><blockquote><p>一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什 么时候应该使用封装对象。换句话说，就是应该优先考虑使用 “abc” 和 42 这样的基本类型 值，而非new String(“abc”)和new Number(42)。</p></blockquote><p>如果想要自行封装基本类型值，可以使用 Object(..) 函数(不带 new 关键字):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"abc"</span>;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>( a );</span><br><span class="line">   <span class="keyword">var</span> c = <span class="built_in">Object</span>( a );</span><br><span class="line">   <span class="keyword">typeof</span> a; <span class="comment">// "string"</span></span><br><span class="line">   <span class="keyword">typeof</span> b; <span class="comment">// "object"</span></span><br><span class="line">   <span class="keyword">typeof</span> c; <span class="comment">// "object"</span></span><br><span class="line">   b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">   c <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">Object</span>.prototype.toString.call( b ); <span class="comment">// "[object String]"</span></span><br><span class="line">   <span class="built_in">Object</span>.prototype.toString.call( c ); <span class="comment">// "[object String]"</span></span><br></pre></td></tr></table></figure><h1 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h1><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"abc"</span> );</span><br><span class="line">   <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">42</span> );</span><br><span class="line">   <span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">true</span> );</span><br><span class="line">   a.valueOf(); <span class="comment">// "abc"</span></span><br><span class="line">   b.valueOf(); <span class="comment">// 42</span></span><br><span class="line">   c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol(..)"></a>Symbol(..)</h1><p>符号(Symbol)。符号是具有唯一性的特殊值(并 非绝对)，用它来命名对象属性不容易导致重名<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507732370374.jpg" alt=""></p><blockquote><p>符号并非对象，而是一种简单的标量基本类型。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。</p><p>对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实 现对这些属性和方法的访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原生函数&quot;&gt;&lt;a href=&quot;#原生函数&quot; class=&quot;headerlink&quot; title=&quot;原生函数&quot;&gt;&lt;/a&gt;原生函数&lt;/h1&gt;&lt;p&gt;常用的原生函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;Boo
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="封装" scheme="https://luoyec.cn/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="解封" scheme="https://luoyec.cn/tags/%E8%A7%A3%E5%B0%81/"/>
    
      <category term="原生函数" scheme="https://luoyec.cn/tags/%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 值</title>
    <link href="https://luoyec.cn/2017/10/11/cl4e29qd1002s989en8pnlsyw/"/>
    <id>https://luoyec.cn/2017/10/11/cl4e29qd1002s989en8pnlsyw/</id>
    <published>2017-10-11T05:17:29.000Z</published>
    <updated>2017-10-11T05:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>数组可以容纳任何类型的值，可以是字符串、 数字、对象(object)，甚至是其他数组(多维数组就是通过这种方式来实现的)</p></blockquote><blockquote><p>使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数 组的 length 属性并不会发生变化。</p></blockquote><p>可以通过下标对数组元素进行索引，但是同时，数组也是对象，所以可以通过点操作符以及[‘’]获取数组元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ ];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="string">"foobar"</span>] = <span class="number">2</span>;</span><br><span class="line">a.length;</span><br><span class="line">a[<span class="string">"foobar"</span>];</span><br><span class="line">a.foobar;</span><br></pre></td></tr></table></figure><p>需要注意的是，当使用[‘1’]数字字符串的性质，会被强制类型转换成十进制数字。</p><p>在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值， 用数组来存放数字索引值。</p><h1 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h1><p>有时需要将类数组(一组通过数字索引的值)转换为真正的数组，这一般通过数组工具函数(如 indexOf(..)、concat(..)、forEach(..) 等)来实现。</p><p>Array.from() 方法返回一个数组复本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'dsdgarg'</span>)</span><br><span class="line">(<span class="number">7</span>) [<span class="string">"d"</span>, <span class="string">"s"</span>, <span class="string">"d"</span>, <span class="string">"g"</span>, <span class="string">"a"</span>, <span class="string">"r"</span>, <span class="string">"g"</span>]</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">(<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在JavaScript中字符串与字符串数组不是一回事，尽管这两者很相似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"foo"</span>;</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">"f"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>]</span><br></pre></td></tr></table></figure><p>都有length属性以及indexOf()方法和concat(…) 方法</p><p>都可以通过b[1]获取元素， 但是低版本的IE中需要通过a. chartAt(1)方法获取指定下标的字符</p><p>一个有趣的事情，我们可以使用数组的方法来处理字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.join;         <span class="comment">// undefined</span></span><br><span class="line">     a.map;          <span class="comment">// undefined</span></span><br><span class="line">     <span class="keyword">var</span> c = <span class="built_in">Array</span>.prototype.join.call( a, <span class="string">"-"</span> );</span><br><span class="line">     <span class="keyword">var</span> d = <span class="built_in">Array</span>.prototype.map.call( a, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> v.toUpperCase() + <span class="string">"."</span>;</span><br><span class="line">     &#125; ).join( <span class="string">""</span> );</span><br><span class="line">     c;              <span class="comment">// "f-o-o"</span></span><br><span class="line">     d;              <span class="comment">// "F.O.O."</span></span><br></pre></td></tr></table></figure><p>字符串反转的例子，数组有一个方法reverse()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.reverse;</span><br><span class="line">b.reverse();</span><br><span class="line">b;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// ["!","o","O","f"]</span></span><br><span class="line"><span class="comment">// ["f","O","o","!"]</span></span><br></pre></td></tr></table></figure><p>一个变通(破解)的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = a</span><br><span class="line"><span class="comment">// 将a的值转换为字符数组 .split( "" )</span></span><br><span class="line"><span class="comment">// 将数组中的字符进行倒转 .reverse()</span></span><br><span class="line"><span class="comment">// 将数组中的字符拼接回字符串 .join( "" );</span></span><br><span class="line">c; <span class="comment">// "oof"</span></span><br></pre></td></tr></table></figure><p>这种方法的确简单粗暴，但对简单的字符串却完全适用。上述方法对于包含复杂字符(Unicode，如星号、多字节字符等)的 字符串并不适用。</p><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><blockquote><p>JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数</p></blockquote><p>指数格式显示，toExponential() 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5E10</span>;</span><br><span class="line">     a;                  <span class="comment">// 50000000000</span></span><br><span class="line">     a.toExponential();  <span class="comment">// "5e+10"</span></span><br><span class="line">     <span class="keyword">var</span> b = a * a;</span><br><span class="line">     b;                  <span class="comment">// 2.5e+21</span></span><br><span class="line">     <span class="keyword">var</span> c = <span class="number">1</span> / a;</span><br><span class="line">     c;                  <span class="comment">// 2e-11</span></span><br></pre></td></tr></table></figure><p>tofixed(..) 方法可指定小数部分的显示位数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line">     a.toFixed( <span class="number">0</span> ); <span class="comment">// "43"</span></span><br><span class="line">     a.toFixed( <span class="number">1</span> ); <span class="comment">// "42.6"</span></span><br><span class="line">     a.toFixed( <span class="number">2</span> ); <span class="comment">// "42.59"</span></span><br><span class="line">     a.toFixed( <span class="number">3</span> ); <span class="comment">// "42.590"</span></span><br><span class="line">     a.toFixed( <span class="number">4</span> ); <span class="comment">// "42.5900"</span></span><br></pre></td></tr></table></figure><p>toPrecision(..) 方法用来指定有效数位的显示位数::</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line">     a.toPrecision( <span class="number">1</span> ); <span class="comment">// "4e+1"</span></span><br><span class="line">     a.toPrecision( <span class="number">2</span> ); <span class="comment">// "43"</span></span><br><span class="line">     a.toPrecision( <span class="number">3</span> ); <span class="comment">// "42.6"</span></span><br><span class="line">     a.toPrecision( <span class="number">4</span> ); <span class="comment">// "42.59"</span></span><br><span class="line">     a.toPrecision( <span class="number">5</span> ); <span class="comment">// "42.590"</span></span><br><span class="line">     a.toPrecision( <span class="number">6</span> ); <span class="comment">// "42.5900"</span></span><br></pre></td></tr></table></figure><h2 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h2><p>0.1 + 0.2 === 0.3; // false</p><p>相加的结果是一个比较接近的数字<code>0.30000000000000004</code>，那么如何判断相加是相等的呢？</p><p>设置一个误差范围值：</p><p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (!<span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">         <span class="built_in">Number</span>.EPSILON = <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">-52</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Number.EPSILON 来比较两个数字是否相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersCloseEnoughToEqual</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">0.3</span>;</span><br><span class="line">     numbersCloseEnoughToEqual( a, b );</span><br><span class="line">     numbersCloseEnoughToEqual( <span class="number">0.0000001</span>, <span class="number">0.0000002</span> );  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="数的极限范围"><a href="#数的极限范围" class="headerlink" title="数的极限范围"></a>数的极限范围</h2><p> 1.798e+308    5e-324（不是负数，但无限接近0）</p><h2 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h2><p>能够被“安全”呈现的最大整数是 2^53 - 1，即 9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991，在 ES6 中被定义为 Number. MIN_SAFE_INTEGER。</p><h2 id="整数的检测"><a href="#整数的检测" class="headerlink" title="整数的检测"></a>整数的检测</h2><p>Number.isInteger(..)方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6之前</span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger) &#123;</span><br><span class="line">         <span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">"number"</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">         &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6语法</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> );     <span class="comment">// true</span></span><br><span class="line">     <span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span></span><br><span class="line">     <span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>检测一个值是否是安全的整数，number.isSafeInteger(..) 方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger) &#123;</span><br><span class="line">         <span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp;</span><br><span class="line">                 <span class="built_in">Math</span>.abs( num ) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );</span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) );</span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> );</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="一些特殊的值"><a href="#一些特殊的值" class="headerlink" title="一些特殊的值"></a>一些特殊的值</h2><ul><li><p>null：指的是空值，或者曾经赋值，但现在没有值，初始化时会赋值成null以便于和undefined区分</p></li><li><p>undefined：指的是没有值，从未赋值</p></li><li><p>void运算符：通过void运算符可以让表达式返回undefined</p></li><li><p>NaN：不是数字的数字，如果数学运算的操作数不是数字类型，就无法返回一个有效的数字，这种情况下返回值为NaN，推荐使用ES6中的Number.isNan(..)方法，以避免一些历史遗留的问题</p></li></ul><ul><li>-0+0: 转换让人迷惑，还是查文档吧</li></ul><h1 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h1><blockquote><p>引用就像一种特殊的指 针，是来指向变量的指针(别名)。如果参数不声明为引用的话，参数值总是通过值复制 的方式传递，即便对复杂的对象值也是如此。</p></blockquote><p>简单值(即标量基本类型值，scalar primitive)总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。</p><p>复合值(compound value)——对象(包括数组和封装对象，参见第3章)和函数，则总 是通过引用复制的方式来赋值 / 传递。</p><p>由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">     <span class="keyword">var</span> b = a;</span><br><span class="line">     a; <span class="comment">// [1,2,3]</span></span><br><span class="line">     b; <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="comment">// 然后</span></span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]; a; <span class="comment">// [1,2,3] b; // [4,5,6]</span></span><br></pre></td></tr></table></figure><p>引用指向的值本身，所以在函数参数传递的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">         x.push( <span class="number">4</span> );</span><br><span class="line">         x; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">// 然后</span></span><br><span class="line">x = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]; x.push( <span class="number">7</span> );</span><br><span class="line">x; <span class="comment">// [4,5,6,7]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">foo( a );</span><br><span class="line">a; <span class="comment">// 是[1,2,3,4]，不是[4,5,6,7]</span></span><br></pre></td></tr></table></figure><blockquote><p>我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。</p></blockquote><h2 id="值复制"><a href="#值复制" class="headerlink" title="值复制"></a>值复制</h2><p>如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个复本，这样传递的 就不再是原始值。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo( a.slice() );</span><br></pre></td></tr></table></figure><p>slice(..)不带参数会返回当前数组的一个浅副本，由于传递给函数的是指向该副本的引用，所以在函数中的操作不会影响到a指向的数组。</p><p>相反的，如果要将基本数据类型的值传递到函数内，并且修改之，就需要将该值封装套一个复合值（对象或者数组等）中，然后通过引用复制的方式传递</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之 前默认值都是 undefined。void 运算符返回 undefined。</p><p>数字类型有几个特殊值，包括 NaN(意指“not a number”，更确切地说是“invalid number”)、+Infinity、-Infinity 和 -0。</p><p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递，而复合值(对象等) 通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不 能指向别的变量 / 引用，只能指向值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;数组可以容纳任何类型的值，可以是字符串、 数字、对象(object)，甚至是其他数组(多维数组就是通过这种方式来实
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="类型" scheme="https://luoyec.cn/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类型</title>
    <link href="https://luoyec.cn/2017/10/10/cl4e29qd70036989eptk4xla7/"/>
    <id>https://luoyec.cn/2017/10/10/cl4e29qd70036989eptk4xla7/</id>
    <published>2017-10-10T05:27:27.000Z</published>
    <updated>2017-10-10T05:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><blockquote><p>要正确合理地进行类型转换(参见第 4 章)，我们必须掌握 JavaScript 中的各个类型及其内 在行为。几乎所有的 JavaScript 程序都会涉及某种形式的强制类型转换，处理这些情况时 我们需要有充分的把握和自信。</p></blockquote><h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>JavaScript 有七种内置类型（也称基本类型）:</p><p>• 空值(null)<br>• 未定义(undefined)<br>• 布尔值(boolean)<br>• 数字(number)<br>• 字符串(string)<br>• 对象(object)<br>• 符号(symbol，ES6中新增)</p><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507611639825.jpg" alt=""></p><p>需要注意的是，null类型比较特殊</p><p>typeof null === “object”; // true</p><p>所以需要复合条件来检测null值类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">'object'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还有一种情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>&#125; === <span class="string">'function'</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>function实际上是object的一个‘子类型’</p><p>函数不仅是对象，还可以拥有属性。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b,c</span>) </span>&#123;</span><br><span class="line">         <span class="comment">/* .. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数对象的 length 属性是其声明的参数的个数:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span>.<span class="built_in">length</span>;<span class="comment"> // 2</span></span><br></pre></td></tr></table></figure><p>因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2。</p><p>数组也是object的一个‘子类型’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] === <span class="string">"object"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h1><blockquote><p>JavaScript 不做“类型强制”;也就是说，语言引擎不要求变量总是 持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为 数字类型值。</p></blockquote><p>当变量未持有值的时候为undefined，此时typeof返回‘undefined’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><h2 id="undefined（声明未赋值）与undeclared（未声明）"><a href="#undefined（声明未赋值）与undeclared（未声明）" class="headerlink" title="undefined（声明未赋值）与undeclared（未声明）"></a>undefined（声明未赋值）与undeclared（未声明）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">    a; <span class="comment">// undefined</span></span><br><span class="line">    b; <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，typeof运算符对两种情况都一样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">    <span class="keyword">typeof</span> a; <span class="comment">// "undefined"</span></span><br><span class="line">    <span class="keyword">typeof</span> b; <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><h2 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h2><p>顶层的全局变量声明 var DEBUG = true 只在 debug.js 文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环 境中不予加载。</p><p>问题是如何在程序中检查全局变量 DEBUG 才不会出现 ReferenceError 错误。这时 typeof 的 安全防范机制就成了我们的好帮手:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Debugging is starting"</span> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样是安全的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> DEBUG !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Debugging is starting'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅对用户定义的变量有用，也对内建的API有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> atob === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">atob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用typeof运算符，也可以使用window全局对象，因为访问不存在的对象属性不会有ReferenceError错误。问题在于，全局对象并不总是window，例如在服务器端，node.js等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.DEBUG) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">window</span>.atob) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，typeof的安全防范机制为我们提供了更多选择</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript 有 七 种 内 置 类 型:null、undefined、boolean、number、string、object 和<br>symbol，可以使用 typeof 运算符来查看。 </p><p>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</p><p>很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。 undefined 是值的一种。undeclared 则表示变量还没有被声明过。遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined，并且typeof对undefined和undeclared变量都返回 “undefined”。</p><p>然而，通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量，有时是个不错的 办法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;要正确合理地进行类型转换(参见第 4 章)，我们必须掌握 JavaScript 中的各个类型及其内 在行为。几乎所
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="类型" scheme="https://luoyec.cn/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>行为委托</title>
    <link href="https://luoyec.cn/2017/10/08/cl4e29qh100a4989eeblrsjmo/"/>
    <id>https://luoyec.cn/2017/10/08/cl4e29qh100a4989eeblrsjmo/</id>
    <published>2017-10-08T07:10:13.000Z</published>
    <updated>2017-10-08T07:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[[Prototype]] 机制就是指对象中的一个内部链接引用 另一个对象。JavaScript 中这个机制的本质就是对象之间的关联关系</p></blockquote><h1 id="面向委托的设计模式"><a href="#面向委托的设计模式" class="headerlink" title="面向委托的设计模式"></a>面向委托的设计模式</h1><p>为了更好地学习如何更直观地使用 [[Prototype]]，我们必须认识到它代表的是一种不同<br>于类(参见第 4 章)的设计模式。</p><h2 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h2><p>类设计模式鼓励你在继承时使用方法重写(和多态)</p><h2 id="委托理论"><a href="#委托理论" class="headerlink" title="委托理论"></a>委托理论</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Task = &#123;</span><br><span class="line">setID: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = ID</span><br><span class="line">&#125;,</span><br><span class="line">outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让XYZ委托Task</span></span><br><span class="line">XYZ = <span class="built_in">Object</span>.create(Task)</span><br><span class="line">XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID, Label</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.setID(ID)</span><br><span class="line"><span class="keyword">this</span>.lable = Label</span><br><span class="line">&#125;</span><br><span class="line">XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.outputID()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.lable)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XYZ.prepareTask(<span class="number">1222</span>, <span class="string">'hh'</span>)</span><br><span class="line">XYZ.outputTaskDetails()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1222</span></span><br><span class="line"><span class="comment"> * hh</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>将XYZ委托给Task， 当XYZ对象执行setID方式时，该对象本身并没有该方法，会沿着原型链查找到Task对象上，</p><p>this.id = ID其实是隐式绑定。当前的this绑定这XYZ并不是Task</p><p>打印XYZ与Task对象的属性，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">prepareTask</span>: [<span class="built_in">Function</span>],</span><br><span class="line">  outputTaskDetails: [<span class="built_in">Function</span>],</span><br><span class="line">  id: <span class="number">1222</span>,</span><br><span class="line">  lable: <span class="string">'hh'</span> &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#123; <span class="attr">setID</span>: [<span class="built_in">Function</span>: setID], <span class="attr">outputID</span>: [<span class="built_in">Function</span>: outputID] &#125;</span><br></pre></td></tr></table></figure><blockquote><p>委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一<br>个对象(Task)。</p></blockquote><p>这种设计模式需要注意的几个问题：</p><ul><li><p>委托中最好把状态保存在委托者(XYZ、ABC)而不是委托目标(Task)上。如上例子中，id与label都属于对象XYZ</p></li><li><p>进行避免在不同级别中使用相同的方法或属性命名，提倡更有描述性的方法名，尤其是要写清相应对象行为的类型。</p></li><li><p>使用this的隐式绑定，将需要的属性绑定到委托者身上，尤其是对于一些私有的数据属性，这并不需要保存在委托目标上。</p></li></ul><h2 id="互相委托（禁止）"><a href="#互相委托（禁止）" class="headerlink" title="互相委托（禁止）"></a>互相委托（禁止）</h2><p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。</p><p>之所以要禁止互相委托，是因为引擎的开发者们发现在设置时检查(并禁止!)一次无限 循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查。</p><h2 id="比较思维模型"><a href="#比较思维模型" class="headerlink" title="比较思维模型"></a>比较思维模型</h2><p>对比JavaScript中面向对象与对象关联两种设计模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123; <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123; Foo.call( <span class="keyword">this</span>, who );</span><br><span class="line">     &#125;</span><br><span class="line">     Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar( <span class="string">"b2"</span> ); b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><p>子类 Bar 继承了父类 Foo，然后生成了 b1 和 b2 两个实例。b1 委托了 Bar.prototype，后者<br>委托了 Foo.prototype。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.me = who; &#125;,</span><br><span class="line">identify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125; &#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create( Foo );</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b1.init( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line"></span><br><span class="line">b2.init( <span class="string">"b2"</span> );</span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure><h3 id="对象关联风格代码的思维模型"><a href="#对象关联风格代码的思维模型" class="headerlink" title="对象关联风格代码的思维模型"></a>对象关联风格代码的思维模型</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507445889858.jpg" alt=""></p><blockquote><p>对象之间的关联关系。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章)，也可以拥抱更自然的 [[Prototype]] 委托机制。</p><p>当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 </p><p>对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把<br>它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[[Prototype]] 机制就是指对象中的一个内部链接引用 另一个对象。JavaScript 中这个机制的本质就是对象之间的关联关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;面向委托的设计模式&quot;&gt;&lt;a href=&quot;#面向委托的设计模
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="原型链" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="委托" scheme="https://luoyec.cn/tags/%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="https://luoyec.cn/2017/10/08/cl4e29qg0008e989e5fgarnjt/"/>
    <id>https://luoyec.cn/2017/10/08/cl4e29qg0008e989e5fgarnjt/</id>
    <published>2017-10-08T06:04:27.000Z</published>
    <updated>2017-10-08T06:04:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><blockquote><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引<br>用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p></blockquote><blockquote><p>使用for…in…，会查找对象的整条原型链。因此，当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者<br>查找完整条原型链。</p></blockquote><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。</p><h2 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h2><p>在于原型链上层时myObject.foo = “bar”会出现的三种情况。</p><ul><li>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。</li></ul><ul><li>如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li></ul><ul><li>如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。</li></ul><p>有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123; <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">     anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">     myObject.a; <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">anotherObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></span><br><span class="line">     myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">myObject.a++; <span class="comment">// 隐式屏蔽! anotherObject.a; // 2</span></span><br><span class="line">     myObject.a; <span class="comment">// 3</span></span><br><span class="line">     myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]] 查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a</p><h1 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h1><blockquote><p>JavaScript 和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。<br>实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。</p></blockquote><blockquote><p>JavaScript 会在两 个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 委托</p></blockquote><h2 id="构造函数”"><a href="#构造函数”" class="headerlink" title="构造函数”"></a>构造函数”</h2><p>使用 new 调用时，它就会构造一个对象并赋值 给 a，这看起来像是 new 的一个副作用(无论如何都会构造一个对象)。这个调用是一个构 造函数调用，但是 NothingSpecial 本身并不是一个构造函数。</p><p>换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><h2 id="回顾“构造函数”"><a href="#回顾“构造函数”" class="headerlink" title="回顾“构造函数”"></a>回顾“构造函数”</h2><p>一些随意的对象属性引用，比如 a1.constructor，实际上是不被信任的，它们不一 定会指向默认的函数引用。此外，很快我们就会看到，稍不留神 a1.constructor 就可能会 指向你意想不到的地方。</p><p>a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部<br>[[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。</p><p>所有普通对象都有内置的 Object.prototype，指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。</p><p>关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。<br>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。</p><p>虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但 是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prototype&quot;&gt;&lt;a href=&quot;#Prototype&quot; class=&quot;headerlink&quot; title=&quot;Prototype&quot;&gt;&lt;/a&gt;Prototype&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript 中的对象有一个特殊的 [[Proto
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="原型" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>混合对象“类”</title>
    <link href="https://luoyec.cn/2017/10/06/cl4e29qgo009g989e7na6nrnr/"/>
    <id>https://luoyec.cn/2017/10/06/cl4e29qgo009g989e7na6nrnr/</id>
    <published>2017-10-06T15:50:15.000Z</published>
    <updated>2017-10-06T15:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍面向类的设计模式:实例化(instantiation)、继承(inheritance)和 (相对)多态(polymorphism)。</p><h1 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h1><p>类 / 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模<br>方法。</p><h2 id="“类”设计模式"><a href="#“类”设计模式" class="headerlink" title="“类”设计模式"></a>“类”设计模式</h2><p>类并不是必须的编程基础，而是一种可选 的代码抽象。</p><p>JavaScript 提供了一些近似类的语法。</p><p>总结一下，在软件设计中类是一种可选的模式，你需要自己决定是否在 JavaScript 中使用 它。</p><h2 id="类的机制"><a href="#类的机制" class="headerlink" title="类的机制"></a>类的机制</h2><ul><li><p>构造：类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这<br>个方法的任务就是初始化实例需要的所有信息(状态)。</p></li><li><p>类的继承：同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会 包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p></li><li><p>多态：</p><ul><li>任何方法都<br>可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。</li><li>另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。</li></ul></li><li><p>多重继承：有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制 到子类中。</p></li><li><p>混入：一个对象并不会被复制到其他对 象，它们会被关联起来。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来 模拟类的复制行为，这个方法就是混入。</p></li></ul><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>JavaScript 开发者也想出了一个方法来 模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入:显式和隐式。</p><h3 id="显式混入"><a href="#显式混入" class="headerlink" title="显式混入"></a>显式混入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常简单的 mixin(..) 例子 :</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params"> sourceObj, targetObj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj) &#123;</span><br><span class="line"><span class="comment">// 只会在不存在的情况下复制 if (!(key in targetObj)) &#123;</span></span><br><span class="line">                 targetObj[key] = sourceObj[key];</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> targetObj; &#125;</span><br><span class="line"><span class="keyword">var</span> Vehicle = &#123; <span class="attr">engines</span>: <span class="number">1</span>,</span><br><span class="line">         ignition: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log( <span class="string">"Turning on my engine."</span> );</span><br><span class="line">&#125;,</span><br><span class="line">drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.ignition();</span><br><span class="line">             <span class="built_in">console</span>.log( <span class="string">"Steering and moving forward!"</span> );</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Car = mixin( Vehicle, &#123; <span class="attr">wheels</span>: <span class="number">4</span>,</span><br><span class="line">drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; Vehicle.drive.call( <span class="keyword">this</span> ); <span class="built_in">console</span>.log(</span><br><span class="line">                <span class="string">"Rolling on all "</span> + <span class="keyword">this</span>.wheels + <span class="string">" wheels!"</span></span><br><span class="line">             );</span><br><span class="line">&#125; &#125; );</span><br></pre></td></tr></table></figure><p>函数实际上没有 被复制，复制的是函数引用</p><h2 id="混合复制"><a href="#混合复制" class="headerlink" title="混合复制"></a>混合复制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一种混入函数，可能有重写风险 function mixin( sourceObj, targetObj ) &#123;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sourceObj) &#123; targetObj[key] = sourceObj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> targetObj; &#125;</span><br><span class="line"><span class="keyword">var</span> Vehicle = &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 首先创建一个空对象并把 Vehicle 的内容复制进去</span></span><br><span class="line"><span class="keyword">var</span> Car = mixin( Vehicle, &#123; &#125; );</span><br><span class="line"><span class="comment">// 然后把新内容复制到 Car 中 mixin( &#123;</span></span><br><span class="line">wheels: <span class="number">4</span>,</span><br><span class="line">drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, Car );</span><br></pre></td></tr></table></figure><h2 id="隐式混入"><a href="#隐式混入" class="headerlink" title="隐式混入"></a>隐式混入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Something = &#123; <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.greeting = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">this</span>.count = <span class="keyword">this</span>.count ? <span class="keyword">this</span>.count + <span class="number">1</span> : <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Something.cool();</span><br><span class="line">     Something.greeting; <span class="comment">// "Hello World"</span></span><br><span class="line">     Something.count; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> Another = &#123;</span><br><span class="line">cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 隐式把 Something 混入 Another</span></span><br><span class="line">Something.cool.call( <span class="keyword">this</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Another.cool();</span><br><span class="line">Another.greeting; <span class="comment">// "Hello World" Another.count; // 1(count不是共享状态)</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态(OtherObj.methodName.call(this, …))，这会让代码更加难 懂并且难以维护。</p><p>总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋 下更多的隐患。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍面向类的设计模式:实例化(instantiation)、继承(inheritance)和 (相对)多态(polymorphism)。&lt;/p&gt;
&lt;h1 id=&quot;类理论&quot;&gt;&lt;a href=&quot;#类理论&quot; class=&quot;headerlink&quot; title=&quot;类理论&quot;&gt;&lt;/a&gt;类
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="https://luoyec.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>关于this</title>
    <link href="https://luoyec.cn/2017/10/06/cl4e29qfn007r989e8byxw0p8/"/>
    <id>https://luoyec.cn/2017/10/06/cl4e29qfn007r989e8byxw0p8/</id>
    <published>2017-10-06T15:24:44.000Z</published>
    <updated>2017-10-06T15:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><blockquote><p>任何足够先进技术和魔法无异</p></blockquote><p>实际上，JavaScript中this的机制并没有那么先进，但是开发者往往把理解过程复杂化，毫无疑问，在缺乏清晰认识的情况下，this对你来说完全是一种魔法。</p><h2 id="为什么要用到this："><a href="#为什么要用到this：" class="headerlink" title="为什么要用到this："></a>为什么要用到this：</h2><p>如果不使用this，那就需要给函数传入一个上下文对象，而this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以让API设计得更加简洁易于复用。</p><h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>太拘泥于“this”的字面意思就会产生一些误解。有两种常见的对于 this 的解释，但是它 们都是错误的。</p><p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被 这样的解释误导过，但其实它们都是错误的。<br>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h1 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h1><p>每个函数的 this 是在调用 时被绑定的，完全取决于函数的调用位置(也就是函数的调用方法)。</p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><blockquote><p>调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。</p></blockquote><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数调用时应用了 this 的默认绑定，因此 this 指向全局对象，注意在严格模式下，全局对象无法使用默认绑定，因此this会绑定到undefined</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">foo: foo &#125;;</span><br><span class="line">     obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默<br>认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">foo: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a是全局对象的属性 bar(); // "oops, global"</span></span><br></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>使用函数的 call(..) 和 apply(..) 方法</p><p>这两个方法是如何工作的呢?它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">     &#125;;</span><br><span class="line">     foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>装箱：如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。</p></blockquote><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line">     bar(); <span class="comment">// 2</span></span><br><span class="line">     setTimeout( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2</span></span><br></pre></td></tr></table></figure><p> Function.prototype. bind：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123; <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something ); <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">this</span>全面解析 | <span class="number">89</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3 console.log( b ); // 5</span></span><br></pre></td></tr></table></figure><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ul><li>创建(或者说构造)一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的this。</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>); <span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><h2 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h2><ol><li><p>函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。<br>  var bar = new foo()</p></li><li><p>函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。<br>  var bar = foo.call(obj2)</p></li><li><p>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this绑定的是那个上 下文对象。<br>  var bar = obj1.foo()</p></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。<br>  var bar = foo()</p></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><p>由new调用?绑定到新创建的对象。</p></li><li><p>由call或者apply(或者bind)调用?绑定到指定的对象。</p></li></ol><ol start="3"><li>由上下文对象调用?绑定到那个上下文对象。</li></ol><ol start="4"><li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和ES6之前代码中的self = this机制一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于this&quot;&gt;&lt;a href=&quot;#关于this&quot; class=&quot;headerlink&quot; title=&quot;关于this&quot;&gt;&lt;/a&gt;关于this&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;任何足够先进技术和魔法无异&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，Ja
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="https://luoyec.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>作用域闭包</title>
    <link href="https://luoyec.cn/2017/10/04/cl4e29qfk007m989elzyi9sma/"/>
    <id>https://luoyec.cn/2017/10/04/cl4e29qfk007m989elzyi9sma/</id>
    <published>2017-10-04T03:16:16.000Z</published>
    <updated>2017-10-06T15:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>魔术师的幕后藏着一个人，我们将要揭开他的伪装</p></blockquote><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><blockquote><p>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</p></blockquote><p>闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。</p><h1 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h1><p>一个闭包的直接定义，当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使喊你数是在当前词法作用域之外执行</p><p>以下的例子是闭包吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这是闭包吗?<br>技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却 是非常重要的一部分!)</p><p>以下代码清晰展示了闭包:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a  = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar baz = foo()</span><br><span class="line"></span><br><span class="line">baz()  <span class="comment">//2  ,这就是闭包的效果</span></span><br></pre></td></tr></table></figure><p>函数bar（）的词法作用域能够访问foo（）的内部作用域，然后将bar（）函数本身当做一个值类型来进行传递。<br>在这个例子中，bar（）函数在自己定义的词法作用域以外的地方执行。</p><p>闭包阻止了foo（）的内存回收</p><p>引申出来的一点，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    barz(bar)</span><br><span class="line">&#125;)()<span class="comment">//立即执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">barz</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo() 内部<br>作用域的闭包就可以观察到了，因为它能够访问 a。</p><p>也可以是间接的传递函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn = baz<span class="comment">//将baz分配给全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">fn()<span class="comment">//闭包</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行 这个函数都会使用闭包。</p><h2 id="闭包小结"><a href="#闭包小结" class="headerlink" title="闭包小结"></a>闭包小结</h2><p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!</p><h1 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507082188486.jpg" alt=""></p><p>输出结果为5次6，延迟函数会在循环结束时才执行，即使将延时时间设为0，也会等待循环结束之后才执行。它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。</p><p>  以下方法是否可行？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( i );</span><br><span class="line">             &#125;, i*<span class="number">1000</span> );</span><br><span class="line">         &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是输出5次6，这个IIFE只是一个什么都没有的空作用域，需要包含一点实质性内容才能为我们所用，它需要有自己的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> j = i;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                 <span class="built_in">console</span>.log( j );</span><br><span class="line">             &#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)(); &#125;</span><br></pre></td></tr></table></figure><p>ok，再对IIFE进行改进！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( j );</span><br><span class="line">             &#125;, j*<span class="number">1000</span> );</span><br><span class="line">         &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的<br>作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><h1 id="重返块作用域"><a href="#重返块作用域" class="headerlink" title="重返块作用域"></a>重返块作用域</h1><p>仔细思考我们对前面的解决方案，我们使用IIFe在每次迭代时都创建了一个新的作用域，换句话说，每次迭代我们都需要一个块作用域。 使用let，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。</p><blockquote><p>本质上这是将一个块转换成一个可以被关闭的作用域</p></blockquote><p>因此，上面的循环闭包可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域! setTimeout( function timer() &#123;</span></span><br><span class="line">             <span class="built_in">console</span>.log( j );</span><br><span class="line">         &#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。因此可以改写成:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log( i );</span><br><span class="line">         &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>一个模块的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">    <span class="keyword">var</span> anoter = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnohter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(anoter.join(<span class="string">' ! '</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnohter: doAnohter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModult()</span><br><span class="line"></span><br><span class="line">foo.doSomething()</span><br><span class="line">foo.doAnohter()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cool</span></span><br><span class="line"><span class="comment">1 ! 2 ! 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行 外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。</p><p>引申出来的，模块模式需要具备两个必要条件：</p><ul><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）</li><li>封闭函数必须返回至少一个内部函数，这样的内部函数才能在私有作用于中形成闭包，并且可以访问或者修改私有状态</li></ul><h2 id="改写为单例模式"><a href="#改写为单例模式" class="headerlink" title="改写为单例模式"></a>改写为单例模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">    <span class="keyword">var</span> anoter = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnohter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(anoter.join(<span class="string">' ! '</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnohter: doAnohter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo.doSomething()</span><br><span class="line">foo.doAnohter()</span><br></pre></td></tr></table></figure><p>将模块函数转换成了 IIFE(参见第 3 章)，立即调用这个函数并将返回值直接赋值给 单例的模块实例标识符 foo。</p><h2 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> modules = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">deps[i] = modules[deps[i]]</span><br><span class="line">&#125;</span><br><span class="line">modules[name] = impl.apply(impl, deps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> modules[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">define: define,</span><br><span class="line">get: get</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">MyModules.define(<span class="string">'bar'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Let me introduce: '</span> + who</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyModules.define(<span class="string">'foo'</span>, [<span class="string">'bar'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">'hippo'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = MyModules.get(<span class="string">'bar'</span>)</span><br><span class="line"><span class="keyword">var</span> foo = MyModules.get(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    bar.hello(<span class="string">'hippo'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">foo.awesome()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Let me introduce: hippo</span></span><br><span class="line"><span class="comment"> * LET ME INTRODUCE: HIPPO</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这段代码的核心是modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装 函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管 理的模块列表中。</p><h2 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bar.js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> hello; foo.js</span><br><span class="line"><span class="comment">// 仅从 "bar" 模块导入 hello() import hello from "bar";</span></span><br><span class="line"><span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(</span><br><span class="line">             hello( hungry ).toUpperCase()</span><br><span class="line">         );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> awesome;</span><br><span class="line">baz.js</span><br><span class="line"><span class="comment">// 导入完整的 "foo" 和 "bar" 模块 56 | 第 5 章</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">"foo"</span>;</span><br><span class="line">     <span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(</span><br><span class="line">         bar.hello( <span class="string">"rhino"</span> )</span><br><span class="line">     ); <span class="comment">// Let me introduce: rhino</span></span><br><span class="line">     foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。</p><p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭 包模块一样。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。</p></blockquote><p>模块有两个主要特征:</p><ul><li>为创建内部作用域而调用了一个包装函数;</li><li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭 包。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;魔术师的幕后藏着一个人，我们将要揭开他的伪装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;启示&quot;&gt;&lt;a href=&quot;#启示&quot; class=&quot;headerlink&quot; title=&quot;启示&quot;&gt;&lt;/a&gt;启示&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="https://luoyec.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>提升</title>
    <link href="https://luoyec.cn/2017/10/03/cl4e29qgd008y989ebeh5y9o1/"/>
    <id>https://luoyec.cn/2017/10/03/cl4e29qgd008y989ebeh5y9o1/</id>
    <published>2017-10-03T07:25:48.000Z</published>
    <updated>2017-10-06T15:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面的章节，详细讨论了作用域的概念，以及根据声明的位置和方式将变量分配给 作用域的相关原理。函数作用域和块作用域的行为是一样的，可以总结为:任何声明在 某个作用域内的变量，都将附属于这个作用域。</p><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。<br>当你看到var a = 2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个 声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。</p><p> 我们的第一个代码片段会以如下形式进行处理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">2</span>; <span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p> 其中第一部分是编译，而第二部分是执行。<br> 类似地，我们的第二个代码片段实际是按照以下流程处理的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="built_in">console</span>.log( a ); </span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变<br>  了代码执行的顺序，会造成非常严重的破坏。</p></blockquote><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined var a = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo函数的声明被提升了，因此该函数可以被执行。<br>因此这段代码实际上会被理解为下 面的形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> a;</span><br><span class="line">         <span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>; &#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>可以看到，函数声明会被提升，但是函数表达式却不会被提升。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为此时foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。</p><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中提升使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      foo(); <span class="comment">// TypeError</span></span><br><span class="line">      bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 这个代码片段经过提升后，实际上会被理解为以下形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">      bar(); <span class="comment">// ReferenceError</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bar = ...self... <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h1><p>函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个<br>“重复”声明的代码中)是函数会首先被提升，然后才是变量。</p><p>考虑以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo()  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// "b"</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>; <span class="keyword">if</span> (a) &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"a"</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"b"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。 (判断语句并不具有作用域)</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a<br>和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。</p><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引<br>起很多危险的问题!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面的章节，详细讨论了作用域的概念，以及根据声明的位置和方式将变量分配给 作用域的相关原理。函数作用域和块作用域的行为是一样的，可以总结为:任何声明在 某个作用域内的变量，都将附属于这个作用域。&lt;/p&gt;
&lt;h1 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="提升" scheme="https://luoyec.cn/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>谈项目中如何选择框架和库</title>
    <link href="https://luoyec.cn/2017/10/03/cl4e29qh500ad989e3ckyah6g/"/>
    <id>https://luoyec.cn/2017/10/03/cl4e29qh500ad989e3ckyah6g/</id>
    <published>2017-10-03T06:43:25.000Z</published>
    <updated>2017-10-03T06:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227070&amp;idx=1&amp;sn=b2a7f923ed0432d97cc9b2951bb940d7&amp;chksm=bd495a3a8a3ed32cf36eed0bd8841d926bebad838653e7aceb6cb4f31d54f676fbe93615440a&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">谈项目中如何选择框架和库</a></p><p>概要：<br>我们在项目开发中，根据项目的不同的情况，我们在做技术选型的时候会有所不同，当然我们在框架和库方面也会有所不同，哪具体如何选择呢？克军将和大家谈一谈项目中如何选择框架和库。</p><h1 id="基本的前提：成本与效率"><a href="#基本的前提：成本与效率" class="headerlink" title="基本的前提：成本与效率"></a>基本的前提：成本与效率</h1><ul><li>实现目标的成本和效率<ul><li>用第三方库以及自己造轮子？</li><li>良好的架构设计比代码更重要</li></ul></li><li><p>团队协作的成本和效率</p><ul><li>不能被团队接收的方案不是好方案？</li></ul></li><li><p>后续迭代的成本和效率</p><ul><li>兼顾可维护性以及可迭代性的架构设计，这意味着在项目之初需要花掉时间成本</li></ul></li></ul><h1 id="轮子的选择"><a href="#轮子的选择" class="headerlink" title="轮子的选择"></a>轮子的选择</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507011312623.jpg" alt=""></p><p>对于需要用轮子的人和造轮子的人，都需要关注的问题是，这个轮子解决的问题是什么，痛点是什么。在项目中，最大的瓶颈在哪？轮子对于项目是否匹配。</p><h1 id="各种维度的比较"><a href="#各种维度的比较" class="headerlink" title="各种维度的比较"></a>各种维度的比较</h1><p>  模式、体量、性能、前景、普及率、局限性、活跃性、契合度、成熟度、学习成本、周边资源、文档质量</p><p>  在不同特点的项目中，权重是不一样的。</p><h1 id="选择的原则"><a href="#选择的原则" class="headerlink" title="选择的原则"></a>选择的原则</h1><h2 id="妥适性在原则"><a href="#妥适性在原则" class="headerlink" title="妥适性在原则"></a>妥适性在原则</h2><p>  避免过度实践，引入了暂时用不到的技术</p><h2 id="库的选择"><a href="#库的选择" class="headerlink" title="库的选择"></a>库的选择</h2><ul><li>缩小依赖范围和稳定方向依赖</li><li>避重趋轻、避繁逐简、以简获繁、避虚就实</li><li>可替代性</li></ul><h2 id="主框架的选择"><a href="#主框架的选择" class="headerlink" title="主框架的选择"></a>主框架的选择</h2><ul><li>没有不二法则</li><li>拥抱未来</li><li>经验价值高</li><li>架构的优势为重</li></ul><p>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507012471964.jpg" alt=""></p><h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p>软件熵，软件在经过各种修改之后，无序程度会上升。在前期，首先在选择的过程中，有些工具import cods插件。包分析工具，分析包所占比重。</p><p>库选择：</p><ul><li>扩展语言类</li><li>基础功能</li><li>兼容问题</li><li>少量成熟的组件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651227070&amp;amp;idx=1&amp;amp;sn=b2a7f923ed0432d97cc9b2951bb940d7&amp;amp;chksm
      
    
    </summary>
    
      <category term="开发实践分享" scheme="https://luoyec.cn/categories/%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="前端早读课" scheme="https://luoyec.cn/tags/%E5%89%8D%E7%AB%AF%E6%97%A9%E8%AF%BB%E8%AF%BE/"/>
    
      <category term="架构设计" scheme="https://luoyec.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数作用域和块作用域</title>
    <link href="https://luoyec.cn/2017/10/03/cl4e29qfq007z989elz5j1tc7/"/>
    <id>https://luoyec.cn/2017/10/03/cl4e29qfq007z989elz5j1tc7/</id>
    <published>2017-10-03T06:02:42.000Z</published>
    <updated>2017-10-03T06:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章讨论的问题是，是否只有函数会生成新的作用域，在Javas中其他的结构能生成作用域吗？</p><h1 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h1><p>考虑一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">var b = 2</span><br><span class="line">//一些代码</span><br><span class="line"></span><br><span class="line">function bar ()&#123;</span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更多的代码</span><br><span class="line"></span><br><span class="line">var c = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个代码片段中，foo（…） 的作用域气泡中包含了标识符a、b、c和bar，无论标志服声明出现在作用域中的何处，这个标识符所代表的变量或函数都将属于所处作用域的气泡。</p><p>所以，这些在foo中定义的标识符无法从全局作用域中进行访问，这会导致ReferenceError</p><p>总结一下函数作用域，属于这个函数的全局变量都可以在整个函数的范围内使用以及复用。但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能导致意想不到的问题。</p><h1 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h1><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示：从所写的代码中挑选出任意一个片段，然后利用函数声明对它进行包装，实际上就是把代码隐藏起来了。</p><p>这其实就是在这个代码片段周围创建了一个作用域气泡，也就是说任何声明（变量或者函数）都将绑定在这个新创建的包装函数的作用域中。</p><p>出发点以及目的，为什么要对代码进行隐藏：应该最小限度的暴露必要内容，而将其他内容都“隐藏起来”，这类似于某个模块或者对象的API设计。</p><h1 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h1><p>“隐藏”作用域中的变量和函数所带来的另一个好处是，是可以避免同名标识符之间的冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">i = <span class="number">3</span>; <span class="comment">//修改for循环所属作用域中的i</span></span><br><span class="line">              <span class="built_in">console</span>.log( a + i );</span><br><span class="line">          &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了!</span></span><br><span class="line">&#125; &#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这段代码的问题在于，函数bar修改了变量i，这会导致for循环没法满足终止的条件，出现无限循环。</p><p>解决这问题的几种方法：</p><ul><li>将函数bar中的i，声明为var i= 3； 这个i就是之前提过的“遮蔽变量”，及在当前作用域和上层作用域重复定义的变量，屏蔽上层的作用域定义的变量。</li><li>但是更好的方法，是应该讲作用域“隐藏”起来，内部声明是唯一最佳的选择。</li></ul><p>以下是在软件开发中常见的需要进行冲突管理的情况：</p><h2 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h2><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p><p>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象，这个对象就被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间的）属性。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var MyreallyCoolLibrary = &#123;</span><br><span class="line">awesome: &quot;stuff&quot;,</span><br><span class="line">dosometing: functino () &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;,</span><br><span class="line">doAnoterhThing: fucntion() &#123;</span><br><span class="line">//..</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器 的机制将库的标识符显式地导入到另外一个特定的作用域中。</p><h2 id="两种模式的共性"><a href="#两种模式的共性" class="headerlink" title="两种模式的共性"></a>两种模式的共性</h2><p>显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用 域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域 中，这样可以有效规避掉所有的意外冲突。</p><h1 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h1><p>虽然利用函数可以生成作用域，但这种方法有两个弊端，首先必须声明一个具名函数foo，这意味着这个名称本身“污染”了所在的作用域，这是不必要的。其实，必须显示地通过函数名（foo（））调用这个函数才能运行其中代码。</p><p>为解决以上问题，Javas提供了方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//3</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>将函数用（）包裹起来，这会将函数当做函数表达式而不是一个标准的函数声明来处理。</p><p>如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><h2 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h2><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处</p><p>比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过<br>foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。<br>换句话说，(function foo(){ .. })作为函数表达式意味着foo只能在..所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。</p><p><a href="http://www.cnblogs.com/isaboy/p/javascript_function.html" target="_blank" rel="noopener">参考：详解Javascript 函数声明和函数表达式的区别</a></p><h2 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure><p>这叫做匿名函数表达式，因为声明也名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p><p>匿名函数书写起来简单便捷，但是有几个确定需要考虑：</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，调试变得困难</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。</li><li>匿名函数省略了对于代码可读性/可理解性而言很重要的函数名，一个描述性的名称可以让代码不言自明。</li></ul><h3 id="行内函数表达式"><a href="#行内函数表达式" class="headerlink" title="行内函数表达式"></a>行内函数表达式</h3><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- 快看，我有名字了! </span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"I waited 1 second!"</span> );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure><h2 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//3 </span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>由于函数被包含在一对（）内部，一次成为一个表达式，通过在欧威加上另一个（）可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。</p><h2 id="IIFE（立即执行函数表达式）"><a href="#IIFE（立即执行函数表达式）" class="headerlink" title="IIFE（立即执行函数表达式）"></a>IIFE（立即执行函数表达式）</h2><p>这种模式很常见，几年前社区给它规定了一个术语:IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression);</p><p>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使 用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值 得推广的实践。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; (<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>; <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">      &#125;)();</span><br><span class="line">      <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式:(function(){ .. }())， 第一种形式中函数表达式被包含在( )中，然后在后面用另一个()括 号来调用。第二种形式中用来调用的()括号被移进了用来包装的( )括号中。<br>这两种形式在功能上是一致的。选择哪个全凭个人喜好。</p><p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 3 console.log( global.a ); // 2</span></span><br><span class="line">     &#125;)( <span class="built_in">window</span> );</span><br><span class="line">     <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123; def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 3 console.log( global.a ); // 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。</p><h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息。</p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h2><p>非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作<br>用域，其中声明的变量仅在 catch 内部有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log( err ); <span class="comment">// 能够正常执行! &#125;</span></span><br><span class="line">     <span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: err not found</span></span><br></pre></td></tr></table></figure><p>err仅仅存在于catch分句内部，当视图从别处引用它时会抛出错误</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let关键字可以将变量绑定到任意作用域中，通常是{…}内部，换句话说，let为其生命的变量隐式生成所在块作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line"><span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">bar = something( bar ); <span class="built_in">console</span>.log( bar );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><blockquote><p>变量提升：提升是指声明会被视为存在于其所出现的作用域的整个范围内</p></blockquote><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会<br>在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p><p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，<br>也可以属于某个代码块(通常指{ .. }内部)。</p><p>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</p><p>在 ES6 中引入了 let 关键字(var 关键字的表亲)，用来在任意代码块中声明变量。if (..) { let a = 2; }会声明一个劫持了if的{ .. }块的变量，并且将变量添加到这个块中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章讨论的问题是，是否只有函数会生成新的作用域，在Javas中其他的结构能生成作用域吗？&lt;/p&gt;
&lt;h1 id=&quot;函数中的作用域&quot;&gt;&lt;a href=&quot;#函数中的作用域&quot; class=&quot;headerlink&quot; title=&quot;函数中的作用域&quot;&gt;&lt;/a&gt;函数中的作用域&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域</title>
    <link href="https://luoyec.cn/2017/10/03/cl4e29qh300ab989e6wq06lzg/"/>
    <id>https://luoyec.cn/2017/10/03/cl4e29qh300ab989e6wq06lzg/</id>
    <published>2017-10-03T03:39:52.000Z</published>
    <updated>2017-10-03T06:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用(比如 Bash 脚本、Perl 中的一些模式等)。</p><h1 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h1><p>词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。</p><p>考虑一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">var b = a * 2</span><br><span class="line"></span><br><span class="line">function bar (c) &#123;</span><br><span class="line">console.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(b * 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure></p><p>在这个例子中有三个逐级嵌套的作用域，为了帮助理解，可以将他们想象成几个逐级包含的气泡。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1507001339403.jpg" alt=""></p><ul><li>包含整个全局作用域，其中只有一个标识符： foo</li><li>包含着foo所创建的作用域，其中有三个标识符： a、bar和b</li><li>包含着由bar所常见的作用域，其中只有一个标识符： c</li></ul><p>下一章会讨论不同类型的作用域，但现在只是简单的假设没一个函数都会创建一个新的作用域气泡<br>bar的气泡位置被完全包含在foo所创建的气泡中，唯一的原因就是我们希望定义函数bar的位置</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>作用域气泡的结构和相互位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。f引擎会从最内部的作用域中查找，如果没有找到会依次沿着上一级所嵌套的作用域中查找。</p><p>作用域查找会在找到第一个匹配的标识符时停止。</p><p>多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。</p><h1 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h1><p>量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪 明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代 码会运行得更慢这个事实。</p><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样。</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用(比如 Bash 脚本、Perl 中的一些模式等)。&lt;/p&gt;
&lt;h1 id=&quot;词法阶段&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>作用域是什么</title>
    <link href="https://luoyec.cn/2017/10/03/cl4e29qfi007j989ef75hrouk/"/>
    <id>https://luoyec.cn/2017/10/03/cl4e29qfi007j989ef75hrouk/</id>
    <published>2017-10-03T02:49:13.000Z</published>
    <updated>2017-10-03T06:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。</p></blockquote><p>需要一套设计良好的规则来存储变量，以便能够方便的找到这些变量，这套规则称为作用域。</p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。</p><ul><li><p>分词/词法分析</p></li><li><p>解析/语法分析</p></li><li><p>代码生成</p></li></ul><p>比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。</p><p>大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时 间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。</p><h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如 果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。</p><h2 id="引擎、编译器、作用域之间的关系"><a href="#引擎、编译器、作用域之间的关系" class="headerlink" title="引擎、编译器、作用域之间的关系"></a>引擎、编译器、作用域之间的关系</h2><ul><li>引擎负责整个JAvaScript程序的编译以及执行过程</li><li>编译器，复杂语法分析以及代码生成等脏活累活</li><li>作用域，复杂手机并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li></ul><h2 id="编译器遇到一个变量是如何解析的"><a href="#编译器遇到一个变量是如何解析的" class="headerlink" title="编译器遇到一个变量是如何解析的"></a>编译器遇到一个变量是如何解析的</h2><ul><li>遇到var a，编译器询问作用域是否已经有了一个该名称的变量存在于同一个作用域的集合中，如果是，编译器会忽略该声明，继续进行编译。否则，他会要求作用域在当前作用域中声明一个新的变量，并命名为a</li><li>接下编译器会为引擎生成运行时所需的代码，如果当前的作用域集合中存在一个变量a，如果是，则会使用这个变量，如果不是，则会继续查找该变量。</li></ul><h2 id="LHS、RHS"><a href="#LHS、RHS" class="headerlink" title="LHS、RHS"></a>LHS、RHS</h2><p>如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。</p><p>一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)  //RHS，只需要查询并获取a的值</span><br><span class="line"></span><br><span class="line">a = 2 //LHS，这并不关心当前的值是什么，只想为a赋值一个2</span><br></pre></td></tr></table></figure><p>在函数调用中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure><ul><li>最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。</li><li>为了给参数a（隐式的）赋值，需要进进行一次LHS查询</li><li>打印输出语句中，会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法。</li></ul><h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><p>遍历嵌套作用域的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续继续查找，当抵达最外层的全局作用域是，无论找到还是没找到，查找过程都会停止。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。</p><p>相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。</li></ul><ul><li>如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。<br>赋值操作会导致 LHS 查询。 = 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作, 即都会导致 LHS 查询。</li></ul><ul><li>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2 这样的声明会被分解成两个独立的步骤：<br>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。<br>接下来，a = 2会查询（LHS查询）变量 a 并对其进行赋值。</li></ul><ul><li>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。<br>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要一套设计良好的规则来存储变量，以便能够方便的
      
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://luoyec.cn/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="作用域" scheme="https://luoyec.cn/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>礼物说分享</title>
    <link href="https://luoyec.cn/2017/09/25/cl4e29qgy009v989eh3awxb6x/"/>
    <id>https://luoyec.cn/2017/09/25/cl4e29qgy009v989eh3awxb6x/</id>
    <published>2017-09-25T03:37:13.000Z</published>
    <updated>2017-10-03T06:42:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>此次为时两小时的分享，收获最大的两点：</p><ul><li>几乎所有的业务都可以流程化、模块化，并且可以在网上直接找到解决方案</li><li>跨领域成为常态：单一的知识体系已经不足以支撑</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/%E8%81%94%E7%9B%9F%E4%BC%9A%E8%AE%AE.png" alt="" title="联盟会议"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此次为时两小时的分享，收获最大的两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几乎所有的业务都可以流程化、模块化，并且可以在网上直接找到解决方案&lt;/li&gt;
&lt;li&gt;跨领域成为常态：单一的知识体系已经不足以支撑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://oudfgqw
      
    
    </summary>
    
      <category term="经验分享" scheme="https://luoyec.cn/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="成长" scheme="https://luoyec.cn/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="大牛" scheme="https://luoyec.cn/tags/%E5%A4%A7%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>路由协议与应用协议</title>
    <link href="https://luoyec.cn/2017/09/19/cl4e29qh800al989edu7365er/"/>
    <id>https://luoyec.cn/2017/09/19/cl4e29qh800al989edu7365er/</id>
    <published>2017-09-19T12:51:45.000Z</published>
    <updated>2017-09-19T12:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><p>在互联网世界中，夹杂着复杂的LAN和广域网。然而，再复杂的网络结构中，也需要通过合理的路由将数据发送到目标主机。而决定这个路由的，正是控制模块。</p><h2 id="路由控制的定义"><a href="#路由控制的定义" class="headerlink" title="路由控制的定义"></a>路由控制的定义</h2><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>路由器根据路由控制表（Routing Table）转发数据包。它根据所受到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。</p><h2 id="静态路由与动态留路由"><a href="#静态路由与动态留路由" class="headerlink" title="静态路由与动态留路由"></a>静态路由与动态留路由</h2><p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法，而动态路由是指让路由协议在运行过程中自动设置控制信息的一种方法。这些方法都有他们各自的利弊。</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>是指根据距离（代价）和方向决定目标网络或目标主机位置的一种方法。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505822740363.jpg" alt=""></p><h3 id="链路状态算法那"><a href="#链路状态算法那" class="headerlink" title="链路状态算法那"></a>链路状态算法那</h3><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505822935641.jpg" alt=""></p><h1 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505823512383.jpg" alt=""></p><h2 id="应用层协议概要"><a href="#应用层协议概要" class="headerlink" title="应用层协议概要"></a>应用层协议概要</h2><p>TCP和IP等下层协议是不依赖与上层应用类型、实用性非常广的协议。而应用协议则是为了实现某些应用而设计和创造的协议。</p><p>开发者只要关心选用哪种应用协议、如何开发即可，而不必担心应用中的数据该以何种方式发送到目标主机等问题。</p><p>应用层协议相当于OSI中第5、6、7层的协议</p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><h3 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h3><p>TELNET利用TCP的一条连接，通过这一条连接想主机发送文字命令并在主机上执行。本地用户好像直接与远端主机内部的Shell相连似的，直接在本地操作。</p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH是加密的远程登录系统。TELNET中登录时无须密码就能发送容易造成通信窃听和非法入侵的微信。</p><p>SSH可以提供：</p><ul><li>可以使用更强的认证机制</li><li>可以转发文件</li><li><p>可以使用端口转发功能</p><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>FTP是两个相连计算机之间进行文件传输是使用的协议。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505824857406.jpg" alt=""></p></li></ul><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><p>  万维网（WWW，World Wide Web）是将互联网中的信息以超文本形式展现的系统，也叫Web。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p> www定义了三个重要概念，他们分别是访问信息的手段与位置（URI，Uniform Resource Identifier）、信息的表现形式（HTML，HyperText Markup Language）以及信息转发（HTTP，HyperTyxt Transfer Protocol）等操作。</p><ul><li>RUL：是一种可以用于WWW之外的高效识别码，他被用于主页地址、电子邮件、电话号码等各种组合中。</li><li>HTML：是描述web网页的一种语言，指定浏览器显示的内容，包括图像、动画、音频、视频等</li><li>HTTP：HTTP连接一个TCP了解，然后在这个TCP连接上进行请求和应答数据报文的发送。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由协议&quot;&gt;&lt;a href=&quot;#路由协议&quot; class=&quot;headerlink&quot; title=&quot;路由协议&quot;&gt;&lt;/a&gt;路由协议&lt;/h1&gt;&lt;p&gt;在互联网世界中，夹杂着复杂的LAN和广域网。然而，再复杂的网络结构中，也需要通过合理的路由将数据发送到目标主机。而决定这个路
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP与UDP</title>
    <link href="https://luoyec.cn/2017/09/19/cl4e29qei005m989e4x64ilc4/"/>
    <id>https://luoyec.cn/2017/09/19/cl4e29qei005m989e4x64ilc4/</id>
    <published>2017-09-19T11:53:34.000Z</published>
    <updated>2017-09-19T11:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用和通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。</p><h1 id="传输层定义"><a href="#传输层定义" class="headerlink" title="传输层定义"></a>传输层定义</h1><p>IP首部中有一个协议字段，用来标识网络层（IP）的上一层采用的是哪一种传输层协议，根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容还是UDP的内容。</p><h1 id="通信处理"><a href="#通信处理" class="headerlink" title="通信处理"></a>通信处理</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505739603132.jpg" alt=""></p><h1 id="两种传输层协议TCP和UDP"><a href="#两种传输层协议TCP和UDP" class="headerlink" title="两种传输层协议TCP和UDP"></a>两种传输层协议TCP和UDP</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>是面向连接的、可靠的流协议。所谓流就是指不间断的数据结构，可以类比水流。</p><p>TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口等机制实现可靠性传输。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是不具有可靠性的数据报协议，在这种情况下，虽然可以保证发送消息的大小，却不能保证消息一定到达。</p><p>应用场景：</p><ul><li>包总量较少的通信（DNS、SNMP）等</li><li>视频、音频等多媒体通信（即使通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><blockquote><p>套接字（Soket）<br>在应用程序中利用套接字，可以设置对端的IP地址、端口号、并实现数据的发送与接收</p></blockquote><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505797518206.jpg" alt=""></p><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>端口号用来识别同一台计算机中进行通信的不同应用程序，一次，它也被称为程序地址。</p><h2 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h2><p>传输层利用端口号识别本机中正在进行通信的应用程序。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505797650982.jpg" alt=""></p><h2 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h2><ul><li>标准既定的端口号</li><li>时序分配法：例如每需要一个新的端口号就在之前的分配的号码的基础上加1</li></ul><h2 id="端口与协议"><a href="#端口与协议" class="headerlink" title="端口与协议"></a>端口与协议</h2><p>端口号由其使用的传输层协议决定，因此，不同的传输协议可以使用相同的端口号。</p><p>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果是TCP则传给TCP模块，由传输协议各自独立处理。</p><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>UDP是一种面向无连接的通信协议，因此不检查对端是否可用痛殴更新，直接将UDP包发送出去。TCP相反。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505820102926.jpg" alt=""></p><h1 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505820524004.jpg" alt=""></p><ul><li>源端口号（Source Port）：表示发送端口号，字段长16位。</li><li>目标端口号（Destination Port）：表示接收端口号，字段长度16位。</li><li>包长度（Length）：该字段保存了UDP首部的长度跟数据的长度之和。单位字节为8</li><li>校验和（Checksum）：校验和是为了提供可靠的UDP首部和数据而设计的。</li></ul><h1 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505820793298.jpg" alt=""></p><ul><li>源端口号（Source Port）：表示发送端端口号，字段长16位</li><li>目标端口号（Destination Port）：表示接受端口号，字段长度16位。</li><li>序列号（Sequence Number）:是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小</li><li>确认应答号（Acknowledgement Number）：下一次应该收到的数据的序列号。</li><li>数据偏移（Data Offset）：表示TCP所传输的数据部分应该从TCP包的哪个位开始计算。也可看作TCP首部的长度。</li><li>保留（Reserved）：为 以后扩展</li><li>控制位（Control Flag）: 字段长8位，每一位从左至右分别为 CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505821531586.jpg" alt=""></li><li>窗口大小（Window Size）：用于通知从农耕相同TCP首部的确认应答号所指位置开始能够接受的数据大小。TCP不允许发送超过此处所表示大小的数据。</li><li>校验和（Checksum）：如果计算校验和字段在内的所有数据的16位和以后，得出的结果是“16位全部为1”说明所收到的数据时正确的。</li><li>紧急指针（Urgent Pointer）：紧急指针指出了紧急数据的末尾在报文段中的位置。</li><li>选项（Options）：用于提高TCP传输性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用和通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。&lt;/p&gt;
&lt;h1 id=&quot;传输层定义&quot;&gt;&lt;a href=&quot;#传输层定义&quot; class=&quot;headerlink&quot; title=&quot;传输层定
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IP协议相关技术</title>
    <link href="https://luoyec.cn/2017/09/18/cl4e29qce001f989eu1jg8z5i/"/>
    <id>https://luoyec.cn/2017/09/18/cl4e29qce001f989eu1jg8z5i/</id>
    <published>2017-09-18T12:42:21.000Z</published>
    <updated>2017-09-18T12:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>IP（Internet Protocal）旨在让最终目标主机收到数据包，但是在这一过程中仅仅IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS(Domain Name System)，将字符串自动转成具体的IP地址</p><blockquote><p>主机识别码：是指为每台计算机赋以唯一的主机名，在进行网络通信时可以直接使用主机名称而无需输入一大串的IP地址。并且此时，系统必须自动将主机名转换成具体的IP地址。</p></blockquote><h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505736952526.jpg" alt=""></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>是指管理域名的主机和响应的软件，他可以管理所在分层的相关信息。</p><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>进行DNS查询的主机和软件叫做DNS解析器，用户使用的工作站和个人电脑都属于解析器</p><h2 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h2><p>解析器为了调查IP地址，向域名服务器进行查询处理。首先在自己的数据库中查找，如果没有则再向上一层根域名服务器进行查询处理。</p><h2 id="DNS如同互联网中的分布式数据库"><a href="#DNS如同互联网中的分布式数据库" class="headerlink" title="DNS如同互联网中的分布式数据库"></a>DNS如同互联网中的分布式数据库</h2><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>只要确定了IP地址，就可以向这个目标地址发送IP数据，然而，在底层数据链路层，进行实际通信时有必要了解每个IP地址所对应的MAC地址。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接受数据分包的网络设备对应的MAC地址。如果目标不在同一个链路上时，可以通过ARP查找下一级路由器调转的MAC地址。不过ARP只适用于IPv4.</p><h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><p>RARP（Reverse Address Resolution Protocal）是将ARP反过来，从MAC地址定位IP地址的一种协议。</p><h1 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h1><p>采用ARP（Proxy ARP）的路由器可以将ARP请求转发给邻近的网段。</p><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>其主要功能，确定IP包是否成功送达目的地址，通知在发送过程当中IP包被丢弃的原因，改善网络设置等。</p><h1 id="DHCP实现即插即用"><a href="#DHCP实现即插即用" class="headerlink" title="DHCP实现即插即用"></a>DHCP实现即插即用</h1><p>  能够自动设置IP地址、统一管理IP地址分配，由此产生了DHCP（Dynamic Host Configuration Protocal）。只要计算机连接了网络，就可以进行TCP/IP 通信。</p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  NAT（Network Address Translator）用于网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。</p><h1 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h1><p>  IP隧道为了IPv4与IPv6之间的相互通信。</p><p>  IP隧道可以将那些从网络A发送过来的IPv6包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C（采用IPv4的网络）</p><p>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505738443662.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP（Internet Protocal）旨在让最终目标主机收到数据包，但是在这一过程中仅仅IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。&lt;/p&gt;
&lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; clas
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IP协议</title>
    <link href="https://luoyec.cn/2017/09/18/cl4e29qcj001n989er2ja7mr0/"/>
    <id>https://luoyec.cn/2017/09/18/cl4e29qcj001n989er2ja7mr0/</id>
    <published>2017-09-18T12:07:00.000Z</published>
    <updated>2017-09-18T12:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>IP作为整个TCP/IP中至关重要的协议，主要复杂数据包发送给最终目标计算机。因此，IP能够让世界上任何两台计算机之间进行通信。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505535067605.jpg" alt=""></p><h2 id="IP相当于OSI参考模型的第3层"><a href="#IP相当于OSI参考模型的第3层" class="headerlink" title="IP相当于OSI参考模型的第3层"></a>IP相当于OSI参考模型的第3层</h2><p>  网络层的主要作用是“实现终端节点之间的通信”，这种终端节点之间的通信也叫“点对点（end to end）通信”。</p><p>  网络层的下一层–数据链路层的主要作用就是互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。</p><p>  网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点的数据包传输。</p><p>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505535982756.jpg" alt=""></p><blockquote><p>主机与节点<br>那些配有IP地址的设备叫“主机”，既配有IP地址又具有路由控制能力的设备叫做路由器。</p></blockquote><h2 id="网络层与数据链路层的关系"><a href="#网络层与数据链路层的关系" class="headerlink" title="网络层与数据链路层的关系"></a>网络层与数据链路层的关系</h2><p>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505536631466.jpg" alt=""></p><h1 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h1><p>  IP大致分为三大模块，分别是IP寻址、路由以及IP分包、组包</p><h2 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h2><p>  IP地址用于在“连接到网络中所有主机中识别出进行通信的目标地址。”， 因此，在TCP/ IP 通信中所有主机或路由器必须设定自己的IP地址。</p><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><ul><li><p>发送数据至最终目标地址</p></li><li><p>路由控制表</p></li></ul><h2 id="IP属于面向无连接"><a href="#IP属于面向无连接" class="headerlink" title="IP属于面向无连接"></a>IP属于面向无连接</h2><p> IP面向无连接，即在发包之前，不需要建立与对端目标地址之间的连接。而面向有连接的情况，需要事先建立连接，如果对端主机关机与不存在，也就不可能建立连接。</p><h1 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h1><h2 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h2><p> IP地址（IPv4地址）由32位正整数来表示。TCP/IP 通信要求将这样的IP地址分配给每个参与通信的主机。</p><p> <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505548968497.jpg" alt=""></p><h2 id="IP地址由网络和主机两部分标识组成"><a href="#IP地址由网络和主机两部分标识组成" class="headerlink" title="IP地址由网络和主机两部分标识组成"></a>IP地址由网络和主机两部分标识组成</h2><p>IP地址由“网络标识（网络地址）”和“主机标志（主机地址）”两部分组成。</p><p>网络标志在数据链路中每个配置不同的值，网络标志必须保证相互连接的每个段的地址不重复。</p><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>IP地址分为四个级别，分别为A、B、C、D类，它根据IP地址中从第一位到第四位的比特列队其网络标识和主机标识区分。</p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p>A类地址是以首位为“0”开头的地址。0.0.0.0~127.0.0.0是A类网络地址。</p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p>B类IP地址是前两位为“10”的地址。128.0.0.1~191.255.0.0</p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p>前两位为“110”的地址， 192.168.0.0~239.255.255.0</p><h3 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h3><p>前两位为“1110”的地址，224.0.0.0~239.255.255.255，<br>D类地址没有主机标识，常被用于多播</p><h3 id="关于分配IP主机地址的注意事项"><a href="#关于分配IP主机地址的注意事项" class="headerlink" title="关于分配IP主机地址的注意事项"></a>关于分配IP主机地址的注意事项</h3><p>要用比特位标识主机地址时，不可用全部为0或者全部为1，全部为0的情况是表示对应的网络地址或IP地址不可获知的情况下才使用。全部为1的主机地址，通常作为广播地址。</p><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>将IP地址中主机地址全部设置为1，如 172.20.255.255</p><ul><li>本地广播：在本网络内的广播</li><li>直接广播：在不同网络之间的广播叫直接广播</li></ul><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><h3 id="分类造成浪费？"><a href="#分类造成浪费？" class="headerlink" title="分类造成浪费？"></a>分类造成浪费？</h3><p>随着互联网的覆盖范围逐渐增大，网络地址越来越不足应对需求，直接使用ABC类地址就显得很浪费。</p><h3 id="子网与子网掩码"><a href="#子网与子网掩码" class="headerlink" title="子网与子网掩码"></a>子网与子网掩码</h3><p>现在，一个IP地址的网络标志和主机标识已经不再受限于该地址的类别，而是由一个叫“子网掩码”的识别码通过子网网络地址细分出别ABC类更小粒度的网络。</p><h1 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h1><p>数据包需要路由器持有的控制表指明真正发送的目标地址。</p><p>这种控制表有两种获得途径： </p><ul><li>管理员手动录入（静态路由）</li><li>路由器与其他路由器相互交互信息时自动刷新（动态路由）</li></ul><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>IP地址的网络地址部分用于进行路由控制。</p><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先yaoquedingIP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p><ul><li>默认路由<br>  默认路由标记为0.0.0.0，标识一张路由表中包含所有的网络及其子网络信息。</li><li>主机路由<br> 整个IP地址的所有位都参与路由，这意味着要基于主机在网卡上配置的IP地址本身。</li><li>环回地址<br>  使用特殊的IP地址 127.0.0.1作为环回地址，此时，数据包不会流向网络</li></ul><h2 id="路由控制表的聚合"><a href="#路由控制表的聚合" class="headerlink" title="路由控制表的聚合"></a>路由控制表的聚合</h2><p>利用网络地址的比特分布可以有效地进行分层配置，对内即有多个子网掩码，对外呈现出同一个网络地址。这样可以更好的构建网络，通过路由信息的聚合可以有效地减小路由表的条目</p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505735602970.jpg" alt=""></p><h1 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h1><p>  通过IP进行通信时，需要在数据前面加上IP首部信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。</p><p>  <img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505735850688.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;IP作为整个TCP/IP中至关重要的协议，主要复杂数据包发送给最终目标计算机。因此，IP能够让世界上任何两台计算机之间进行通信。&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据链路</title>
    <link href="https://luoyec.cn/2017/09/15/cl4e29qgh0096989e0zj77gox/"/>
    <id>https://luoyec.cn/2017/09/15/cl4e29qgh0096989e0zj77gox/</id>
    <published>2017-09-15T05:17:56.000Z</published>
    <updated>2017-09-15T05:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h1><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外的介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p><h1 id="数据链路的相关技术"><a href="#数据链路的相关技术" class="headerlink" title="数据链路的相关技术"></a>数据链路的相关技术</h1><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC地址用于识别数据链路中互连的节点。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505436578945.jpg" alt=""></p><blockquote><p>例外情况–MAC地址不一定是唯一的<br>只要不在同一个数据链路就不会出现问题。</p></blockquote><blockquote><p>厂商识别码<br>它可以分析出局域网中的包是由哪个厂商的网卡发出的。</p></blockquote><h2 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h2><p>  共享介质型网络是指多个设备共享一个通信介质的一种网络。在这种方式下，设备之间使用同一个载波通信信道进行发送和接收。</p><ul><li>争用方式</li><li>令牌传递方式</li></ul><h2 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h2><p>在这种方式下，网络中每个站直连交换机，由交换机负责转发数据帧。发送端与接收端并不共享通信介质，因此很多情况下采用全双工通信方式。</p><blockquote><p>半双工与全双工<br>半双工是指，只发送或只接收的通信方式，类似于无线电收发器。<br>全双杠：在使用交换机与双绞线电缆（或光纤电缆）的情况下，既可以通过交互机端口与计算机之间进行一对一的连接，也可以通过相连电缆内部的收发线路分别进行接收和发送数据。</p></blockquote><h2 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h2><p>以太网交互机就是持有多个端口的网桥，它们根据数据链路中每个帧的目标MAC地址，决定哪个网络接口发送数据。</p><h2 id="环路检测技术"><a href="#环路检测技术" class="headerlink" title="环路检测技术"></a>环路检测技术</h2><ul><li>生成树方式</li><li>源路由法</li></ul><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>对VLAN进行了扩展，不必重新修改布线，只要修改网段即可。</p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p>以太网前端有一个叫做前导码的部分，它由0、1数字交替组合而成，标识一个以太网帧的开始，也是对端网卡能够确保其同步的标志。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505451724015.jpg" alt=""></p><p>以太网帧本体是以太网的首部，它总共14个字节，分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505451836345.jpg" alt=""></p><h1 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505452207582.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据链路的作用&quot;&gt;&lt;a href=&quot;#数据链路的作用&quot; class=&quot;headerlink&quot; title=&quot;数据链路的作用&quot;&gt;&lt;/a&gt;数据链路的作用&lt;/h1&gt;&lt;p&gt;数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 基础知识</title>
    <link href="https://luoyec.cn/2017/09/12/cl4e29qe1004s989e7inwcpqy/"/>
    <id>https://luoyec.cn/2017/09/12/cl4e29qe1004s989e7inwcpqy/</id>
    <published>2017-09-12T06:08:14.000Z</published>
    <updated>2017-09-12T06:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP（Transmission Control Protocool）和IP（Internet Protocol）是互联网的众多通信协议中最为著名的。本章介绍TCP/IP 的发展历程及其协议概况。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505087594668.jpg" alt=""></p><h1 id="TCP-IP-出现的背景及其历史"><a href="#TCP-IP-出现的背景及其历史" class="headerlink" title="TCP/IP 出现的背景及其历史"></a>TCP/IP 出现的背景及其历史</h1><h2 id="从军用技术的应用谈起"><a href="#从军用技术的应用谈起" class="headerlink" title="从军用技术的应用谈起"></a>从军用技术的应用谈起</h2><h2 id="ARPANET的诞生"><a href="#ARPANET的诞生" class="headerlink" title="ARPANET的诞生"></a>ARPANET的诞生</h2><h2 id="TCP-IP-的诞生"><a href="#TCP-IP-的诞生" class="headerlink" title="TCP/IP 的诞生"></a>TCP/IP 的诞生</h2><h2 id="UNIX系统的普及及与互联网的扩张"><a href="#UNIX系统的普及及与互联网的扩张" class="headerlink" title="UNIX系统的普及及与互联网的扩张"></a>UNIX系统的普及及与互联网的扩张</h2><h2 id="商用互联网服务的启蒙"><a href="#商用互联网服务的启蒙" class="headerlink" title="商用互联网服务的启蒙"></a>商用互联网服务的启蒙</h2><h1 id="TCP-IP-的标准化"><a href="#TCP-IP-的标准化" class="headerlink" title="TCP/IP 的标准化"></a>TCP/IP 的标准化</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505179561962.jpg" alt=""></p><h1 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505179766310.jpg" alt=""></p><h2 id="硬件（物理层）"><a href="#硬件（物理层）" class="headerlink" title="硬件（物理层）"></a>硬件（物理层）</h2><p>TCP/IP的最底层复杂数据传输的硬件。这种硬件就相当于以太网或电话线等物理层设备。</p><h2 id="网络接口层（数据链路层）"><a href="#网络接口层（数据链路层）" class="headerlink" title="网络接口层（数据链路层）"></a>网络接口层（数据链路层）</h2><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p><h2 id="互联网层（网络层）"><a href="#互联网层（网络层）" class="headerlink" title="互联网层（网络层）"></a>互联网层（网络层）</h2><p>互联网层使用IP协议，它相同于OSI模型中的第三层网络层。IP协议基于IP地址转发分包数据。</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP是跨越网络产送数据包，是整个互联网都能收到数据的协议。IP协议使数据能够发送到地球另一端，这期间它使用IP地址作为主机的标识。</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>IP数据包在发送途中一旦发生异常导致无法到底对端目标地址时，需要给发送端一个发生异常的通知。ICMP就是为了一功能而定制的，它有时也被用作诊断网络的健康状况。</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>从分组数据包IP地址中解析出物理地址（MAC地址）的一种协议。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505195103235.jpg" alt=""><br>传输层最主要的功能就是能够让应用程序之间实现通信。在计算机内部，通过应用程序端口号来区分哪些程序正在进行通信。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP是一种面向有链接的传输层协议，它既可以保证两端通信主机之间的通信可达，还可以正确处理传输过程中丢包、传输顺序乱掉的异常情况。此外TCP还能够有效利用带宽，环节网络拥堵。</p><p>缺点是，为了建立连接和断开连接，需要至少7次的手包和发包，导致网络流量的浪费。这并不适用于视频会议等场合使用。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>它是一种面向无连接的传输层协议。UDP不关注端是否真的收到了传送过去的数据。</p><p>UDP常用于分组数据较少或多播、广播通信以及使用通信等多媒体领域。</p><h2 id="应用层（会话层以上的分层）"><a href="#应用层（会话层以上的分层）" class="headerlink" title="应用层（会话层以上的分层）"></a>应用层（会话层以上的分层）</h2><p>-电子邮件（E-Mail）<br>    SMTP协议</p><ul><li>文件传输（FTP）<br>  在FTP中进行文件传输时会建立两个TCP链接，分别是发送传输请求时所要用到的控制链接与实际传输数据时所要用到的数据连接。</li><li>远程登录（TELNET与SSH）</li><li>网络管理（SNMP）</li></ul><h1 id="TCP-IP-分层模型与通信示例"><a href="#TCP-IP-分层模型与通信示例" class="headerlink" title="TCP/IP 分层模型与通信示例"></a>TCP/IP 分层模型与通信示例</h1><h2 id="数据包首部"><a href="#数据包首部" class="headerlink" title="数据包首部"></a>数据包首部</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505195718502.jpg" alt=""></p><p>每个分层中，都会对所发送的数据附件一个首部，在这个首部中包含了该层必要的信息，如发送目标地址以及协议相关的信息。</p><p>在数据包的首部，明确表明了协议应该如何读取数据，反过来，看到首部，也就能够了解协议必要的信息以及所要处理的内容。</p><h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><p>以一封邮件的发送为例子：</p><ul><li>应用程序处理：鼠标点击送就开始了TCP/IP的通信了</li><li>TCP模块的处理：TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输</li><li>IP模块的处理：IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端加上自己的IP首部</li><li>网络接口（以太网驱动的处理）：给TP传过来的IP包附加上以太网首部并进行发送处理</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505196194505.jpg" alt=""></p><h2 id="经过数据链路的包"><a href="#经过数据链路的包" class="headerlink" title="经过数据链路的包"></a>经过数据链路的包</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505196293863.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505196280398.jpg" alt=""></p><h2 id="数据包的接收处理"><a href="#数据包的接收处理" class="headerlink" title="数据包的接收处理"></a>数据包的接收处理</h2><p>包的接受流程是发送路程逆序过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP（Transmission Control Protocool）和IP（Internet Protocol）是互联网的众多通信协议中最为著名的。本章介绍TCP/IP 的发展历程及其协议概况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oudfgqwcq.bkt.
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="https://luoyec.cn/2017/09/11/cl4e29qgz009x989ex0sax4by/"/>
    <id>https://luoyec.cn/2017/09/11/cl4e29qgz009x989ex0sax4by/</id>
    <published>2017-09-10T23:46:16.000Z</published>
    <updated>2017-09-10T23:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章总结了深入理解TCP/IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504966276440.jpg" alt=""></p><h2 id="计算机网络出现的背景"><a href="#计算机网络出现的背景" class="headerlink" title="计算机网络出现的背景"></a>计算机网络出现的背景</h2><h2 id="从独立模式到网络互联模式"><a href="#从独立模式到网络互联模式" class="headerlink" title="从独立模式到网络互联模式"></a>从独立模式到网络互联模式</h2><p>  计算机网络，根据其规模可分为WAN（Wide Area Network， 广域网）和LAN（Local Area Networ， 局域网）</p><h2 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h2><p>  分组交换是指将大数据分割为一个个叫包（Packet）的较小单位进行传输的方法。<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504967619906.jpg" alt=""></p><blockquote><p>标准化：所谓标准化是指不同厂商所生产的异构产品之间具有兼容性、便于使用的规范化过程。</p></blockquote><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504968037402.jpg" alt=""></p><h2 id="OSI参考模型在各个分层的作用"><a href="#OSI参考模型在各个分层的作用" class="headerlink" title="OSI参考模型在各个分层的作用"></a>OSI参考模型在各个分层的作用</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504968175860.jpg" alt=""></p><h2 id="OSI参考模型通信处理举例"><a href="#OSI参考模型通信处理举例" class="headerlink" title="OSI参考模型通信处理举例"></a>OSI参考模型通信处理举例</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1505012773330.jpg" alt=""></p><h2 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h2><h3 id="面向有连接型和面向无连接型"><a href="#面向有连接型和面向无连接型" class="headerlink" title="面向有连接型和面向无连接型"></a>面向有连接型和面向无连接型</h3><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1505015596197.jpg" alt=""></p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p>让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。数据被细分后，所有的计算机就可以一齐收发数据，这样也提高了通信线路的利用率。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1505015984794.jpg" alt=""></p><h2 id="根据接收端数量分类"><a href="#根据接收端数量分类" class="headerlink" title="根据接收端数量分类"></a>根据接收端数量分类</h2><h3 id="单播（Unicast）"><a href="#单播（Unicast）" class="headerlink" title="单播（Unicast）"></a>单播（Unicast）</h3><p>1对1通信，早期的固定电话就是单播通信的例子。</p><h3 id="广播（Broadcast）"><a href="#广播（Broadcast）" class="headerlink" title="广播（Broadcast）"></a>广播（Broadcast）</h3><p>将消息从1台主机发送与之相连的所有其他主机。</p><h3 id="多播（Multicast）"><a href="#多播（Multicast）" class="headerlink" title="多播（Multicast）"></a>多播（Multicast）</h3><p>也是将消息发给多个接收主机，不同之处在于多播要限定某一组作为接收端。</p><h3 id="任播（Anycast）"><a href="#任播（Anycast）" class="headerlink" title="任播（Anycast）"></a>任播（Anycast）</h3><p>指的是在特定多态主机中选出一台作为接收端的一种通信方式。<br><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505085985062.jpg" alt=""></p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>在实际的网络通信中，每一层的协议所使用的地址都是不尽相同的，例如TCP/IP中使用MAC地址、IP地址、端口号等信息作为地址标识。甚至在应用层中，可以将电子邮件地址作为网络通信的地址。</p><p>MAC地址由设备制造商对每块网卡分别指定。但对于寻址并没有起到任何作用，所以不能算作有层次的地址。正因如此，虽然MAC地址是真正复杂通信地址，但在实际寻址过程中，IP地址却必不可少。</p><h2 id="网络构成的要素"><a href="#网络构成的要素" class="headerlink" title="网络构成的要素"></a>网络构成的要素</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1505086794129.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章总结了深入理解TCP/IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5
      
    
    </summary>
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/categories/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
    
      <category term="图解TCP/IP" scheme="https://luoyec.cn/tags/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分析算法</title>
    <link href="https://luoyec.cn/2017/09/06/cl4e29qfs0082989e9td37501/"/>
    <id>https://luoyec.cn/2017/09/06/cl4e29qfs0082989e9td37501/</id>
    <published>2017-09-06T12:04:30.000Z</published>
    <updated>2017-09-06T12:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关注的是计算时间"><a href="#关注的是计算时间" class="headerlink" title="关注的是计算时间"></a>关注的是计算时间</h2><blockquote><p>分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存、通信宽带或计算机硬件这类资源，但通常我们想度量的是计算时间。</p></blockquote><h2 id="最坏情况和最好情况"><a href="#最坏情况和最好情况" class="headerlink" title="最坏情况和最好情况"></a>最坏情况和最好情况</h2><p>往往集中于只求最坏情况的运行时间，即对规模为n的任何输入，算法的最长运行时间</p><ul><li><p>最坏的运行时间确定了一个上界，这可以确保算法绝对不会需要比这更长的运行时间</p></li><li><p>对于某些算法，最坏的情况经常出现</p></li><li><p>“平均情况”往往与最坏大致一样差</p></li></ul><h2 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504339302788.jpg" alt=""><br>我们只考虑公式中最重要的项（如 an^2）,因为当n的值很大时，低阶相对来说不太重要。我们也忽略最重要的项的常数项，因为对大的输入，在确定计算效率时常量银子不如增长率重要。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="θ记号"><a href="#θ记号" class="headerlink" title="θ记号"></a>θ记号</h3><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504481635423.jpg" alt=""></p><p>θ(n^3) - θ(n^2) - 100n 忽略低阶项则为 θ(n^3)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504482389251.jpg" alt=""></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> &lt;- <span class="number">1</span> to length[A]-<span class="number">1</span>  </span><br><span class="line">    do min &lt;- <span class="selector-tag">i</span>  </span><br><span class="line">        <span class="keyword">for</span> j &lt;- i+<span class="number">1</span> to length[A]  </span><br><span class="line">            do <span class="keyword">if</span> A[j] &lt; A[min]  </span><br><span class="line">                then min &lt;-j  </span><br><span class="line">        exchange(A[i], A[min])</span><br></pre></td></tr></table></figure><p>使用TypeScript实现选择算法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SelectSort &#123;</span><br><span class="line">    <span class="keyword">private</span> sortArray: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sortArray = arr</span><br><span class="line">        <span class="keyword">this</span>.selectSort()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> selectSort(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> len: <span class="built_in">number</span> = <span class="keyword">this</span>.sortArray.length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="built_in">number</span> = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> min: <span class="built_in">number</span> = <span class="keyword">this</span>.sortArray[i]</span><br><span class="line">            <span class="keyword">let</span> temp: <span class="built_in">number</span></span><br><span class="line">            <span class="keyword">let</span> index: <span class="built_in">number</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.sortArray[j] &lt; min) &#123;</span><br><span class="line">                    min = <span class="keyword">this</span>.sortArray[j]</span><br><span class="line">                    index = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="keyword">this</span>.sortArray[i]</span><br><span class="line">            <span class="keyword">this</span>.sortArray[i] = min</span><br><span class="line">            <span class="keyword">this</span>.sortArray[index] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> printSortWell() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.sortArray.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> selectSort: SelectSort = <span class="keyword">new</span> SelectSort([<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>])</span><br><span class="line">selectSort.printSortWell()</span><br></pre></td></tr></table></figure><p>选择排序时间复杂度</p><p>选择排序的时间复杂度是O(N2)。<br>假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1！因此，选择排序的时间复杂度是O(N2)</p><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><p>再次考虑线性查找问题，在平均情况下，需要检查输入序列中的多少个元素？假定待查找的元素是数组中任何一个元素的可能性相等，在最坏情况下又怎样呢？用O形式表示，线性查找最坏情况运行时间是多少？并说明</p><ul><li><p>平均情况下需要查找序列中(1+n)/2个元素</p></li><li><p>最坏情况下：n个元素。即O(n)为最坏</p></li></ul><h3 id="修改算法以获取最佳运行时间"><a href="#修改算法以获取最佳运行时间" class="headerlink" title="修改算法以获取最佳运行时间"></a>修改算法以获取最佳运行时间</h3><p>应如何修改任何一个算法，才能使之具有较好的最佳情况运行时间</p><p>根据算法的最佳情况改变输入数据的分布（比如说顺序），使之符合最佳情况条件，这样就能拥有最佳运行时间。</p><p>总之是制造出符合最佳情况的条件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关注的是计算时间&quot;&gt;&lt;a href=&quot;#关注的是计算时间&quot; class=&quot;headerlink&quot; title=&quot;关注的是计算时间&quot;&gt;&lt;/a&gt;关注的是计算时间&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存
      
    
    </summary>
    
      <category term="算法导论" scheme="https://luoyec.cn/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="https://luoyec.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="习题答案" scheme="https://luoyec.cn/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>异步操作和async函数</title>
    <link href="https://luoyec.cn/2017/09/03/cl4e29qg5008p989ehysnv0x6/"/>
    <id>https://luoyec.cn/2017/09/03/cl4e29qg5008p989ehysnv0x6/</id>
    <published>2017-09-03T15:59:51.000Z</published>
    <updated>2017-09-03T16:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异步编程对于JavaScript是极为重要的。JavaScript只有一个线程，如果异步编程，得卡死，基本没法用。</p></blockquote><p>ES6诞生之前，异步编程的方法大概有以下几种：</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise对象</li></ul><blockquote><p>ES7中的async函数更是给出异步编程的终极解决方案</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>所谓“异步”，简单说就是一个任务分成两段执行，先执行第一段，然后转而执行其他任务，等做完准备工作再回过头执行第二段。</p><p>相应的，连续执行的就叫同步。</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>所谓“回调”就是把任务的第二段单独写在一个函数中，等到重新执行该任务时直接调用这个函数。</p><p>读取文件进行处理是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>为什么nodejs约定回调函数的第一个参数必须是错误对象err（如果没有错误，该参数就是null）？原因是执行拆分成两段，在这两段之间抛出的错误程序无法捕获，只能当做参数传入第二段</p></blockquote><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>当回调函数过多，多重嵌套。代码不是纵向发展而是横向发展，很快代码就会乱成一团。Promise就是为了解决这个问题诞生的。</p><p>Promise不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载改成纵向加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>)</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> readFile(fileB)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise最大的问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义并不清楚。</p><h1 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h1><h2 id="传名调用和传值调用"><a href="#传名调用和传值调用" class="headerlink" title="传名调用和传值调用"></a>传名调用和传值调用</h2><ul><li>传值调用：在进入函数之前，就计算参数的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>) </span><br><span class="line"><span class="comment">//传值调用等同于</span></span><br><span class="line">f(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><ul><li>传名调用：传值调用比较简单，但是对参数求值时并未使用这个参数，有可能造成性能损失。而传名调用就是只在执行时求值</li></ul><h2 id="Thunk函数的含义"><a href="#Thunk函数的含义" class="headerlink" title="Thunk函数的含义"></a>Thunk函数的含义</h2><p>编译器“传名调用”实现往往是先将参数放到一个临时函数中，在将这个临时函数传入函数体。这个临时函数就叫Thunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f (x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">//等同于  参数放到一个临时函数</span></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> thunk() * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h1><p>async函数返回值是Promise，你可用then方法指定下一步操作。</p><h2 id="async函数实现"><a href="#async函数实现" class="headerlink" title="async函数实现"></a>async函数实现</h2><p>async函数的实现就是将Generator函数和自动执行器包装在一个函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="comment">//参数运算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span> *)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="asycn的用法"><a href="#asycn的用法" class="headerlink" title="asycn的用法"></a>asycn的用法</h2><p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行时，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后台的语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStokPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> symbo = <span class="keyword">await</span> getStockSymbol(name)</span><br><span class="line"><span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol)</span><br><span class="line"><span class="keyword">return</span> stockPrice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码是一个获取股票报价的函数，函数前面的async关键字表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p><p>下面这个例子指定了多少毫秒后输出一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">(resolve</span>) =&gt; </span>&#123;</span><br><span class="line">setTimeout(resolve, ms)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> timeout(ms)</span><br><span class="line"><span class="built_in">console</span>.log(valuse)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">"Hello World!"</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//50毫秒后输出, "Hello World!"</span></span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>await命令后面的Promise对象，运行结果可能是Rejected，所以最好把await命令放在try…catch代码块中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">await</span>(</span><br><span class="line"><span class="keyword">await</span> somethingThatReturnAPromise()</span><br><span class="line">)<span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;异步编程对于JavaScript是极为重要的。JavaScript只有一个线程，如果异步编程，得卡死，基本没法用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES6诞生之前，异步编程的方法大概有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数&lt;/li
      
    
    </summary>
    
      <category term="ES6" scheme="https://luoyec.cn/categories/ES6/"/>
    
    
      <category term="异步" scheme="https://luoyec.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="ES6" scheme="https://luoyec.cn/tags/ES6/"/>
    
      <category term="《ES 6标准入门》" scheme="https://luoyec.cn/tags/%E3%80%8AES-6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-插入排序&amp;&amp;习题2.1-3、2.1-4</title>
    <link href="https://luoyec.cn/2017/09/02/cl4e29qgs009q989elgr5li7o/"/>
    <id>https://luoyec.cn/2017/09/02/cl4e29qgs009q989elgr5li7o/</id>
    <published>2017-09-02T07:23:24.000Z</published>
    <updated>2017-09-02T07:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>对于少量排序，它是一个很好的算法。开始时，我们的左手为空，并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中的正确位置。为了找到一张牌的正确位置，我们从右往左将它与已在手中的每张牌比较。如图所示，拿在左手中的牌总是排序好的。</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504225484963.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504225208044.jpg" alt=""></p><h2 id="TypeScript实现"><a href="#TypeScript实现" class="headerlink" title="TypeScript实现"></a>TypeScript实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InsertionSort &#123;</span><br><span class="line">    <span class="keyword">private</span> sortArray: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">A: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sortArray = A</span><br><span class="line">        <span class="keyword">this</span>.insertionSort()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> insertionSort(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.sortArray.length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> key: <span class="built_in">any</span> = <span class="keyword">this</span>.sortArray[j]</span><br><span class="line">            <span class="keyword">let</span> i: <span class="built_in">number</span> = j - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.sortArray[i] &gt; key) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sortArray[i + <span class="number">1</span>] = <span class="keyword">this</span>.sortArray[i]</span><br><span class="line">                i = i - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.sortArray[i + <span class="number">1</span>] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> printSortResult(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.sortArray)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sort = <span class="keyword">new</span> InsertionSort([<span class="number">31</span>, <span class="number">41</span>, <span class="number">59</span>, <span class="number">26</span>, <span class="number">41</span>, <span class="number">58</span>])</span><br><span class="line">sort.printSortResult()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运算结果：</span></span><br><span class="line"><span class="comment">[ 26, 31, 41, 41, 58, 59 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>插入排序的时间复杂度分析。在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + … + (N - 1)，等差数列求和，结果为 N^2 / 2，所以最坏情况下的复杂度为 O(N^2)。</p><p>最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(N)。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="考虑以下查找问题："><a href="#考虑以下查找问题：" class="headerlink" title="考虑以下查找问题："></a>考虑以下查找问题：</h3><p>输入： n个数的一个序列A={ a1, a2, …, an } 和一个值v。<br>输出： 下标i使得v=A[i]或者当v不在A中时，v为特殊值NIL。<br>写出线性查找 的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保循环不变式满足三条必要的性质</p><p>伪代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">LINEAR-SEARCH</span><span class="params">(A, v)</span></span></span><br><span class="line"><span class="number">1</span> <span class="keyword">for</span> <span class="selector-tag">i</span> &lt;- <span class="number">1</span> to len(A)</span><br><span class="line"><span class="number">2</span>     do <span class="keyword">if</span> A[i] == v</span><br><span class="line"><span class="number">3</span>               then return i</span><br><span class="line"><span class="number">4</span> return NIL</span><br></pre></td></tr></table></figure><h3 id="二进制相加"><a href="#二进制相加" class="headerlink" title="二进制相加"></a>二进制相加</h3><p>考虑把两个n位二进制证书加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数和应按二进制形式存储在一个（n+1）元数组中。</p><p>其实就是二进制相加， 用TypeScript实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BinaryAddition &#123;</span><br><span class="line">    <span class="keyword">private</span> A: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">private</span> B: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">private</span> C: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = []</span><br><span class="line">    <span class="keyword">private</span> lastflow: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.binaryAdditionResult()</span><br><span class="line">        <span class="keyword">this</span>.printResult()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> addMethod(a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> r: <span class="built_in">number</span> = a + b + <span class="keyword">this</span>.lastflow</span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastflow = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> r % <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastflow = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> binaryAdditionResult(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n: <span class="built_in">number</span> = <span class="keyword">this</span>.A.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.C[i + <span class="number">1</span>] = <span class="keyword">this</span>.addMethod(<span class="keyword">this</span>.A[i], <span class="keyword">this</span>.B[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.C[<span class="number">0</span>] = <span class="keyword">this</span>.lastflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> printResult(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A  '</span> + <span class="keyword">this</span>.A)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'B  '</span> + <span class="keyword">this</span>.B)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'C  '</span> + <span class="keyword">this</span>.C)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binaryAddition: BinaryAddition = <span class="keyword">new</span> BinaryAddition()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运算结果：</span></span><br><span class="line"><span class="comment">A  1,1,0,0,1,0,1,1,1,0</span></span><br><span class="line"><span class="comment">B  1,1,1,0,1,1,0,1,1,1</span></span><br><span class="line"><span class="comment">C  1,1,0,1,1,1,0,0,1,0,1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于少量排序，它是一个很好的算法。开始时，我们的左手为空，并且桌子上的牌面向下。然后，我们每次从桌
      
    
    </summary>
    
      <category term="算法导论" scheme="https://luoyec.cn/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="https://luoyec.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="习题答案" scheme="https://luoyec.cn/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>算法在计算中的作用</title>
    <link href="https://luoyec.cn/2017/08/30/cl4e29qgp009i989e74x1pjee/"/>
    <id>https://luoyec.cn/2017/08/30/cl4e29qgp009i989e74x1pjee/</id>
    <published>2017-08-30T15:10:01.000Z</published>
    <updated>2017-08-30T15:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？"><a href="#给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？" class="headerlink" title="给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？"></a>给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？</h2><h3 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>假设平面上有p0~p12共13个点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。</p><p>直观地讲，可以把Q中每个点都想象成是露在一块板外的铁钉，那么凸包就是包围这些铁钉的一条拉近了的橡皮绳所构成的形状。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504100387916.jpg" alt=""></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>根据所有的果树的位置，找出一个n边形的最小篱笆，使 得所有果树都包围在篱笆内部，或者在篱笆边沿上。也就是，一组平面上的点，求一个包含所有点的最小的凸多边形。</p><h2 id="除速度外，在真实环境中还可能使用哪些其他有关效率的夺量"><a href="#除速度外，在真实环境中还可能使用哪些其他有关效率的夺量" class="headerlink" title="除速度外，在真实环境中还可能使用哪些其他有关效率的夺量"></a>除速度外，在真实环境中还可能使用哪些其他有关效率的夺量</h2><p>  占用资源的大小（在计算机中可以成为空间），问题解决的程度</p><h2 id="选择一种你以前一直的数据结构，并且讨论其优势和局限"><a href="#选择一种你以前一直的数据结构，并且讨论其优势和局限" class="headerlink" title="选择一种你以前一直的数据结构，并且讨论其优势和局限"></a>选择一种你以前一直的数据结构，并且讨论其优势和局限</h2><p>  栈:后进先出，非常适合于保存程序调用的迒回地址之类的特殊应用（递归调用），缺点是无法进行随机的读写</p><h2 id="最短路径与旅行商问题的相似之处和不同之处"><a href="#最短路径与旅行商问题的相似之处和不同之处" class="headerlink" title="最短路径与旅行商问题的相似之处和不同之处"></a>最短路径与旅行商问题的相似之处和不同之处</h2><p>  相同之处：都是要求出最短总距离</p><p>  不同之处：终点的不同，同时最短路径不需要遍历全部的点，而那个旅行商问题就是需要遍历所有的点的问题</p><p>  商旅问题没有已知的有效算法，然而，我们知道一些算法，他们给朱一个离最小值不太远的总距离。35章中会讨论近似算法问题。</p><h2 id="提供一个问题，其中只有最佳解才行，然后提供一个问题，其中近似最佳的一个解也足够好"><a href="#提供一个问题，其中只有最佳解才行，然后提供一个问题，其中近似最佳的一个解也足够好" class="headerlink" title="提供一个问题，其中只有最佳解才行，然后提供一个问题，其中近似最佳的一个解也足够好"></a>提供一个问题，其中只有最佳解才行，然后提供一个问题，其中近似最佳的一个解也足够好</h2><p>  最短路径、商旅问题</p><h1 id="作为技术的一种算法"><a href="#作为技术的一种算法" class="headerlink" title="作为技术的一种算法"></a>作为技术的一种算法</h1><h2 id="给出在应用层需要算法内同的应用的一个例子，并且讨论设计的算法的功能"><a href="#给出在应用层需要算法内同的应用的一个例子，并且讨论设计的算法的功能" class="headerlink" title="给出在应用层需要算法内同的应用的一个例子，并且讨论设计的算法的功能"></a>给出在应用层需要算法内同的应用的一个例子，并且讨论设计的算法的功能</h2><p>  在一次有 210 人参加的考试结束后，老师需要对平均分迕行计算。假设老师不借助于计算机类的自动工具，而是采取传统的手工计算平均分。<br>计算方法：看过考分后，大概估计一个值K ，然后与 210 个分数的数据迕行比较，找出分数与k的误差ci，如果发现有ci=-ci，则去掉，假设最后的误差和是bi，那么平均分就可以写成K+bi/210.<br>设计的算法的功能：该算法对于计算机返样的自动化计算工具来说意义不大，但是对于手工<br>计算来说，却是很实用的。在计算的过程中，首先把大数转换成了小数，然后在比较<br>时又直接把一些数据剔除，减少了运算量。最终大大加快了计算效率，幵且提高了计<br>算准确度。</p><h2 id="假设我们正在比较插入排序和归并排序在相同机器上面的实现，对于规模为n的输入，插入排序运行8n-2步，而归并排序运行64nlgn步。问对于哪些n值，插入排序优于归并排序？"><a href="#假设我们正在比较插入排序和归并排序在相同机器上面的实现，对于规模为n的输入，插入排序运行8n-2步，而归并排序运行64nlgn步。问对于哪些n值，插入排序优于归并排序？" class="headerlink" title="假设我们正在比较插入排序和归并排序在相同机器上面的实现，对于规模为n的输入，插入排序运行8n^2步，而归并排序运行64nlgn步。问对于哪些n值，插入排序优于归并排序？"></a>假设我们正在比较插入排序和归并排序在相同机器上面的实现，对于规模为n的输入，插入排序运行8n^2步，而归并排序运行64nlgn步。问对于哪些n值，插入排序优于归并排序？</h2><p>答： 令 8n^2 &lt; 64nlgn<br>=&gt; 化简得n &lt; 8lgn<br>=&gt;  2^(n/8) &lt; 2^(lgn)<br>=&gt;    2^(n/8) &lt; n<br>=&gt;    令t=n/8 , n=8t<br>=&gt;    2^t &lt; 8t<br>=&gt;    制表：<br>        1    2    3    4    5    6<br>8t    8  16    24 32  40  48<br>2^t  2  4       8   16  32  64<br>当t=0 8t=0 2^t=1<br>当t=0.2, 8t=1.6 2^t=1.15<br>当t=5.1， 8t=40.8 2^t=34.3<br>当t=5.4, 8t=43.2 2^t=42.2<br>当t=5.5, 8t=44 2^t=45.25<br>所以，当0.2 &lt; t &lt; 5.5时，即1 &lt; n &lt; 44时，插入排序优于归并。</p><h2 id="n的最小值为何值时，运行时间为100n-2的一个算法在相同的机器上面快于运行时间为2-n的另外一个算法"><a href="#n的最小值为何值时，运行时间为100n-2的一个算法在相同的机器上面快于运行时间为2-n的另外一个算法" class="headerlink" title="n的最小值为何值时，运行时间为100n^2的一个算法在相同的机器上面快于运行时间为2^n的另外一个算法"></a>n的最小值为何值时，运行时间为100n^2的一个算法在相同的机器上面快于运行时间为2^n的另外一个算法</h2><p>答：令100n^2&lt;2^n   =&gt;</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504105321209.jpg" alt=""></p><p>由图可得当n&gt;14.325时，满足不等式，又n为正整数，所以n取最小值15。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="运行时间的比较"><a href="#运行时间的比较" class="headerlink" title="运行时间的比较"></a>运行时间的比较</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1504105519611.jpg" alt=""></p><p>答：具体的答案数据就不列出来了，但可以肯定的是，从上到下，算法效率是逐渐降低的，意思是说一个算法若能做到lgn的效率是极佳的，而如果做到n！的话则是最不可取的了。</p><p>参考资料：<br><a href="http://blog.csdn.net/u012577123/article/details/38778457" target="_blank" rel="noopener"> 算法导论1：第一章算法的作用  奕思</a><br><a href="http://www.cnblogs.com/vc_zgj/p/4313800.html" target="_blank" rel="noopener">第一章 算法在计算机中的应用 技术老鸟</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？&quot;&gt;&lt;a href=&quot;#给出现实生活中需要排序的一个例子或者
      
    
    </summary>
    
      <category term="算法导论" scheme="https://luoyec.cn/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="https://luoyec.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="习题答案" scheme="https://luoyec.cn/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Egret MVC通用框架HTTP请求实践（GET请求）</title>
    <link href="https://luoyec.cn/2017/08/29/cl4e29qby000j989eqw9wmoa2/"/>
    <id>https://luoyec.cn/2017/08/29/cl4e29qby000j989eqw9wmoa2/</id>
    <published>2017-08-29T09:31:52.000Z</published>
    <updated>2017-08-29T09:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="http://developer.egret.com/cn/github/egret-docs/extension/game/URLLoaderNetwork/index.html" target="_blank" rel="noopener">URLLoader网络通讯</a><br><a href="http://bbs.egret.com/forum.php?mod=viewthread&amp;tid=14929&amp;highlight=%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">Egret游戏通用开发框架–MVC篇</a></p><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>  在原有MVC的基础上， 增加了一层Proxy用于进行通信。</p><ul><li>BaseModel，是Model的基类，负责该Module的数据存储，每个Module只存在一个Model</li></ul><ul><li>BaseGuiView、BaseSpriteView，是View的基类，都实现了IBaseView接口，负责该Module的View层显示及View层的基础逻辑，两个类的不同在于，BaseGuiView继承自egret.gui.SkinnableContainer，用于使用GUI的View，BaseSpriteView继承自egret.Sprite，用于不使用GUI的View，每个Module可以有多个View</li></ul><ul><li>BaseController，是Controller的基类，负责Module内部、Module与Module之间的事件交互，每个Module只存在一个Controller</li></ul><ul><li>BaseProxy，是Proxy的基类，负责该Module与服务器的数据通信交互，支持Http和WebSocket</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="财富榜实例文件结构"><a href="#财富榜实例文件结构" class="headerlink" title="财富榜实例文件结构"></a>财富榜实例文件结构</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503997302487.jpg" alt=""></p><h2 id="如何请求数据"><a href="#如何请求数据" class="headerlink" title="如何请求数据"></a>如何请求数据</h2><p>在Controller构造函数中初始化模块内的View、Proxy、Model，并且注册模块内、模块内部事件监听</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.registerFunc(JackWealthConst.GAMERANKING_C2S, <span class="keyword">this</span>.getGameRanking, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.registerFunc(JackWealthConst.GAMERANKING_S2C, <span class="keyword">this</span>.getGameRankingSuccess, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getGameRanking()方法中，调用Proxy的方法，用以HTTP请求，此时需要获取到GET请求所需的参数，这里只需要获取gameID</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求获取财富值排行榜处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> getGameRanking(): <span class="built_in">void</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> userInfo:<span class="built_in">any</span> = egret.localStorage.getItem(JackGameConst.Get_User_Information)</span><br><span class="line">       <span class="keyword">let</span> gameId:<span class="built_in">string</span> = <span class="built_in">JSON</span>.parse(userInfo).gameId</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.jackWealthProxy.getGameRanking(gameId)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy.ts</span></span><br><span class="line"><span class="keyword">public</span> getGameRanking(gameId: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">let</span> param: <span class="built_in">string</span> = <span class="string">`/gameRanking?gameId=<span class="subst">$&#123;gameId&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.getHttpMsg(HttpConst.JACK_GAME_RANKING, param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Proxy中，需要注册从服务器返回的消息监听，并有相应的处理函数，用以通知Controller数据请求成功</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JackWealthProxy <span class="keyword">extends</span> BaseProxy &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">$controller: BaseController</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>($controller);</span><br><span class="line"><span class="comment">//注册从服务器返回消息的监听</span></span><br><span class="line"><span class="keyword">this</span>.receiveServerMsg(HttpConst.JACK_GAME_RANKING, <span class="keyword">this</span>.getGameRankingSuccess, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> getGameRanking(gameId: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">let</span> param: <span class="built_in">string</span> = <span class="string">`/gameRanking?gameId=<span class="subst">$&#123;gameId&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.getHttpMsg(HttpConst.JACK_GAME_RANKING, param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> getGameRankingSuccess(obj: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.applyFunc(JackWealthConst.GAMERANKING_S2C, obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据请求成功"><a href="#数据请求成功" class="headerlink" title="数据请求成功"></a>数据请求成功</h2><p>在Controller中已经注册了监听到数据请求成功的处理函数，在该处理函数中完成模块所需的逻辑处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求获取财富值排行榜成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> getGameRankingSuccess(gameRanking: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">//保存数据</span></span><br><span class="line">    <span class="keyword">this</span>.jackWealthModel.gameRanking = gameRanking</span><br><span class="line">    <span class="comment">//本模块UI的处理</span></span><br><span class="line">    <span class="keyword">this</span>.addItemToWealth()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展框架的HTTP请求"><a href="#扩展框架的HTTP请求" class="headerlink" title="扩展框架的HTTP请求"></a>扩展框架的HTTP请求</h1><p>框架原有的请求方法中，只写了POST（可能有误？）</p><p>参考<a href="http://developer.egret.com/cn/github/egret-docs/extension/game/URLLoaderNetwork/index.html" target="_blank" rel="noopener">URLLoader网络通讯</a></p><h2 id="修改-core-net-http-Http-ts"><a href="#修改-core-net-http-Http-ts" class="headerlink" title="修改 /core/net/http/Http.ts"></a>修改 /core/net/http/Http.ts</h2><p>增加所需要的属性</p><blockquote><p>当我们需要创建一个网络连接的时候，我们需要创建一个 URLLoader 对象，该对象负责网络的连接状态操作， 同时负责接收网络回传的数据。网络通信时，需要的网络通信数据由 URLRequest 对象负责管理。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET请求相关属性</span></span><br><span class="line"><span class="keyword">private</span> _getRequest: egret.URLRequest  <span class="comment">//URL请求对象</span></span><br><span class="line"><span class="keyword">private</span> _getCache: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;<span class="comment">//请求缓存，其实数组，实现按顺序请求</span></span><br><span class="line"><span class="keyword">private</span> _isGetRequesting: <span class="built_in">boolean</span>  <span class="comment">//是否在请求的标志符</span></span><br><span class="line"><span class="keyword">private</span> _urlGetLoader: egret.URLLoader;  <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>初始化属性和添加事件监听</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._getRequest = <span class="keyword">new</span> egret.URLRequest()</span><br><span class="line"><span class="keyword">this</span>._getRequest.method = egret.URLRequestMethod.GET</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._getCache = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._urlGetLoader = <span class="keyword">new</span> egret.URLLoader()</span><br><span class="line"><span class="keyword">this</span>._urlGetLoader.addEventListener(egret.IOErrorEvent.IO_ERROR, <span class="keyword">this</span>.onGetError, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>核心方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加HTTP  GET请求数据方法 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> getData(<span class="keyword">type</span>: <span class="built_in">string</span>, param: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._getCache.push([<span class="keyword">type</span>, param])</span><br><span class="line">    <span class="keyword">this</span>.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">get</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._isGetRequesting) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._getCache.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = <span class="keyword">this</span>._getCache.shift()</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">type</span>: <span class="built_in">string</span> = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> getparam: <span class="built_in">string</span> = arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>._type = <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._getRequest.url = <span class="keyword">this</span>._serverUrl + getparam</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._urlGetLoader.addEventListener(egret.Event.COMPLETE, <span class="keyword">this</span>.onGetLoaderComplete, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>._urlGetLoader.load(<span class="keyword">this</span>._getRequest)</span><br><span class="line">    <span class="keyword">this</span>._isGetRequesting = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功之后需要派发相应事件，需要注意的这个时间的类型，就是之前在Proxy方法中参数的 <code>this.getHttpMsg(HttpConst.JACK_GAME_RANKING, param)</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> onGetLoaderComplete(event: egret.Event): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._urlGetLoader.removeEventListener(egret.Event.COMPLETE, <span class="keyword">this</span>.onGetLoaderComplete, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> msg: <span class="built_in">any</span> = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>._urlGetLoader.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">        App.MessageCenter.dispatch(<span class="keyword">this</span>._type, msg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.trace(<span class="string">"Http错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.nextGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派发事件后，在相应注册了事件监听Controller中就能拿到请求成功的数据<code>msg</code>了，用以保存到Model、通知view进行相应的数据渲染</p><h1 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h1><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503998792642.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;http://developer.egret.com/cn/github/egret-docs/extension/game/URLLoaderNetwork/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="Egret" scheme="https://luoyec.cn/categories/Egret/"/>
    
    
      <category term="HTTP" scheme="https://luoyec.cn/tags/HTTP/"/>
    
      <category term="Egret" scheme="https://luoyec.cn/tags/Egret/"/>
    
      <category term="MVC" scheme="https://luoyec.cn/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（15）</title>
    <link href="https://luoyec.cn/2017/08/26/cl4e29qeu0068989eaxg0bxqk/"/>
    <id>https://luoyec.cn/2017/08/26/cl4e29qeu0068989eaxg0bxqk/</id>
    <published>2017-08-26T04:03:04.000Z</published>
    <updated>2017-08-26T04:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>创建一个软件系统时，实际上是对一个真实系统建模。</p></blockquote><p>设计模式的基本概念以最佳实践原则为中心。所谓最佳实践，当创建好的、高效的解决方案时，这些解决方案会以某种方式记录下来，使其他人能够从先前已取得的成功获益——当然也包括从以往的失败学习。</p><h2 id="为什么研究设计模式"><a href="#为什么研究设计模式" class="headerlink" title="为什么研究设计模式"></a>为什么研究设计模式</h2><blockquote><p>每个模式都描述了在我们环境中反复出现的一个问题，然后介绍这个问题解决方案的核心，以便多次使用这个解决方案，而不必反复地重复工作。</p></blockquote><h3 id="模式的四大要素"><a href="#模式的四大要素" class="headerlink" title="模式的四大要素"></a>模式的四大要素</h3><ul><li><p>模式名是描述一个设计问题</p></li><li><p>问题描述了何时应用这种模式</p></li><li></li><li>解决方案描述了构成设计的元素，以及元素之间的关系、元素的职责和协作</li><li></li><li>结果描述应用这种模式的结果和开销</li></ul><h2 id="模型-视图-控制器（MVC）"><a href="#模型-视图-控制器（MVC）" class="headerlink" title="模型/视图/控制器（MVC）"></a>模型/视图/控制器（MVC）</h2><blockquote><p>《设计模式》将MVC组件定义如下：模型是应用对象，视图是屏幕表示，而控制器定义了用户界面与用户输入之间的交互方法。</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503719498707.jpg" alt=""></p><h2 id="设计模式的不同类型"><a href="#设计模式的不同类型" class="headerlink" title="设计模式的不同类型"></a>设计模式的不同类型</h2><ul><li>创建型模式：这些模式为你创建对象，而不是由你直接实例化对象。这样在确定给定情况下需要创建哪些对象时，程序会有更多的灵活性</li><li>结构性模式：可以帮助你将多组对象组合为更多的结构，如果复杂用户界面或审计数据</li><li>行为型模式：帮助你定义系统中对象之间的通信，以及复杂程序中如何控制数据流</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul><li>抽象工厂模式</li><li>生成器模式</li><li>工厂方法模式</li><li>原型模式</li><li>单例模式</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰器模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul><li>职责链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单介绍设计模式，及《设计模式》中列举的模式类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;创建一个软件系统时，实际上是对一个真实系统建模。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计模
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（9）</title>
    <link href="https://luoyec.cn/2017/08/26/cl4e29qf80070989eni89i2bp/"/>
    <id>https://luoyec.cn/2017/08/26/cl4e29qf80070989eni89i2bp/</id>
    <published>2017-08-26T03:36:02.000Z</published>
    <updated>2017-08-26T04:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><p>前面主要的内容是继承、接口、抽象类和组合如果结合使用。本章主要关于整体设计中对象之间如何关联的问题。</p><p>继承和组合在构建对象上的方式有显著区别，使用继承是，结果是单个类，其中覆盖继承层次结构中的所有行为和属性。而使用组合时，会使用一个或者多个类来构建另一个类。</p><h2 id="使用组合"><a href="#使用组合" class="headerlink" title="使用组合"></a>使用组合</h2><p>使用组合的原因，可以通过结合不太复杂的部分来构建系统。</p><h2 id="分阶段构建"><a href="#分阶段构建" class="headerlink" title="分阶段构建"></a>分阶段构建</h2><blockquote><p>要构建高质量的软件，必须遵守的一条最高原则才能成功：尽可能成功。要让软件系统正常地工作而且易于维护，它们必须分解为较小、更可管理的部分。</p></blockquote><p>诺贝尔得主Herbert Simon对稳定系统的观点：</p><ul><li><p>“稳定的复杂系统通常采用一种层次结构的形式，其中各个系统都是由更简单的子系统构成，而各个子系统则由更贱的下一级子系统构成”</p></li><li><p>“稳定的复杂系统几乎都是可以分解的”</p></li><li><p>“稳定的复杂系统几乎总是由几个不同类型的子系统组成，并以不同的结合方式组织”</p></li><li><p>“能正常工作的稳定系统几乎总是由能正常工作的简单系统发展而来”</p></li></ul><h2 id="不同类型的组合"><a href="#不同类型的组合" class="headerlink" title="不同类型的组合"></a>不同类型的组合</h2><p>一般来说，组合有两种类型：关联和聚集</p><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><p>聚集是指一个复杂对象由其他对象组成。</p><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>当一个对象希望另一个对象为它完成某个服务时则使用关联。</p><h3 id="结合使用关联和聚集"><a href="#结合使用关联和聚集" class="headerlink" title="结合使用关联和聚集"></a>结合使用关联和聚集</h3><blockquote><p>与以往一样，做设计决策时并没有一种绝对正确的答案。设计不是精确的科学，尽管我们可以遵守一些一般规则，但是这些规则并不是硬性规定。</p></blockquote><h2 id="避免依赖性"><a href="#避免依赖性" class="headerlink" title="避免依赖性"></a>避免依赖性</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>聚集和关联。继承表示在现有对象基础上创建新对象，而组合表示不同对象之间的交互。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建对象&quot;&gt;&lt;a href=&quot;#构建对象&quot; class=&quot;headerlink&quot; title=&quot;构建对象&quot;&gt;&lt;/a&gt;构建对象&lt;/h2&gt;&lt;p&gt;前面主要的内容是继承、接口、抽象类和组合如果结合使用。本章主要关于整体设计中对象之间如何关联的问题。&lt;/p&gt;
&lt;p&gt;继承和组
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（8）</title>
    <link href="https://luoyec.cn/2017/08/26/cl4e29qf6006v989edd702605/"/>
    <id>https://luoyec.cn/2017/08/26/cl4e29qf6006v989edd702605/</id>
    <published>2017-08-26T03:05:58.000Z</published>
    <updated>2017-08-26T03:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架与重用：-使用接口和抽象类实现设计"><a href="#框架与重用：-使用接口和抽象类实现设计" class="headerlink" title="框架与重用： 使用接口和抽象类实现设计"></a>框架与重用： 使用接口和抽象类实现设计</h2><p>本章讨论代码重用、框架、契约、接口和抽象类等主题</p><h2 id="代码：重用还是不重用"><a href="#代码：重用还是不重用" class="headerlink" title="代码：重用还是不重用"></a>代码：重用还是不重用</h2><p>OO方法提供了一些机制，有利于可重用diamante的开发。创建可重用代码的一种方法就是创建框架。本章将重点讨论如何使用接口和抽象类来创建框架，并促进重用diamante开发。</p><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><p>框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法; 另一种定义认为，框架是可被应用开发者定制的应用骨架。</p><h2 id="什么是契约"><a href="#什么是契约" class="headerlink" title="什么是契约"></a>什么是契约</h2><p>契约是要求开发人员遵守应用编程接口规范所需的机制。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>实现契约的一种方法是通过抽象类来实现；。抽象类（abstract class）包含一个或者多个没有提供任何具体实现的方法。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503571034222.jpg" alt=""></p><p>采用这种只有声明而没有实现的方法，可以实现多态。在实例化的对象中重写父类的方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口并没有被声明为一个类，接口包含了抽象方法，这些方法中没有实现。也可以说，接口不提供任何实现。<br>因此，实现了接口的任何类都必须提供所有的方法的实现。</p><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>问题：抽象类可以同时提供抽象方法和具体方法，而接口之鞥呢提供抽象方法。为什么会存在这一个区别？</p><p>继承时建立在密切的联系的继承上，而接口并没有这种联系。<br>抽象类表示某种实现，但是接口并不会提供任何类型的实现，只提供行为，说明是一个说明方法。<br>所以接口可以独立在抽象类之外而不受的类的制约，在需要的时候都可以实现接口。</p><h3 id="编译器的证明"><a href="#编译器的证明" class="headerlink" title="编译器的证明"></a>编译器的证明</h3><h3 id="建立契约定"><a href="#建立契约定" class="headerlink" title="建立契约定"></a>建立契约定</h3><p>定义契约的简单规则是提供一个未实现的方法，可以通过抽象类提供，也可以通过接口提供。因此，当设计一个子类来实现某个契约时，它必须为父类或接口中未实现的方法提供实现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>设计了和对象模型时，最为重要的是理解对象直接如何关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;框架与重用：-使用接口和抽象类实现设计&quot;&gt;&lt;a href=&quot;#框架与重用：-使用接口和抽象类实现设计&quot; class=&quot;headerlink&quot; title=&quot;框架与重用： 使用接口和抽象类实现设计&quot;&gt;&lt;/a&gt;框架与重用： 使用接口和抽象类实现设计&lt;/h2&gt;&lt;p&gt;本章
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（7）</title>
    <link href="https://luoyec.cn/2017/08/23/cl4e29qf5006s989ei0ux5eqk/"/>
    <id>https://luoyec.cn/2017/08/23/cl4e29qf5006s989ei0ux5eqk/</id>
    <published>2017-08-23T14:27:46.000Z</published>
    <updated>2017-08-23T14:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="掌握继承和组合"><a href="#掌握继承和组合" class="headerlink" title="掌握继承和组合"></a>掌握继承和组合</h2><p>继承和组合都是实现重用的机制。</p><ul><li>继承（inheritance）是指从其他类继承属性和行为。</li><li>组合（subclass）是指使用其他对象来构建对象。</li></ul><h2 id="重用对象"><a href="#重用对象" class="headerlink" title="重用对象"></a>重用对象</h2><p>最根本的是，继承和组合都是构建OO系统的重要技术。只是设计人员和开发人员需要花时间来了解这两种技术的优点和缺点，并在合适的情况下正确加以使用。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="一般化与特殊化"><a href="#一般化与特殊化" class="headerlink" title="一般化与特殊化"></a>一般化与特殊化</h3><p>其思想是，逐步向下建立继承树时对象会越来越具体。</p><h3 id="设计决策"><a href="#设计决策" class="headerlink" title="设计决策"></a>设计决策</h3><p>设计时要保证更低的复杂性还是提供更多的功能？</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>如果某个对象由其他对象组成，而这些对象作为字段包含在内，在这个新对象就称为复合对象（compound object）、聚合对象（aggregate object）或组合对象（composite object）</p><p>一个很经典的机车的例子：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-23%20%E4%B8%8B%E5%8D%8810.15.16.png" alt="" title="屏幕快照 2017-08-23 下午10.15.16"></p><h2 id="为什么封装在OO中如此重要"><a href="#为什么封装在OO中如此重要" class="headerlink" title="为什么封装在OO中如此重要"></a>为什么封装在OO中如此重要</h2><h3 id="继承如何削弱封装"><a href="#继承如何削弱封装" class="headerlink" title="继承如何削弱封装"></a>继承如何削弱封装</h3><p>  问题在于，如果从一个父类继承一个实现，然后修改这个实现，那么父类的修改会对整个类层次结构产生涟漪作用。这种涟漪效应可能会影响所有的子类。</p><p>  严格设计好继承关系是解决这个问题的方法。</p><h3 id="多态的一个详细例子"><a href="#多态的一个详细例子" class="headerlink" title="多态的一个详细例子"></a>多态的一个详细例子</h3><p>  多态的字面含义是多种形状，将一条消息发送给一个对象时，这个对象必须定义相应的方法对这个消息做出响应。</p><h3 id="对象职责"><a href="#对象职责" class="headerlink" title="对象职责"></a>对象职责</h3><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  组合在大多数情况下都比继承更适用，不过这不并不意味着继承一无是处，组合和继承都可以使用，但只应该在其适当的上下文中使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;掌握继承和组合&quot;&gt;&lt;a href=&quot;#掌握继承和组合&quot; class=&quot;headerlink&quot; title=&quot;掌握继承和组合&quot;&gt;&lt;/a&gt;掌握继承和组合&lt;/h2&gt;&lt;p&gt;继承和组合都是实现重用的机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承（inheritance）是指从其他类
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（6）</title>
    <link href="https://luoyec.cn/2017/08/23/cl4e29qf3006o989ezxd0thr3/"/>
    <id>https://luoyec.cn/2017/08/23/cl4e29qf3006o989ezxd0thr3/</id>
    <published>2017-08-23T13:51:17.000Z</published>
    <updated>2017-08-23T13:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用对象实现设计"><a href="#利用对象实现设计" class="headerlink" title="利用对象实现设计"></a>利用对象实现设计</h2><p>本章的重点是介绍如何设计好的系统。</p><h2 id="设计指导原则"><a href="#设计指导原则" class="headerlink" title="设计指导原则"></a>设计指导原则</h2><p>一般的一个可靠的OO设计过程包括以下步骤：</p><ul><li>完成适当的分析</li><li>建立一份描述系统的工作陈述</li><li>从这个工作陈述中收集需求</li><li>开发一个用户界面原型</li><li>明确类</li><li>确定各个类的职责</li><li>确定各个类如何互相交互</li><li>创建一个高层模型来描述要构建的系统</li></ul><p>本章主要关注最后一点，系统或者对象模型由类图和类交互构成。这个模型应当真实地表示系统，而且要易于理解和修改。</p><h3 id="完成适当的分析"><a href="#完成适当的分析" class="headerlink" title="完成适当的分析"></a>完成适当的分析</h3><p>设计阶段的重点则是要让每个人都了解系统（包括老系统和新的系统），并确定系统需求。</p><h3 id="建立工作陈述"><a href="#建立工作陈述" class="headerlink" title="建立工作陈述"></a>建立工作陈述</h3><p>工作陈述（statement of work，SOW）是一个描述系统的文档。</p><h3 id="收集需求"><a href="#收集需求" class="headerlink" title="收集需求"></a>收集需求</h3><p>需求文档（requirements document）描述了用户系统系统做什么。需求是必须实现的系统的最终描述，软件开发过程中的所有文档都要以这些需求为基础。</p><h3 id="开发用户界面原型"><a href="#开发用户界面原型" class="headerlink" title="开发用户界面原型"></a>开发用户界面原型</h3><h3 id="明确类"><a href="#明确类" class="headerlink" title="明确类"></a>明确类</h3><p>重点标记所有名词。</p><h3 id="确定各个类的职责"><a href="#确定各个类的职责" class="headerlink" title="确定各个类的职责"></a>确定各个类的职责</h3><h3 id="确定各个类如何互相交互"><a href="#确定各个类如何互相交互" class="headerlink" title="确定各个类如何互相交互"></a>确定各个类如何互相交互</h3><h3 id="创建一个高层模型来描述要构建的系统"><a href="#创建一个高层模型来描述要构建的系统" class="headerlink" title="创建一个高层模型来描述要构建的系统"></a>创建一个高层模型来描述要构建的系统</h3><p>既然已经确定了所有类，而且列出了类职责并明确了类如何协作，下面就可以构建一个类模型来标识完成系统。</p><p>将使用UML对系统建模。</p><h2 id="案例研究：-blackjack"><a href="#案例研究：-blackjack" class="headerlink" title="案例研究： blackjack"></a>案例研究： blackjack</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503452097785.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用对象实现设计&quot;&gt;&lt;a href=&quot;#利用对象实现设计&quot; class=&quot;headerlink&quot; title=&quot;利用对象实现设计&quot;&gt;&lt;/a&gt;利用对象实现设计&lt;/h2&gt;&lt;p&gt;本章的重点是介绍如何设计好的系统。&lt;/p&gt;
&lt;h2 id=&quot;设计指导原则&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（5）</title>
    <link href="https://luoyec.cn/2017/08/23/cl4e29qf1006m989ez4s8uj5m/"/>
    <id>https://luoyec.cn/2017/08/23/cl4e29qf1006m989ez4s8uj5m/</id>
    <published>2017-08-22T16:31:50.000Z</published>
    <updated>2017-08-22T16:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类设计指导原则"><a href="#类设计指导原则" class="headerlink" title="类设计指导原则"></a>类设计指导原则</h2><p>本章为如何设计健壮的类提供一些建议。</p><h2 id="真实世界系统建模"><a href="#真实世界系统建模" class="headerlink" title="真实世界系统建模"></a>真实世界系统建模</h2><p>面向对象（OO）程序设计的主要目标之一就是以类似于人们真正的思维方式对真实世界的系统建模。设计类就是创建这些模型的面向对象方式。</p><p>第一次转向OO开发时，许多人倾向于采用一种结构化的方式思考。由此导致主要的错误之一就是创建的类只包含行为而没有数据。实际上，他们创建的只是结构化模型的一组函数或子例程。</p><h2 id="明确公共接口"><a href="#明确公共接口" class="headerlink" title="明确公共接口"></a>明确公共接口</h2><p>设计类时，最重要的问题可能就是保证公共接口的最小。构建类的根本目的就是提供一些有用而且简洁的功能。</p><h3 id="最小接口"><a href="#最小接口" class="headerlink" title="最小接口"></a>最小接口</h3><p>提供最小接口可以使类尽可能简洁。</p><blockquote><p>扩展接口<br>对于一个特定应用，及时一个类的公共接口还不够，使用对象技术也能很容易的利用继承扩展并调整这个接口。简单来讲，如何设计时考虑到继承，新类可以继承一个原有的类，从而创建一个有扩展接口的新类。</p></blockquote><h3 id="隐藏实现"><a href="#隐藏实现" class="headerlink" title="隐藏实现"></a>隐藏实现</h3><h2 id="设计健壮的构造函数（和析构函数）"><a href="#设计健壮的构造函数（和析构函数）" class="headerlink" title="设计健壮的构造函数（和析构函数）"></a>设计健壮的构造函数（和析构函数）</h2><p>首先，也是最重要的，构造函数应当将对象置于一种安全的初始状态。这包括属性初始化和内存管理等问题。</p><p>析构函数要包含适当的清理功能。</p><blockquote><p>内存泄露<br>如果一个对象未能适当地释放它在对象生存周期中获得的内存，那么只要创建这个对象这个对象的应用还在执行，对于整个操作系统来说这部分内容就丢失了。在极端情况，消耗掉系统所有可用的内存。</p></blockquote><h2 id="在类中设计的错误处理"><a href="#在类中设计的错误处理" class="headerlink" title="在类中设计的错误处理"></a>在类中设计的错误处理</h2><h3 id="对类建立文档以及使用注释"><a href="#对类建立文档以及使用注释" class="headerlink" title="对类建立文档以及使用注释"></a>对类建立文档以及使用注释</h3><blockquote><p>过多的文档<br>要注意，如果注释过多也会有问题，看起来很杂乱，有可能影响建立文档的初衷</p></blockquote><h3 id="构建类要以合作为出发点"><a href="#构建类要以合作为出发点" class="headerlink" title="构建类要以合作为出发点"></a>构建类要以合作为出发点</h3><h2 id="设计时充分考虑重用"><a href="#设计时充分考虑重用" class="headerlink" title="设计时充分考虑重用"></a>设计时充分考虑重用</h2><h2 id="设计时充分考虑到可扩展性"><a href="#设计时充分考虑到可扩展性" class="headerlink" title="设计时充分考虑到可扩展性"></a>设计时充分考虑到可扩展性</h2><p>为一个类增加新特性可能很简单，只需扩展一个现有的类，增加一些新方法，并修改其他方法的行为。不必重写代码。这里使用继承。</p><h3 id="名字要有描述性"><a href="#名字要有描述性" class="headerlink" title="名字要有描述性"></a>名字要有描述性</h3><blockquote><p>好的命名<br>确保坚持一种命名约定很有意义。使名字具有描述性是一个很好的开发实践，这在各种开发泛型中都使用。</p></blockquote><h3 id="抽出不可移植的代码"><a href="#抽出不可移植的代码" class="headerlink" title="抽出不可移植的代码"></a>抽出不可移植的代码</h3><p>将这些不可移植的代码单独放在一个类中，或者至少放在一个方法中。</p><h3 id="提供一种复制和比较对象的方法"><a href="#提供一种复制和比较对象的方法" class="headerlink" title="提供一种复制和比较对象的方法"></a>提供一种复制和比较对象的方法</h3><h3 id="让作用域尽可能小"><a href="#让作用域尽可能小" class="headerlink" title="让作用域尽可能小"></a>让作用域尽可能小</h3><p>这种思想是尽可能将属性和行为置于局部。采用这种方式，维护、测试和扩展类就会容易很多。</p><h3 id="类应当对自己负责"><a href="#类应当对自己负责" class="headerlink" title="类应当对自己负责"></a>类应当对自己负责</h3><p>类的设计原则是：所有对象都应当尽可能自行负责自己的行为。</p><h2 id="设计时充分考虑可维护性"><a href="#设计时充分考虑可维护性" class="headerlink" title="设计时充分考虑可维护性"></a>设计时充分考虑可维护性</h2><p>一个类中的修改不会对其他类产生影响，或者影响尽可能小。</p><blockquote><p>高度耦合的类<br>彼此相当依赖的类被认为是高度耦合（highly coupled）。因此对一个类的修改还要求对另一个类进行修改，这两个类就是高度耦合的。没有这种依赖关系的耦合度很低。</p></blockquote><h3 id="采用迭代"><a href="#采用迭代" class="headerlink" title="采用迭代"></a>采用迭代</h3><p>类设计推荐一种迭代过程，这与提供最小接口的概念恰好一致。</p><h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h3><h2 id="使对象持久性"><a href="#使对象持久性" class="headerlink" title="使对象持久性"></a>使对象持久性</h2><p>保存对象状态以备以后使用的三种方法：</p><ul><li>平面文件系统：可以通过串行化对象将对象保存在一个平面文件中</li><li>关系数据库：必须使用某种中间件将对象转换成关系模型</li><li>OO数据库：这是保证对象持久化的最合理的做法</li></ul><h3 id="对象串行化和封送"><a href="#对象串行化和封送" class="headerlink" title="对象串行化和封送"></a>对象串行化和封送</h3><p>通过网络发送一个对象，然后在另一端重新合成。这个过程成为串行化（serializing）一个对象。通过网络发送对象的行为称为封送（marshaling）一个对象。</p><p>主要的问题是，串行化和反串行化都必须使用相同的规范。这有些类似于加密算法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章提供了许多指导原则。一类不会独立存在，类必须设计与其他类交互。彼此交互的一组类会作为系统的一部分。最后，再由这些系统为最终用户提供服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类设计指导原则&quot;&gt;&lt;a href=&quot;#类设计指导原则&quot; class=&quot;headerlink&quot; title=&quot;类设计指导原则&quot;&gt;&lt;/a&gt;类设计指导原则&lt;/h2&gt;&lt;p&gt;本章为如何设计健壮的类提供一些建议。&lt;/p&gt;
&lt;h2 id=&quot;真实世界系统建模&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="OO" scheme="https://luoyec.cn/tags/OO/"/>
    
  </entry>
  
  <entry>
    <title>Egret 图片缓动动画实现</title>
    <link href="https://luoyec.cn/2017/08/22/cl4e29qc2000r989eschd660i/"/>
    <id>https://luoyec.cn/2017/08/22/cl4e29qc2000r989eschd660i/</id>
    <published>2017-08-22T10:18:36.000Z</published>
    <updated>2017-08-22T10:18:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://developer.egret.com/cn/github/egret-docs/extension/tween/tween/index.html" target="_blank" rel="noopener">参考官方缓动动画文档</a><br><a href="http://developer.egret.com/cn/example/egret2d/index.html#070-tween-basic" target="_blank" rel="noopener">参考官方实例演示</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>egret中实现动画的方式，有几种，缓动动画、关键帧、序列帧、龙骨动画。<br>在不同场景下可以选择适合的动画实现方式。这里只介绍缓动动画。</p><blockquote><p>通常情况下，游戏中或多或少都会带有一些缓动动画。例如界面弹出，或者道具飞入飞&gt;出的特效等等。在制作这些缓动动画的时候我们仅仅 希望简单的办法实现这种移动或者&gt;变形缩放的效果。Egret中的 Tween 缓动动画类就为我们提供了相关的功能。</p></blockquote><h1 id="添加tween模块"><a href="#添加tween模块" class="headerlink" title="添加tween模块"></a>添加tween模块</h1><p>从Egret 2.5 开始，以官方扩展模块的形式支持 Tween 。在现有的 Egret 项目中，修改egretProperties.json中的modules，添加 tween 模块：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"tween"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目所在目录内执行一次引擎编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egret build -e</span><br></pre></td></tr></table></figure><p>本步骤已经完成，现在项目中既可以使用 Tween 相关的API了。</p><h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1><p>  只有当所需的资源加载完成之后才能获取资源，并赋予动画。<br>  使用通用MVC框架，这里简单介绍其资源加载策略。</p><p>  以下为部分代码</p><p>main.ts<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Main <span class="keyword">extends</span> egret.DisplayObjectContainer &#123;</span><br><span class="line">        <span class="comment">//初始化场景及模块</span></span><br><span class="line">        <span class="keyword">this</span>.initScene();</span><br><span class="line">        <span class="keyword">this</span>.initModule();</span><br><span class="line"></span><br><span class="line">        App.SceneManager.runScene(SceneConsts.LOADING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载资源版本号</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            App.ResVersionManager.loadConfig(<span class="string">"resource/resource_version.json"</span>, <span class="keyword">this</span>.loadResVersionComplate, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadResVersionComplate();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> loadResVersionComplate(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">//初始化Resource资源加载库（这里加载自动以的资源配置方案，如龙骨动画资源、框架核心资源），静态资源加载完成事件</span></span><br><span class="line">        App.ResourceUtils.addConfig(<span class="string">"resource/default.res.json"</span>, <span class="string">"resource/"</span>);</span><br><span class="line">        App.ResourceUtils.addConfig(<span class="string">"resource/resource_core.json"</span>, <span class="string">"resource/"</span>);</span><br><span class="line">        App.ResourceUtils.addConfig(<span class="string">"resource/resource_ui.json"</span>, <span class="string">"resource/"</span>);</span><br><span class="line">        App.ResourceUtils.addConfig(<span class="string">"resource/resource_battle.json"</span>, <span class="string">"resource/"</span>);</span><br><span class="line">        App.ResourceUtils.loadConfig(<span class="keyword">this</span>.onConfigComplete, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件加载完成,开始预加载preload资源组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onConfigComplete(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">//加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。</span></span><br><span class="line">        <span class="keyword">var</span> theme = <span class="keyword">new</span> eui.Theme(<span class="string">"resource/default.thm.json"</span>, <span class="keyword">this</span>.stage);</span><br><span class="line">        theme.addEventListener(eui.UIEvent.COMPLETE, <span class="keyword">this</span>.onThemeLoadComplete, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主题文件加载完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onThemeLoadComplete(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> BlackJack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BlackJack.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> BlackJack &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> groupName: <span class="built_in">string</span> = <span class="string">"preload"</span></span><br><span class="line"><span class="comment">//此处将页面所需的资源分组加载，加载完成后就能拿到图片以实现动画啦</span></span><br><span class="line">        <span class="keyword">var</span> subGroups: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">"preload_core"</span>, <span class="string">"preload_ui"</span>, <span class="string">"welcome"</span>]</span><br><span class="line">        App.ResourceUtils.loadGroups(groupName, subGroups, <span class="keyword">this</span>.onResourceLoadComplete, <span class="keyword">this</span>.onResourceLoadProgress, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> onResourceLoadComplete(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.initModule()</span><br><span class="line">        App.Init()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//音乐音效处理</span></span><br><span class="line">        App.SoundManager.setBgOn(<span class="literal">true</span>)</span><br><span class="line">        App.SoundManager.setEffectOn(!App.DeviceUtils.IsHtml5 || !App.DeviceUtils.IsMobile)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//场景管理 有三类场景</span></span><br><span class="line">        App.SceneManager.runScene(SceneConsts.UI)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> onResourceLoadProgress(itemsLoaded: <span class="built_in">number</span>, itemsTotal: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        App.ControllerManager.applyFunc(ControllerConst.JackLoading, LoadingConst.SetProgress, itemsLoaded, itemsTotal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化所有模块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> initModule(): <span class="built_in">void</span> &#123;</span><br><span class="line">        App.ControllerManager.register(ControllerConst.JackWelcome, <span class="keyword">new</span> JackWelcomeConstroller())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JackWelcomeConstroller.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化view模块，并注册到全局的view管理器中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> JackWelcomeConstroller <span class="keyword">extends</span> BaseController &#123;</span><br><span class="line">    <span class="keyword">private</span> jackWelcomeView: JackWelcomeView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.jackWelcomeView = <span class="keyword">new</span> JackWelcomeView(<span class="keyword">this</span>, LayerManager.UI_Main)</span><br><span class="line">        App.ViewManager.register(ViewConst.JackWelcome, <span class="keyword">this</span>.jackWelcomeView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JackWelcomeView.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JackWelcomeView <span class="keyword">extends</span> BaseEuiView &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">$controller: BaseController, $parent: eui.Group</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>($controller, $parent)</span><br><span class="line">        <span class="keyword">this</span>.skinName = <span class="string">"resource/black_jack/skins/JackWelcomeUiSkin.exml"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> welcomeInfoBtn: eui.Button</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对面板初始化，用于子类继承</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> initUI(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initUI()</span><br><span class="line">        <span class="keyword">this</span>.welcomeInfoBtn.addEventListener(egret.TouchEvent.TOUCH_TAP, <span class="keyword">this</span>.imagesTweenStart, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.addImageToStage()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要赋予动画的三个图片元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> banner: egret.Bitmap</span><br><span class="line">    <span class="keyword">private</span> infoGo: egret.Bitmap</span><br><span class="line">    <span class="keyword">private</span> infoText: egret.Bitmap</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实例化图片，并添加到当前页面中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> addImageToStage(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> banner = <span class="keyword">new</span> egret.Bitmap()</span><br><span class="line"><span class="comment">//获取前面加载好的资源文件</span></span><br><span class="line">        banner.texture = RES.getRes(<span class="string">'welcome_banner_png'</span>)</span><br><span class="line">        banner.x = <span class="number">-50</span></span><br><span class="line">        banner.y = <span class="number">274</span></span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.banner = banner)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> infoText = <span class="keyword">new</span> egret.Bitmap()</span><br><span class="line">        infoText.texture = RES.getRes(<span class="string">'welcome_info_text_png'</span>)</span><br><span class="line">        infoText.x = <span class="number">35</span> + <span class="keyword">this</span>.width</span><br><span class="line">        infoText.y = <span class="number">190</span></span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.infoText = infoText)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> infoGo = <span class="keyword">new</span> egret.Bitmap()</span><br><span class="line">        infoGo.texture = RES.getRes(<span class="string">'welcome_info_go_png'</span>)</span><br><span class="line">        infoGo.x = <span class="number">269</span> + <span class="keyword">this</span>.width</span><br><span class="line">        infoGo.y = <span class="number">924</span></span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.infoGo = infoGo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">监听触发动画的按钮</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> imagesTweenStart(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bannerDis: <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">let</span> infoTextDis: <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">let</span> infoGoDis: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.banner.x == <span class="number">-50</span>) &#123;</span><br><span class="line">            bannerDis = <span class="number">-850</span></span><br><span class="line">            infoTextDis = <span class="number">35</span></span><br><span class="line">            infoGoDis = <span class="number">269</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bannerDis = <span class="number">-50</span></span><br><span class="line">            infoTextDis = <span class="number">800</span></span><br><span class="line">            infoGoDis = <span class="number">1034</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        egret.Tween.get(<span class="keyword">this</span>.banner).to(&#123; x: bannerDis &#125;, <span class="number">300</span>, egret.Ease.sineIn)</span><br><span class="line">        egret.Tween.get(<span class="keyword">this</span>.infoText).to(&#123; x: infoTextDis &#125;, <span class="number">300</span>, egret.Ease.sineIn)</span><br><span class="line">        egret.Tween.get(<span class="keyword">this</span>.infoGo).to(&#123; x: infoGoDis &#125;, <span class="number">300</span>, egret.Ease.sineIn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/QQ20170822-181434-HD.gif" alt="" title="QQ20170822-181434-HD"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://developer.egret.com/cn/github/egret-docs/extension/tween/tween/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考官方缓动动画文档&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="Egret" scheme="https://luoyec.cn/categories/Egret/"/>
    
    
      <category term="Egret" scheme="https://luoyec.cn/tags/Egret/"/>
    
      <category term="缓动动画" scheme="https://luoyec.cn/tags/%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    
      <category term="交互效果" scheme="https://luoyec.cn/tags/%E4%BA%A4%E4%BA%92%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（4）</title>
    <link href="https://luoyec.cn/2017/08/22/cl4e29qez006i989ewa8nvw65/"/>
    <id>https://luoyec.cn/2017/08/22/cl4e29qez006i989ewa8nvw65/</id>
    <published>2017-08-22T06:27:50.000Z</published>
    <updated>2017-08-22T06:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类剖析"><a href="#类剖析" class="headerlink" title="类剖析"></a>类剖析</h2><p>实例化对象时，几乎总要与其他对象交互，一个对象也有可能作为另一个对象的一部分，或者是一个继承层次结构中组成部分。</p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>简单的标识、具有描述性、提供类做什么以及与其在交互系统中如何交互的信息。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释风格</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote><p>尽可能地隐藏数据<br>属性私有，能够保证接口设计尽可能少的设计原则是一致的。访问这些属性的唯一途径就是通过所提供的方法接口。</p></blockquote><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>对于这个类实例化的所有对象来说，这个属性只有一个副本。</p><h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><p>属性私有，其他对象无法直接访问它，必须使用类提供的接口</p><h3 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> myCab： Cab</span><br></pre></td></tr></table></figure><p>Cab对象可能由另一个对象穿件，因此，将把对象引用传递到Cabbie对象。<br>注意，目前只创建了Cab对象的一个引用，根据这个定义并没有真正分配内存。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在构造函数中初始化属性。也可以在构造函数中，将不需要赋值的属性赋值为null，那么以后再使用该类时就能检查其属性是否为null</p><p>可以传递参数给构造函数，已完成初始化属性工作。这里需要注意的是，所有的构造函数都应该定义为public ，如果是私有的构造函数，那么其他对象就不能访问他们，包括实例化对象的对象。</p><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>一个类应当很好的保护自己的属性。</p><blockquote><p>静态属性<br>如果一个属性是静态的，而且类为这个属性提供了一个设置方法，那么调用这个设置方法的任何对象都可以修改这个副本。因此，对于所有对象来来说，该属性的值都会发生改变。</p></blockquote><h2 id="公共接口方法"><a href="#公共接口方法" class="headerlink" title="公共接口方法"></a>公共接口方法</h2><p>够赞函数和访问方法都声明为公共方法，是公共接口的一部分。</p><h2 id="私有的实现方法"><a href="#私有的实现方法" class="headerlink" title="私有的实现方法"></a>私有的实现方法</h2><p>私有方法只是实现的一部分，不能由其他类访问。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>没有太多的内容，主要是前几章节的一个总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类剖析&quot;&gt;&lt;a href=&quot;#类剖析&quot; class=&quot;headerlink&quot; title=&quot;类剖析&quot;&gt;&lt;/a&gt;类剖析&lt;/h2&gt;&lt;p&gt;实例化对象时，几乎总要与其他对象交互，一个对象也有可能作为另一个对象的一部分，或者是一个继承层次结构中组成部分。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="OO" scheme="https://luoyec.cn/tags/OO/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（3）</title>
    <link href="https://luoyec.cn/2017/08/21/cl4e29qey006g989e5b834ahf/"/>
    <id>https://luoyec.cn/2017/08/21/cl4e29qey006g989e5b834ahf/</id>
    <published>2017-08-21T00:25:09.000Z</published>
    <updated>2017-08-21T00:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级面向对象概念"><a href="#高级面向对象概念" class="headerlink" title="高级面向对象概念"></a>高级面向对象概念</h2><p>本章将会介绍更高级的OO概念，如构造函数、操作符重载和多重继承，还将考虑错误处理技术，并强调面向对象设计中应用作用域的重要性。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>注意<br>构造函数没有返回值，如果为方法提供一个返回值，编译器就不会把它作为一个构造函数</p></blockquote><p>创建一个新对象时，首先要做的事情之一就是调用构造函数。</p><p>new关键字创建一个新实例，并分配所需的内存。然后构造函数被调用，传入参数列表中的参数。构造函数为开发人员提供了一个机会来完成适当的初始化。</p><blockquote><p>初始化属性<br>在结构化程序设计中，通常需要一个名为housekeeping或initialization的例程来完成初始化工作。</p></blockquote><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果没有为类提供显式的构造函数，就会提供一个默认的构造函数。</p><p>这时候，默认构造函数唯一的工作就是调用父类的构造函数。会默认的插入以下默认构造函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Hero &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> magic <span class="keyword">extends</span> Hero &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的经验是，总应该提供一个构造函数，即使你不打算在其中做任何事情。</p><h3 id="使用多个构造函数"><a href="#使用多个构造函数" class="headerlink" title="使用多个构造函数"></a>使用多个构造函数</h3><p>在TypeScript中没有这部分内容，求证实？</p><h4 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h4><p>重载允许程序员多次使用同一个方法名，只要每次方法的签名不同，签名由方法名和一个参数列表组成。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503273348572.jpg" alt=""></p><p>Java中的重载方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCab</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCab</span><span class="params">(<span class="keyword">int</span> numberOfPassngers)</span></span></span><br></pre></td></tr></table></figure><h4 id="父类如果构造"><a href="#父类如果构造" class="headerlink" title="父类如果构造"></a>父类如果构造</h4><p>使用继承时，必须知道父类如何构造。会完成以下几个步骤：</p><ul><li>构造函数中首先做的是调用该类的父类的构造函数，如果没有显示的调用父类的构造函数就会自动调用父类的默认构造函数。在TypeScript中也是如此。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Hero &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是父类的构造函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Magic <span class="keyword">extends</span> Hero &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> magic = <span class="keyword">new</span> Magic()  <span class="comment">//log:  我是父类的构造函数</span></span><br></pre></td></tr></table></figure><ul><li>然后初始化对象的个各类属性</li><li>然后执行构造函数中其余代码</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>一个try/catch块结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//possible nasty code</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//code to handle the exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果try块中抛出了一个异常，catch块就会处理这个异常。执行try块中时如果抛出一个异常，会发生以下情况：</p><ul><li>try块的执行会终止</li><li>检查catch子句，确定对出现的异常是否班阔一个合适的catch块（每个try块可能不止有一个catch子句）</li><li>如果没有能够处理所抛出异常的catch子句，则把异常传递到下一个更高层的try块</li><li>如果某个catch子句匹配，则执行该catch子句中的语句</li><li>再从try块之后的语句继续执行</li></ul><h2 id="作用域的概念"><a href="#作用域的概念" class="headerlink" title="作用域的概念"></a>作用域的概念</h2><p>属性作用域、方法作用域</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>即改变一个操作符的含义。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>多重继承允许继承多个类。</p><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><blockquote><p>类和引用<br>复杂数据结构和对象的问题在于，它们包含引用。只建立引用的一个副本并不会复制它引用的数据结构或对象。同样的，比较对象时，如果是将一个指针与另一个指针相比较，这只会比较引用，而不是它们所指的对象</p></blockquote><blockquote><p>深复制与浅复制<br>深复制（deep coty）是指，沿着所有引用（指针）完成复制，从而为所引用的所有对象创建新的副本。深复制可能涉及多个层次。一个对象可能包含许多对象的引用，而所引用的这些对象可能又引用更多对象，所以复制本身可能会带来显著的开销。<br>浅复制（shallow copy）则只是复制引用，而不沿着引用层继续向下。</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503274894223.jpg" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要分析了构造函数、默认构造函数、错误处理、继承、多重继承以及对象操作（深复制与浅复制）的概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高级面向对象概念&quot;&gt;&lt;a href=&quot;#高级面向对象概念&quot; class=&quot;headerlink&quot; title=&quot;高级面向对象概念&quot;&gt;&lt;/a&gt;高级面向对象概念&lt;/h2&gt;&lt;p&gt;本章将会介绍更高级的OO概念，如构造函数、操作符重载和多重继承，还将考虑错误处理技术，并强调
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（2）</title>
    <link href="https://luoyec.cn/2017/08/21/cl4e29qew006b989ebei8w5yl/"/>
    <id>https://luoyec.cn/2017/08/21/cl4e29qew006b989ebei8w5yl/</id>
    <published>2017-08-20T23:32:21.000Z</published>
    <updated>2017-08-20T23:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何以对象方式思考"><a href="#如何以对象方式思考" class="headerlink" title="如何以对象方式思考"></a>如何以对象方式思考</h2><p>OO设计所期望的最终结果是一个健壮、功能完备的对象模型，换句话说，也就是一个完备的系统。</p><p>将会讨论以下几个问题：</p><ul><li>了解接口和实现之间的区别</li><li>以更抽象的方式思考</li><li>尽可能为用户提供最小接口</li></ul><h2 id="了解接口和实现之间的区别"><a href="#了解接口和实现之间的区别" class="headerlink" title="了解接口和实现之间的区别"></a>了解接口和实现之间的区别</h2><p>在设计类时，必须了解用户需要知道什么以及用户不需要知道什么。</p><p>适当的构造类分为两个部分设计—-接口和实现</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在最理想的情况下，应该只为最终用户提供他们所需要的服务。</p><blockquote><p>明确用户<br>在设计一个类时，也许最重要的就是明确类的受众或用户。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现的细节对用户是隐藏的。需要记住的一个实现的目标：改变实现不需要同时改变用户的代码。</p><h3 id="接口-实现示例"><a href="#接口-实现示例" class="headerlink" title="接口/实现示例"></a>接口/实现示例</h3><p>根据需求提供相应的接口，例如一个简单的数据库读取器：</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503271056492.jpg" alt=""></p><p>DataBaseReader类的一个UML类图</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503271314894.jpg" alt=""></p><blockquote><p>公共接口<br>如果一个方法是公共的，应用程序员就可以访问它，因此，它可以认为是类接口的一部分。</p></blockquote><blockquote><p>对象持久性<br>是指保存对象的状态，从而可以在以后恢复并使用。没有持久存储的对象一旦出了作用域实际上就已经死亡了。例如可以把对象的状态保存在数据库中。</p></blockquote><h2 id="设计接口是使用抽象思维"><a href="#设计接口是使用抽象思维" class="headerlink" title="设计接口是使用抽象思维"></a>设计接口是使用抽象思维</h2><p>抽象接口通常是实现一个优秀可重用OO设计所采用的做法。</p><h3 id="尽可能为用户提供最小接口"><a href="#尽可能为用户提供最小接口" class="headerlink" title="尽可能为用户提供最小接口"></a>尽可能为用户提供最小接口</h3><p>要做到这一点，需要遵守以下规则：</p><ul><li>只为用户提供他们确实需要的东西</li><li>最好是当用户确实需要时才增加接口，而不要为用户提供他们不需要的接口</li><li>公共接口定义用户能够访问的信息</li><li>用用户角度设计类，而不要从信息系统的角度进行设计</li><li>确保设计类时将与真正使用这个类的人（不只是开发人员）反复考虑需求和设计</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于OO思维过程的问题并不是固定的，采用OO方式做事与其说是一门科学不如说是一门艺术。你可以用自己的方式来描述OO思维。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何以对象方式思考&quot;&gt;&lt;a href=&quot;#如何以对象方式思考&quot; class=&quot;headerlink&quot; title=&quot;如何以对象方式思考&quot;&gt;&lt;/a&gt;如何以对象方式思考&lt;/h2&gt;&lt;p&gt;OO设计所期望的最终结果是一个健壮、功能完备的对象模型，换句话说，也就是一个完备的系
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>《写给大家看的面向对象编程书》总结&amp;&amp;实践（1）</title>
    <link href="https://luoyec.cn/2017/08/20/cl4e29qfo007v989eadkch015/"/>
    <id>https://luoyec.cn/2017/08/20/cl4e29qfo007v989eadkch015/</id>
    <published>2017-08-20T15:50:04.000Z</published>
    <updated>2017-08-20T23:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象概念介绍"><a href="#面向对象概念介绍" class="headerlink" title="面向对象概念介绍"></a>面向对象概念介绍</h2><h2 id="过程式程序设计与OO程序设计"><a href="#过程式程序设计与OO程序设计" class="headerlink" title="过程式程序设计与OO程序设计"></a>过程式程序设计与OO程序设计</h2><blockquote><p>OO和过程式程序设计的区别<br>在OO设计中，属性和行为都包含在一个对象中，而在过程式程序设计中，属性和行为是分开的</p></blockquote><blockquote><p>适当的设计<br>可以断言，如果设计得当，OO模型中根本不会有诸如全局数据之类的东西。这一点保证了OO系统中高度的数据完整性。</p></blockquote><p>对象不只是数据结构和基本数据类型，还包含方法。在一个对象中，方法用于完成数据操作和其他动作。更为重要的一点是，可以孔子对象成员（包括属性和方法）的访问。</p><blockquote><p>数据隐藏<br>在OO术语中，数据表示为属性，行为表示为方法。限制对某些属性或方法的访问称为隐藏。</p></blockquote><h2 id="对象到底是什么"><a href="#对象到底是什么" class="headerlink" title="对象到底是什么"></a>对象到底是什么</h2><h3 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h3><p>存储在一个对象中的数据表示对象的状态，在OO程序设计中，该数据称为属性。</p><h3 id="对象行为"><a href="#对象行为" class="headerlink" title="对象行为"></a>对象行为</h3><p>对象的行为就是对象能够做什么，也就是在面对过程语言中，行为由过程、函数和子例程定义。在OO程序设计术语中，这些行为包含在方法中，要通过发送消息来调用方法。</p><blockquote><p>获取方法和设置方法（set、get）<br>获取方法和设置方法的概念支持数据隐藏的概念。因为其他对象不能直接处理另一个对象内部数据，所以获取方法和设置方法提供了对对象数据的一种可控访问。有时也被称为访问方法和修改方法。</p></blockquote><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503239285383.jpg" alt=""></p><blockquote><p>UML类图<br>每个类图定义为3个不同部分：类名本身、数据（属性）和行为（方法）</p></blockquote><p>创建一个对象时，称之为对象被实例化。例如这里你创了三个员工，实际上就会创建3个完全不同的Employee类实例。每个对象都包含其自己的属性和方法副本。</p><h2 id="类到底是什么"><a href="#类到底是什么" class="headerlink" title="类到底是什么"></a>类到底是什么</h2><p>简单的说，类就是对象的一个蓝图。实例化一个对象时，就是使用一个类作为构建这个对象的基础。应该先有类，如果没有类，对象就无法实例化。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>访问指示<br>当某个数据类型或者方法定义我public时，其他对象可以直接访问它。当某个数据类型或方法定义为private时，只有特定对象能够访问。还有一个访问修饰符protected，它允许相关对象访问。</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法实现了一个类所需的行为。从这个类实例化的各个对象都有该类所定义的方法。方法可能实现其他对象（消息）所调用的行为，或者提供这个类内部的基本行为。内部行为是不允许其他对象访问的私有方法。除非是暴露了相应的set、get方法。</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息是对象之家的通信机制。例如当对象A调用对象B的一个方法时，对象A就是在向对象B发送一个消息。当然，只有对象的公共方法能够被另一个对象调用。</p><h2 id="封装和数据的隐藏"><a href="#封装和数据的隐藏" class="headerlink" title="封装和数据的隐藏"></a>封装和数据的隐藏</h2><p>使用对象的主要优点之一，就是对象不需要公开它的所有属性和行为。在好的OO设计中，对象只应该公开其他对象与之交互所必须的接口。与对象设计无关的细节应当对所有的对象隐藏。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接上文，接口定义了对象间通信的基本途径。每个类设计都要指定接口来正确地实现对象的实例化和操作。在大多数OO语言中，接口中的方法都指定为public</p><blockquote><p>私有数据<br>要实现数据隐藏，所有属性都应该声明为private。因此属性不是接口的一部分。只有public方法才数据类接口。将属性声明为public会破坏数据隐藏的概念。</p></blockquote><p>一个简单的例子，包含了私有属性、私有方法、公共接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> IntSquare &#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> squareValue: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共接口</span></span><br><span class="line">    <span class="keyword">public</span> getSquare(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.squareValue = <span class="keyword">this</span>.calculateSquare(value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.squareValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="keyword">private</span> calculateSquare(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intSquare = <span class="keyword">new</span> IntSquare()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(intSquare.getSquare(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OO程序设计中最强大的一个特性就是代码重用，你可以编写一个过程，然后根据需要使用多次。不过OO设计更近一步，允许通过组织类并抽取各个类的共性来定义类之间的关系，这不仅有利于代码重用，还可以实现更好的整体设计。</p><h3 id="父亲类和子类"><a href="#父亲类和子类" class="headerlink" title="父亲类和子类"></a>父亲类和子类</h3><p>父类包含继承自该类的所有子类共同的属性和方法。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>继承的强大之处就在于其抽象和组织技术。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503242485931.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1503270322338.jpg" alt=""></p><p>在当前的多数OO语言中，一个类只能有一个父类；不过一个父类可以有多个子类。<br>一个类只能有一个父类叫单重继承（java、.net）、一个类只能有多个父类叫多重继承（如C++）</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>字面意思是多种形状。问题引申，由于每个子类都是一个单独的实体，他们可能需要对同一个消息做出不同的响应。</p><p>多态是指类似对象可以采用不同的方式对相同的消息做出相应。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果一个方法与所在的类同名，而且没有提供任何返回类型，这就是构造函数。可以把构造函数当做类的入口点，这里非常适合完成初始化和准备工作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要包含以下部分：</p><ul><li>封装：将属性和方法封装到一个对象中</li><li>继承: 一个类可以从另一个类继承，并且可以利用父类定义的属性和方法</li><li>多态：对象可以采用不同的方式对相同的消息做出响应</li><li>组合：一个对象由其他对象构建而成</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>定义一个类，直接实例化或者在另一个对象中实例化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> strName: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> strAddress: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TestPerson &#123;</span><br><span class="line">    <span class="keyword">private</span> personq: Person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.personq.name = <span class="string">'aaa'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.personq.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">'jojo'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">//jojo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testPerson = <span class="keyword">new</span> TestPerson()  <span class="comment">//aaa</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象概念介绍&quot;&gt;&lt;a href=&quot;#面向对象概念介绍&quot; class=&quot;headerlink&quot; title=&quot;面向对象概念介绍&quot;&gt;&lt;/a&gt;面向对象概念介绍&lt;/h2&gt;&lt;h2 id=&quot;过程式程序设计与OO程序设计&quot;&gt;&lt;a href=&quot;#过程式程序设计与OO程序设计&quot;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://luoyec.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面对对象" scheme="https://luoyec.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>mongodb二（命令行操作）</title>
    <link href="https://luoyec.cn/2017/08/16/cl4e29qem005u989ef2fc8u04/"/>
    <id>https://luoyec.cn/2017/08/16/cl4e29qem005u989ef2fc8u04/</id>
    <published>2017-08-16T13:58:13.000Z</published>
    <updated>2017-08-17T01:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB分片"><a href="#MongoDB分片" class="headerlink" title="MongoDB分片"></a>MongoDB分片</h1><p>在MongoDB里面存在另一种集群，就是分片技术，可以满足MongoDB数据大量增长的需求。<br>当MongoDB存储海量数据的时候，一台机器可能不足以存储数据，也不足以提供可接受的读写吞吐量。这是，我们需要通过在多台机器上分割数据，使得数据库系统能存储和处理更多数据。</p><h2 id="为什么使用分片技术"><a href="#为什么使用分片技术" class="headerlink" title="为什么使用分片技术"></a>为什么使用分片技术</h2><ul><li>复制所有的写入操作到主节点</li><li>延迟敏感数据会在主节点查询</li><li>单个副本集限制在12个节点</li><li>当请求量巨大时会出现内存不足</li><li>本地磁盘不足</li><li>垂直扩展价格高</li></ul><h2 id="MongoDB分片-1"><a href="#MongoDB分片-1" class="headerlink" title="MongoDB分片"></a>MongoDB分片</h2><p>下图展示了在MongoDB中使用分片集群结构分布：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501016030156.jpg" alt="分片集群结构分布"></p><p> 上图中主要有如下所述三个主要组件：</p><ul><li>Shard：用于存储实际的数据块，实际生产环境中有一个shard server角色可由几台机器组一个replica set承担，防止主机单点故障</li><li>Config Server：mongod实例，存储了整个ClusterMetadata，其中包括chunk信息</li><li>Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><a href="http://www.runoob.com/mongodb/mongodb-sharding.html" target="_blank" rel="noopener">具体实例参考菜鸟教程</a></p><h1 id="MongoDB备份（mongodump）与恢复（mongorestore）"><a href="#MongoDB备份（mongodump）与恢复（mongorestore）" class="headerlink" title="MongoDB备份（mongodump）与恢复（mongorestore）"></a>MongoDB备份（mongodump）与恢复（mongorestore）</h1><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><p>在MongoDB中我们使用mongodump命令来备份MongoDB数据，该命令可以导出所有数据到指定目录中。<br>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>mongodump -h dbhost -d dbname -o dbdirectory</span><br><span class="line">//-h:mongoDB所在服务器地址，如127.0.0.1，也可以指定端口号：127.0.0.1：27017 </span><br><span class="line">//-d:需要备份的数据库实例，例如test</span><br><span class="line">//-o:备份的出局存放位置，例如： c:\data\dump ，当然该目录需要提前建立，当备份完成后，系统会在dump目录下件一个test目录，这个目录里存放该数据库实例的备份数据</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在当前目录下，新建终端，备份到当前目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">luoyecs-iMac:~ LW-luoyec$ mongodump</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.736</span>+<span class="number">0800</span>writing admin<span class="selector-class">.system</span><span class="selector-class">.version</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.739</span>+<span class="number">0800</span>done dumping admin<span class="selector-class">.system</span><span class="selector-class">.version</span> (<span class="number">1</span> document)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.739</span>+<span class="number">0800</span>writing test<span class="selector-class">.fruits</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.739</span>+<span class="number">0800</span>writing test<span class="selector-class">.user</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>writing test<span class="selector-class">.meterial</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>writing test<span class="selector-class">.col</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>done dumping test<span class="selector-class">.user</span> (<span class="number">2</span> documents)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>writing movie.的 to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>done dumping test<span class="selector-class">.fruits</span> (<span class="number">7</span> documents)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.740</span>+<span class="number">0800</span>writing test<span class="selector-class">.values</span> to </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.741</span>+<span class="number">0800</span>done dumping test<span class="selector-class">.meterial</span> (<span class="number">1</span> document)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.741</span>+<span class="number">0800</span>done dumping test<span class="selector-class">.col</span> (<span class="number">3</span> documents)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.741</span>+<span class="number">0800</span>done dumping movie.的 (<span class="number">0</span> documents)</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span>T05:<span class="number">11</span>:<span class="number">32.741</span>+<span class="number">0800</span>done dumping test<span class="selector-class">.values</span> (<span class="number">0</span> documents)</span><br></pre></td></tr></table></figure><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501017297528.jpg" alt=""></p><p> mongodump 命令可选参数列表如下所示：<br> <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501017353859.jpg" alt="enter description here"></p><h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p> mongodb使用mongorestore命令来恢复备份到数据。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</span><br><span class="line">/*</span><br><span class="line">--host &lt;:port&gt;, -h &lt;:port&gt;：</span><br><span class="line">MongoDB所在服务器地址，默认为： localhost:27017</span><br><span class="line">--db , -d ：</span><br><span class="line">需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</span><br><span class="line">--drop：</span><br><span class="line">恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</span><br><span class="line">&lt;path&gt;：</span><br><span class="line">mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。</span><br><span class="line">你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。</span><br><span class="line">--dir：</span><br><span class="line">指定备份的目录</span><br><span class="line">你不能同时指定 &lt;path&gt; 和 --dir 选项。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mongorestore</span><br></pre></td></tr></table></figure><p>执行以上命令输出结果如下：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501018023117.jpg" alt="enter description here"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MongoDB分片&quot;&gt;&lt;a href=&quot;#MongoDB分片&quot; class=&quot;headerlink&quot; title=&quot;MongoDB分片&quot;&gt;&lt;/a&gt;MongoDB分片&lt;/h1&gt;&lt;p&gt;在MongoDB里面存在另一种集群，就是分片技术，可以满足MongoDB数据大量增长
      
    
    </summary>
    
      <category term="mongodb" scheme="https://luoyec.cn/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="https://luoyec.cn/tags/mongodb/"/>
    
      <category term="命令行" scheme="https://luoyec.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="增删改查" scheme="https://luoyec.cn/tags/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>mongodb一（命令行操作）</title>
    <link href="https://luoyec.cn/2017/08/16/cl4e29qek005r989e40f7pf8c/"/>
    <id>https://luoyec.cn/2017/08/16/cl4e29qek005r989e40f7pf8c/</id>
    <published>2017-08-16T13:46:13.000Z</published>
    <updated>2017-08-17T01:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="http://www.runoob.com/mongodb/mongodb-dropdatabase.html" target="_blank" rel="noopener">菜鸟教程</a></p><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>use 创建数据库<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">use</span> runoob<span class="comment">//如数据库不存则创建，否则切换到制定数据库</span></span><br><span class="line">switched to <span class="keyword">db</span> runoob</span><br><span class="line">&gt; <span class="keyword">db</span><span class="comment">//显示当前操作的数据库</span></span><br><span class="line">runoob</span><br></pre></td></tr></table></figure></p><p>show dbs 查看所有数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs    <span class="comment">//如果数据库中没有数据，则不会显示出来</span></span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">runoob  <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure><p>insert 插入数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.runoob</span><span class="selector-class">.insert</span>(&#123;<span class="string">"name"</span>:<span class="string">"lyctea"</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; show dbs</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">runoob  <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure><h1 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>删除数据库 runoob</p><p>首先，查看所有数据库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">runoob  <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure><p>接下来我们切换到数据库 runoob：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use runoob</span><br><span class="line">switched to db runoob</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>执行删除命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.dropDatabase()</span><br><span class="line">&#123; <span class="string">"dropped"</span> : <span class="string">"runoob"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>最后，我们再通过 show dbs 命令数据库是否删除成功：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin  <span class="number">0.000</span>GB</span><br><span class="line">local  <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure><h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>集合删除语法格式如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.drop</span>()  <span class="comment">//collection 是集合名</span></span><br></pre></td></tr></table></figure><p>以下实例删除了 runoob 数据库中的集合 runoob：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show tables</span><br><span class="line">runoob</span><br><span class="line">&gt; db<span class="selector-class">.runoob</span><span class="selector-class">.drop</span>()</span><br><span class="line">true</span><br><span class="line">&gt; show tables</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h1 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h1><p>文档的数据结构和JSON基本一样。<br>所有存储在集合中的数据都是BSON格式。<br>BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON</p><h2 id="插入文档-1"><a href="#插入文档-1" class="headerlink" title="插入文档"></a>插入文档</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.insert</span>(document)</span><br></pre></td></tr></table></figure><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>以下文档可以存储在 MongoDB 的 runoob 数据库 的 col 集合中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.insert</span>(&#123;title: <span class="string">'MongDB master'</span>,description: <span class="string">'Mongo is s Nosql database'</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br></pre></td></tr></table></figure><p>查看已经插入的文档，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"597005c9c1f1597f764b41bb"</span>), <span class="string">"title"</span> : <span class="string">"MongDB master"</span>, <span class="string">"description"</span> : <span class="string">"Mongo is s Nosql database"</span> &#125;</span><br></pre></td></tr></table></figure><p>定义一个变量，插入数据库中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; document = &#123;title: <span class="string">'is a var'</span>,description: <span class="string">'use test'</span>&#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"is a var"</span>, <span class="string">"description"</span> : <span class="string">"use test"</span> &#125;</span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.insert</span>(document)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"597005c9c1f1597f764b41bb"</span>), <span class="string">"title"</span> : <span class="string">"MongDB master"</span>, <span class="string">"description"</span> : <span class="string">"Mongo is s Nosql database"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"597006d5c1f1597f764b41bc"</span>), <span class="string">"title"</span> : <span class="string">"is a var"</span>, <span class="string">"description"</span> : <span class="string">"use test"</span> &#125;</span><br></pre></td></tr></table></figure><p>插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p><h1 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h1><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档</p><h2 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h2><p>用于更新已经存在的文档</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.update</span>(</span><br><span class="line">   &lt;query&gt;,<span class="comment">//查询条件，类似sql update查询内where后面的</span></span><br><span class="line">   &lt;update&gt;,  <span class="comment">//update对象和一些更新的操作符</span></span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,   <span class="comment">//可选，如果不存在update记录，是否插入ObjNew？插入：不插入</span></span><br><span class="line">     multi: &lt;boolean&gt;,<span class="comment">//可选，默认为false，只更新查找到的第一条记录，如果为true，则按条件查出来的记录全部更新</span></span><br><span class="line">     writeConcern: &lt;document&gt;  <span class="comment">//可选，抛出异常的级别</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>我们在集合 col 中插入如下数据：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.insert</span>(&#123;title:<span class="string">'jiaocheng'</span>,class: <span class="string">'yuwen'</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.update</span>(&#123;title:<span class="string">'jiaocheng'</span>&#125;,&#123;<span class="variable">$set</span>:&#123;title: <span class="string">'peixun'</span>&#125;&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>().pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"597005c9c1f1597f764b41bb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongDB master"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"Mongo is s Nosql database"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"597006d5c1f1597f764b41bc"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"is a var"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"use test"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5970093bc1f1597f764b41bd"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"peixun"</span>,</span><br><span class="line"><span class="string">"class"</span> : <span class="string">"yuwen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改多条文档</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.update</span>(&#123;title:<span class="string">'jiaocheng'</span>&#125;,&#123;<span class="variable">$set</span>:&#123;title:<span class="string">'MongoDB'</span>&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nMatched"</span> : <span class="number">2</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">2</span> &#125;)</span></span></span><br></pre></td></tr></table></figure><h2 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h2><p>save()方法通过传入的文档来替换已有文档，语法格式如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.save</span>(</span><br><span class="line">   &lt;document&gt;,<span class="comment">//文档数据</span></span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;   <span class="comment">//可选，跑出异常级别</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>以下实例中我们替换了 _id 为 597005c9c1f1597f764b41bb 的文档数据：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.save</span>(&#123;_id: ObjectId(<span class="string">'597005c9c1f1597f764b41bb'</span>),title: <span class="string">'changeById'</span>,by:<span class="string">'lyctea'</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>().pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"597005c9c1f1597f764b41bb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"changeById"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"lyctea"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只更新第一条记录：</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; "test2" : "OK"&#125; &#125; );</span><br><span class="line"><span class="comment">//全部更新：</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; "test2" : "OK"&#125; &#125;,false,true );</span><br><span class="line"><span class="comment">//只添加第一条：</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; "test5" : "OK"&#125; &#125;,true,false );</span><br><span class="line"><span class="comment">//全部添加加进去:</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; "test5" : "OK"&#125; &#125;,true,true );</span><br><span class="line"><span class="comment">//全部更新：</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; "count" : 1&#125; &#125;,false,true );</span><br><span class="line"><span class="comment">//只更新第一条记录：</span></span><br><span class="line">db.col.update( &#123; "count" : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; "count" : 1&#125; &#125;,false,false );</span><br></pre></td></tr></table></figure><h1 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h1><p>MongoDB remove()函数是用来移除集合中的数据。<br>MongoDB数据更新可以使用update()函数。<br>在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>remove() 方法的基本语法格式如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.remove</span>(</span><br><span class="line">   &lt;query&gt;,<span class="comment">//可选，删除文档的条件</span></span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;, <span class="comment">//可选，如果为true或1，则只删除一个文档</span></span><br><span class="line">     writeConcern: &lt;document&gt;  <span class="comment">//可选，抛出异常的级别</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><p>移除title 为 MongoDB的文档</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.remove</span>(&#123;title:<span class="string">'MongoDB'</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nRemoved"</span> : <span class="number">2</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>().pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"597005c9c1f1597f764b41bb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"changeById"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"lyctea"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"597006d5c1f1597f764b41bc"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"is a var"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"use test"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5970093bc1f1597f764b41bd"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"peixun"</span>,</span><br><span class="line"><span class="string">"class"</span> : <span class="string">"yuwen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h1><p>MongoDB 查询文档使用 find() 方法。<br>find() 方法以非结构化的方式来显示所有文档</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>MongoDB 查询数据的语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(query, <span class="comment">//可选，使用查询操符制定查询条件；</span></span><br><span class="line">projection)    ／／可选，使用投影操作符返回指定的健，默认省略</span><br></pre></td></tr></table></figure><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.col</span><span class="selector-class">.find</span>().pretty()   <span class="comment">//pretty() 方法以格式化的方式来显示所有文档。</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line">        <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line">        <span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">        <span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="string">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"likes"</span> : <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><h2 id="MongoDB-AND-条件"><a href="#MongoDB-AND-条件" class="headerlink" title="MongoDB AND 条件"></a>MongoDB AND 条件</h2><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。<br>语法格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p>实例：<br>以下实例通过class和title健来查询数据<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;<span class="string">'class'</span>:<span class="string">'yuwen'</span>&#125;,&#123;<span class="string">'title'</span>:<span class="string">'peixun'</span>&#125;).pretty()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5970093bc1f1597f764b41bd"</span>), <span class="string">"title"</span> : <span class="string">"peixun"</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="MongoDB-OR-条件"><a href="#MongoDB-OR-条件" class="headerlink" title="MongoDB OR 条件"></a>MongoDB OR 条件</h2><p>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.col</span><span class="selector-class">.find</span>(</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="variable">$or</span>: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure></p><p>实例<br>以下实例通过class或者title健来查询数据<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;<span class="variable">$or</span>:[&#123;<span class="string">'class'</span>:<span class="string">'yuwen'</span>&#125;,&#123;<span class="string">'title'</span>:<span class="string">'peixun'</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5970093bc1f1597f764b41bd"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"peixun"</span>,</span><br><span class="line"><span class="string">"class"</span> : <span class="string">"yuwen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AND-和-OR-联合使用"><a href="#AND-和-OR-联合使用" class="headerlink" title="AND 和 OR 联合使用"></a>AND 和 OR 联合使用</h2><p>联合条件查询，查询likes大于50，并class为语文或者title为peixun的文档 (&gt;50&amp;&amp;(class==yuwen || title==peixun))</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;<span class="string">'likes'</span>:&#123;<span class="variable">$gt</span>:<span class="number">50</span>&#125;,<span class="variable">$or</span>:[&#123;<span class="string">'class'</span>:<span class="string">'yuwen'</span>&#125;,&#123;<span class="string">'title'</span>:<span class="string">'peixun'</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5970093bc1f1597f764b41bd"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"peixun"</span>,</span><br><span class="line"><span class="string">"class"</span> : <span class="string">"yuwen"</span>,</span><br><span class="line"><span class="string">"likes"</span> : <span class="number">80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB条件操作符"><a href="#MongoDB条件操作符" class="headerlink" title="MongoDB条件操作符"></a>MongoDB条件操作符</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>条件操作符，用于比较两个表达式并从mongoDB集合中获取数据<br>MongoDB中条件操作符有：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>  -$gt  大于</span><br><span class="line">&lt;  -$lt小于</span><br><span class="line"><span class="meta">&gt;</span>= -$gte  大于等于</span><br><span class="line">&lt;= -$lte   小于等于</span><br></pre></td></tr></table></figure></p><p>清空集合的数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.remove(&#123;&#125;)</span><br><span class="line">WriteResult(&#123; "nRemoved" : 3 &#125;)</span><br></pre></td></tr></table></figure></p><p>插入以下数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.insert(&#123;</span><br><span class="line">...     title: 'PHP 教程', </span><br><span class="line">...     description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',</span><br><span class="line"></span><br><span class="line">...     by: '菜鸟教程',</span><br><span class="line">...     url: 'http://www.runoob.com',</span><br><span class="line">...     tags: ['php'],</span><br><span class="line">...     likes: 200</span><br><span class="line">... &#125;)</span><br><span class="line">WriteResult(&#123; "nInserted" : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span> db.col.insert(&#123;title: 'Java 教程', </span><br><span class="line">...     description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',</span><br><span class="line">...     by: '菜鸟教程',</span><br><span class="line">...     url: 'http://www.runoob.com',</span><br><span class="line">...     tags: ['java'],</span><br><span class="line">...     likes: 150</span><br><span class="line">... &#125;)</span><br><span class="line">WriteResult(&#123; "nInserted" : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span> db.col.insert(&#123;title: 'MongoDB 教程', </span><br><span class="line">...     description: 'MongoDB 是一个 Nosql 数据库',</span><br><span class="line">...     by: '菜鸟教程',</span><br><span class="line">...     url: 'http://www.runoob.com',</span><br><span class="line">...     tags: ['mongodb'],</span><br><span class="line">...     likes: 100</span><br><span class="line">... &#125;)</span><br><span class="line">WriteResult(&#123; "nInserted" : 1 &#125;)</span><br></pre></td></tr></table></figure></p><p>mongoBD (&gt;)操作符 -$gt<br>获取col集合中，likes大于100的数据，你可以使用一下命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.find(&#123;likes: &#123;$gt: 100&#125;&#125;)</span><br><span class="line">&#123; "_id" : ObjectId("597197fa6d266472131059b0"), "title" : "PHP 教程", "description" : "PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "php" ], "likes" : 200 &#125;</span><br><span class="line">&#123; "_id" : ObjectId("597198106d266472131059b1"), "title" : "Java 教程", "description" : "Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "java" ], "likes" : 150 &#125;</span><br></pre></td></tr></table></figure></p><p>mongoDB (&gt;=)操作符 -$gte<br>获取col集合中，likes大于等于100的数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.find(&#123;likes: &#123;$gte: 100&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>mongoDB (&lt;)小于操作符 -$lt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find(&#123;likes: &#123;$lt: 100&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>mongoDB (&lt;=)小于等于操作符 -$lte<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.find(&#123;likes: &#123;$lte: 100&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>同时使用大于和小于条件查询语句<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.find(&#123;likes: &#123;$lt: 200, $gt: 100&#125;&#125;)</span><br><span class="line">&#123; "_id" : ObjectId("597198106d266472131059b1"), "title" : "Java 教程", "description" : "Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "java" ], "likes" : 150 &#125;</span><br></pre></td></tr></table></figure></p><h1 id="MongoDB-type操作符"><a href="#MongoDB-type操作符" class="headerlink" title="MongoDB $type操作符"></a>MongoDB $type操作符</h1><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果<br>MongoDB中可以是使用的类型如下：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1500617726496.jpg" alt="enter description here"></p><h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><p>获取col集合中title为String的数据，可以使用以下命令, type的健值对对照上图<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  &gt;</span> db.col.find(&#123;title: &#123;$type: 2&#125;&#125;)</span><br><span class="line">&#123; "_id" : ObjectId("59719c336d266472131059b3"), "title" : "PHP 教程", "description" : "PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "php" ], "likes" : 200 &#125;</span><br><span class="line">&#123; "_id" : ObjectId("59719c386d266472131059b4"), "title" : "Java 教程", "description" : "Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "java" ], "likes" : 150 &#125;</span><br><span class="line">&#123; "_id" : ObjectId("59719c416d266472131059b5"), "title" : "MongoDB 教程", "description" : "MongoDB 是一个 Nosql 数据库", "by" : "菜鸟教程", "url" : "http://www.runoob.com", "tags" : [ "mongodb" ], "likes" : 100 &#125;</span><br></pre></td></tr></table></figure></p><h1 id="MongoDB-Limit与Skip方法"><a href="#MongoDB-Limit与Skip方法" class="headerlink" title="MongoDB Limit与Skip方法"></a>MongoDB Limit与Skip方法</h1><p>如果需要在MongoDB中，读取指定数量的数据记录，可以使用MongoDB的Limit方法，该方法接受一个参数，该参数指定从MongoDB中读取的记录条数</p><h2 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;&#125;,&#123;title:<span class="number">1</span>, _id:<span class="number">0</span>&#125;).limit(<span class="number">2</span>)</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"PHP 教程"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"Java 教程"</span> &#125;</span><br><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;&#125;,&#123;title:<span class="number">1</span>, _id:<span class="number">0</span>&#125;)</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"PHP 教程"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"Java 教程"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>以下实例之后显示第二条文档数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> db.col.find(&#123;&#125;,&#123;title:1,_id:0&#125;).limit(1).skip(1)</span><br><span class="line">&#123; "title" : "Java 教程" &#125;</span><br></pre></td></tr></table></figure></p><h1 id="MongoDB排序"><a href="#MongoDB排序" class="headerlink" title="MongoDB排序"></a>MongoDB排序</h1><h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.find</span>().sort(&#123;KEY:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h2><p>col集合按照likes的降序排列</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;&#125;,&#123;title:<span class="number">1</span>,_id:<span class="number">0</span>&#125;).sort(&#123;likes: -<span class="number">1</span>&#125;)</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"PHP 教程"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"Java 教程"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB-索引"><a href="#MongoDB-索引" class="headerlink" title="MongoDB 索引"></a>MongoDB 索引</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p><h2 id="ensureIndex-方法创建索引"><a href="#ensureIndex-方法创建索引" class="headerlink" title="ensureIndex()方法创建索引"></a>ensureIndex()方法创建索引</h2><p>MongoDB使用 ensureIndex() 方法来创建索引。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.ensureIndex</span>(&#123;KEY:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>ensureIndex()title升序创建索引，降序则为-1<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.ensureIndex</span>(&#123;title:<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"createdCollectionAutomatically"</span> : false,</span><br><span class="line"><span class="string">"numIndexesBefore"</span> : <span class="number">1</span>,</span><br><span class="line"><span class="string">"numIndexesAfter"</span> : <span class="number">2</span>,</span><br><span class="line"><span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用多个字段来创建索引</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.ensureIndex</span>(&#123;title: <span class="number">1</span>, description: -<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"createdCollectionAutomatically"</span> : false,</span><br><span class="line"><span class="string">"numIndexesBefore"</span> : <span class="number">3</span>,</span><br><span class="line"><span class="string">"numIndexesAfter"</span> : <span class="number">3</span>,</span><br><span class="line"><span class="string">"note"</span> : <span class="string">"all indexes already exist"</span>,</span><br><span class="line"><span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureIndex() 接收可选参数，可选参数列表如下：</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1500730514785.jpg" alt="enter description here"></p><p>实例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.values</span><span class="selector-class">.ensureIndex</span>(&#123;open: <span class="number">1</span>, close: <span class="number">1</span>&#125;, &#123;<span class="attribute">background</span>: true&#125;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"createdCollectionAutomatically"</span> : true,</span><br><span class="line"><span class="string">"numIndexesBefore"</span> : <span class="number">1</span>,</span><br><span class="line"><span class="string">"numIndexesAfter"</span> : <span class="number">2</span>,</span><br><span class="line"><span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB聚合"><a href="#MongoDB聚合" class="headerlink" title="MongoDB聚合"></a>MongoDB聚合</h1><p>MongoDB中聚合（aggregate）主要用于处理数据（统计平均值，求和），并返回计算后的数据结果。</p><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate()方法"></a>aggregate()方法</h2><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db<span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.aggregate</span>(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>计算集合中，每个title的数量<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span>: &#123;_id: <span class="string">'$title'</span>, total: &#123;<span class="variable">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;])</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"MongoDB 教程"</span>, <span class="string">"total"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"Java 教程"</span>, <span class="string">"total"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"PHP 教程"</span>, <span class="string">"total"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>常用的聚合表达式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">表达式描述实例</span><br><span class="line"><span class="variable">$sum</span>计算总和。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, num_tutorial : &#123;<span class="variable">$sum</span> : <span class="string">"$likes"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$avg</span>计算平均值db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, num_tutorial : &#123;<span class="variable">$avg</span> : <span class="string">"$likes"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$min</span>获取集合中所有文档对应值得最小值。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, num_tutorial : &#123;<span class="variable">$min</span> : <span class="string">"$likes"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$max</span>获取集合中所有文档对应值得最大值。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, num_tutorial : &#123;<span class="variable">$max</span> : <span class="string">"$likes"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$push</span>在结果文档中插入值到一个数组中。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, url : &#123;<span class="variable">$push</span>: <span class="string">"$url"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$addToSet</span>在结果文档中插入值到一个数组中，但不创建副本。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, url : &#123;<span class="variable">$addToSet</span> : <span class="string">"$url"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$first</span>根据资源文档的排序获取第一个文档数据。db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, first_url : &#123;<span class="variable">$first</span> : <span class="string">"$url"</span>&#125;&#125;&#125;])</span><br><span class="line"><span class="variable">$last</span>根据资源文档的排序获取最后一个文档数据db<span class="selector-class">.mycol</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">"$by_user"</span>, last_url : &#123;<span class="variable">$last</span> : <span class="string">"$url"</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure><h2 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h2><p>管道在Unix和Linux中一般用于当前命令的输出结果作为下个命令的参数<br>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理，管道操作可以重复<br>表达式：处理输入文档并输出，表达式是无状态的，只能用于计算当前聚合管道中的文档，不能处理其他文档<br>聚合框架中常用的几个操作：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$project</span>：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</span><br><span class="line"><span class="variable">$match</span>：用于过滤数据，只输出符合条件的文档。<span class="variable">$match</span>使用MongoDB的标准查询操作。</span><br><span class="line"><span class="variable">$limit</span>：用来限制MongoDB聚合管道返回的文档数。</span><br><span class="line"><span class="variable">$skip</span>：在聚合管道中跳过指定数量的文档，并返回余下的文档。</span><br><span class="line"><span class="variable">$unwind</span>：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</span><br><span class="line"><span class="variable">$group</span>：将集合中的文档分组，可用于统计结果。</span><br><span class="line"><span class="variable">$sort</span>：将输入文档排序后输出。</span><br><span class="line"><span class="variable">$geoNear</span>：输出接近某一地理位置的有序文档。</span><br></pre></td></tr></table></figure><h3 id="管道操作实例"><a href="#管道操作实例" class="headerlink" title="管道操作实例"></a>管道操作实例</h3><p>查询结果，只包含title和rul字段，1 表示包含，0表示不包含<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.aggregate</span>(&#123;<span class="variable">$project</span>: &#123;title:<span class="number">1</span>,url:<span class="number">1</span>,_id: <span class="number">0</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"PHP 教程"</span>, <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"Java 教程"</span>, <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>, <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span> &#125;</span><br></pre></td></tr></table></figure></p><p>$match用于获取likes大于100的记录，然后将符合条件的记录送到一下阶段$group管道操作进行处理<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.aggregate</span>([&#123;<span class="variable">$match</span>: &#123;likes: &#123;<span class="variable">$gt</span>: <span class="number">100</span>&#125;&#125;&#125;,&#123;<span class="variable">$group</span>:&#123;_id: null,title: &#123;<span class="variable">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;])</span><br><span class="line">&#123; <span class="string">"_id"</span> : null, <span class="string">"title"</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p><p>经过$skip管道符处理后，前两个文档被过滤掉了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col</span><span class="selector-class">.aggregate</span>(&#123;<span class="variable">$skip</span>: <span class="number">2</span>&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59719c416d266472131059b5"</span>), <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>, <span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>, <span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"mongodb"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB复制（副本集）"><a href="#MongoDB复制（副本集）" class="headerlink" title="MongoDB复制（副本集）"></a>MongoDB复制（副本集）</h1><p>MongoDB复制是将数据同步在多个服务器的过程。<br>复制提供了数据的冗余备份，并在多个服务器上存储副本，提高了数据的可用性，并可以保证数据安全。<br>复制还可以允许从硬件故障和服务终端中恢复数据。</p><h2 id="什么是复制"><a href="#什么是复制" class="headerlink" title="什么是复制"></a>什么是复制</h2><ul><li>保障数据的安全性</li><li>提高数据可用性</li><li>灾难恢复</li><li>无需停机维护（如备份，重建索引，压缩）</li><li>分布式读取数据 </li></ul><h2 id="MongoDB复制原理"><a href="#MongoDB复制原理" class="headerlink" title="MongoDB复制原理"></a>MongoDB复制原理</h2><p>mongodb的复制至少需要两个节点。其中一个是主节点，复制处理客户端请求，其余的都是从节点，负责复制主节点上的数据。<br>mongoDB个节点常见搭配方式为： 一主一从，一主多从。<br>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取的这些操作，然后对自己的数据副本执行这些操作，从而保证节点的数据与主节点一致<br>MongoDB复制结构图如下：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1500889427130.jpg" alt="enter description here"></p><p>以上结构图总，客户端总主节点读取数据，在客户端写入数据到主节点是， 主节点与从节点进行数据交互保障数据的一致性。</p><h2 id="副本集特性"><a href="#副本集特性" class="headerlink" title="副本集特性"></a>副本集特性</h2><ul><li>N 个节点的集群</li><li>任何节点可作为主节点</li><li>所有写入操作都在主节点上</li><li>自动故障转移</li><li>自动恢复</li></ul><h2 id="MongoDB副本设置"><a href="#MongoDB副本设置" class="headerlink" title="MongoDB副本设置"></a>MongoDB副本设置</h2><p>在教程中使用同一个MongoDB来做MongoDB的主从实验，步骤：</p><h3 id="关闭正在运行的Mongo服务器"><a href="#关闭正在运行的Mongo服务器" class="headerlink" title="关闭正在运行的Mongo服务器"></a>关闭正在运行的Mongo服务器</h3><p>现在我们通过指定 –replSet 选项来启动mongoDB。–replSet 基本语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --port <span class="string">"PORT"</span> --dbpath <span class="string">"YOUR_DB_DATA_PATH"</span> --replSet <span class="string">"REPLICA_SET_INSTANCE_NAME"</span></span><br></pre></td></tr></table></figure><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mongod </span><span class="built_in">--port</span> <span class="string">27017 </span><span class="built_in">--dbpath</span> <span class="string">"D:\set up\mongodb\data"</span> <span class="built_in">--replSet</span> <span class="string">rs0</span></span><br></pre></td></tr></table></figure><p>以上实例会启动一个名为rs0的MongoDB实例，其端口号为27017。<br>启动后打开命令提示框并连接上mongoDB服务。<br>在Mongo客户端使用命令rs.initiate()来启动一个新的副本集。<br>我们可以使用rs.conf()来查看副本集的配置<br>查看副本集状态使用 rs.status() 命令</p><h3 id="副本集添加成员"><a href="#副本集添加成员" class="headerlink" title="副本集添加成员"></a>副本集添加成员</h3><p>添加副本集的成员，我们需要使用多条服务器来启动mongo服务。进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。<br>语法<br>rs.add() 命令基本语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">rs</span><span class="selector-class">.add</span>(<span class="selector-tag">HOST_NAME</span><span class="selector-pseudo">:PORT)</span></span><br></pre></td></tr></table></figure><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>假设你已经启动了一个名为mongod1.net，端口号为27017的Mongo服务。 在客户端命令窗口使用rs.add() 命令将其添加到副本集中，命令如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">rs</span><span class="selector-class">.add</span>("<span class="selector-tag">mongod1</span><span class="selector-class">.net</span><span class="selector-pseudo">:27017")</span></span><br></pre></td></tr></table></figure><p>MongoDB中你只能通过主节点将Mongo服务添加到副本集中， 判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster() 。<br>MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-dropdatabase.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建数据库&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="mongodb" scheme="https://luoyec.cn/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="https://luoyec.cn/tags/mongodb/"/>
    
      <category term="命令行" scheme="https://luoyec.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="增删改查" scheme="https://luoyec.cn/tags/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>安卓App内嵌Egret</title>
    <link href="https://luoyec.cn/2017/08/16/cl4e29qg4008m989edmvrrbbc/"/>
    <id>https://luoyec.cn/2017/08/16/cl4e29qg4008m989edmvrrbbc/</id>
    <published>2017-08-16T13:40:34.000Z</published>
    <updated>2017-08-16T13:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源:<br><a href="http://www.cnblogs.com/vanezkw/archive/2012/07/02/2572799.html" target="_blank" rel="noopener">webview与js交互</a></p><p><a href="http://www.jianshu.com/p/0b986d6e2e17" target="_blank" rel="noopener">简书 安卓混合开发——原生Java和H5交互，保证你一看就懂！</a></p><h1 id="webview与js交互"><a href="#webview与js交互" class="headerlink" title="webview与js交互"></a>webview与js交互</h1><h2 id="什么是webview"><a href="#什么是webview" class="headerlink" title="什么是webview"></a>什么是webview</h2><blockquote><p>webview介绍的原文如下：A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more.</p></blockquote><p>一个用于显示web 页面的view容器, 你可以滚动web浏览器或者只是简单的显示网络上的内容. 他使用Webkit 引擎去渲染页面可以拥有前进后退的导航, 放大或者缩小. 可以实现和js的交互</p><h2 id="webview能做什么"><a href="#webview能做什么" class="headerlink" title="webview能做什么"></a>webview能做什么</h2><ul><li><p>webView可以利用html做界面布局，虽然目前还比较少人这么使用，不过我相信当一些客户端需要复杂的图文（图文都是动态生成）混排的时候它肯定是个不错的选择。</p></li><li><p>直接显示网页，这功能当然也是它最基本的功能。</p></li><li><p>和js交互。（如果你的js基础比java基础好的话那么采用这种方式做一些复杂的处理是个不错的选择）。</p></li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501747620552.jpg" alt="一个demo"></p><p>  WebViewDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.android.webviewdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.webkit.JsResult;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebChromeClient;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebSettings;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** Demonstrates how to embed a WebView in your activity. Also demonstrates how</span></span><br><span class="line"><span class="comment"> * to have javascript in the WebView call into the activity, and how the activity </span></span><br><span class="line"><span class="comment"> * can invoke javascript.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this example, clicking on the android in the WebView will result in a call into</span></span><br><span class="line"><span class="comment"> * the activities code in &#123;<span class="doctag">@link</span> DemoJavaScriptInterface#clickOnAndroid()&#125;. This code</span></span><br><span class="line"><span class="comment"> * will turn around and invoke javascript using the &#123;<span class="doctag">@linkWebView</span>#loadUrl(String)&#125;</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Obviously all of this could have been accomplished without calling into the activity</span></span><br><span class="line"><span class="comment"> * and then back into javascript, but this code is intended to show how to set up the </span></span><br><span class="line"><span class="comment"> * code paths for this sort of communication.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewDemo</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"WebViewDemo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView mWebView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(icicle);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        mWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line"></span><br><span class="line">        WebSettings webSettings = mWebView.getSettings();</span><br><span class="line">        webSettings.setSavePassword(<span class="keyword">false</span>);</span><br><span class="line">        webSettings.setSaveFormData(<span class="keyword">false</span>);</span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        webSettings.setSupportZoom(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        mWebView.setWebChromeClient(<span class="keyword">new</span> MyWebChromeClient());</span><br><span class="line"></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> DemoJavaScriptInterface(), <span class="string">"demo"</span>);</span><br><span class="line"></span><br><span class="line">        mWebView.loadUrl(<span class="string">"file:///android_asset/demo.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoJavaScriptInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DemoJavaScriptInterface() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This is not called on the UI thread. Post a runnable to invoke</span></span><br><span class="line"><span class="comment">         * loadUrl on the UI thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickOnAndroid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mWebView.loadUrl(<span class="string">"javascript:wave()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provides a hook for calling "alert" from javascript. Useful for</span></span><br><span class="line"><span class="comment">     * debugging your javascript.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebChromeClient</span> <span class="keyword">extends</span> <span class="title">WebChromeClient</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> </span>&#123;</span><br><span class="line">            Log.d(LOG_TAG, message);</span><br><span class="line">            result.confirm();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">/* This function is invoked by the activity */</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">wave</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"droid"</span>).src=<span class="string">"android_waving.png"</span>;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"2"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Calls into the javascript interface for the activity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">"window.demo.clickOnAndroid()"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:80px;</span></span></span><br><span class="line"><span class="tag"><span class="string">            margin:0px auto;</span></span></span><br><span class="line"><span class="tag"><span class="string">            padding:10px;</span></span></span><br><span class="line"><span class="tag"><span class="string">            text-align:center;</span></span></span><br><span class="line"><span class="tag"><span class="string">            border:2px solid #202020;"</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"droid"</span> <span class="attr">src</span>=<span class="string">"android_normal.png"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                Click me!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/intro"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"4dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/webview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="如何交互"><a href="#如何交互" class="headerlink" title="如何交互"></a>如何交互</h2><h3 id="android如果调用js"><a href="#android如果调用js" class="headerlink" title="android如果调用js"></a>android如果调用js</h3><p> 调用形式:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl("javascript:wave()");</span><br></pre></td></tr></table></figure><p>其中wave（）是js中的一个方法，当然你可以把这个方法改成其他的方法，也就是android调用其他的方法。</p><h3 id="js调用android"><a href="#js调用android" class="headerlink" title="js调用android"></a>js调用android</h3><p>调用形式:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> onClick=<span class="string">"window.demo.clickOnAndroid()"</span>&gt;</span><br></pre></td></tr></table></figure><p>代码中的“demo”是在android中指定的调用名称，即</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), <span class="string">"demo"</span>)</span><br></pre></td></tr></table></figure><p>代码中的clickOnAndroid()是“demo”对应的对象：new DemoJavaScriptInterface() 中的一个方法。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>现在你一定了解了android和js的交互了。是时候分析一些demo了，根据上面讲的你也应该比较清楚了。具体交互流程如下：</p><p>①点击图片，则在js端直接调用android上的方法clickOnAndroid()；</p><p>②clickOnAndroid()方法（利用线程）调用js的方法。</p><p>③被②调用的js直接控制html。</p><p>个人总结：利用webView的这种方式在有些时候UI布局就可以转成相应的html代码编写了，而html布局样式之类有DW这样强大的工具，而且网上很多源码，很多代码片。在UI和视觉效果上就会节省很多时间，重复发明轮子没有任何意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源:&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/vanezkw/archive/2012/07/02/2572799.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webview与js交互&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Egret" scheme="https://luoyec.cn/categories/Egret/"/>
    
    
      <category term="内嵌App" scheme="https://luoyec.cn/tags/%E5%86%85%E5%B5%8CApp/"/>
    
      <category term="webview" scheme="https://luoyec.cn/tags/webview/"/>
    
      <category term="js交互" scheme="https://luoyec.cn/tags/js%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>Egret HTTP简单请求</title>
    <link href="https://luoyec.cn/2017/08/16/cl4e29qbv000e989e4iay20di/"/>
    <id>https://luoyec.cn/2017/08/16/cl4e29qbv000e989e4iay20di/</id>
    <published>2017-08-16T03:49:36.000Z</published>
    <updated>2017-08-16T13:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在游戏使用的网络请求，http协议，常用的get、post方法实例</p><p><a href="http://developer.egret.com/cn/2d/net/sendHTTP" target="_blank" rel="noopener">参考官方文档</a></p><h1 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h1><p> 新建请求对象，设置参数，请求方法，注册监听事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> params = <span class="string">`?gameId=<span class="subst">$&#123;userAccountInfo.gameId&#125;</span>&amp;accesstoken=<span class="subst">$&#123;userAccountInfo.token&#125;</span>&amp;userId=<span class="subst">$&#123;userAccountInfo.userId&#125;</span>`</span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> egret.HttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">`<span class="subst">$&#123;SoloGame.baseURL&#125;</span>gameRanking.do<span class="subst">$&#123;params&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">request.open(<span class="string">`http://<span class="subst">$&#123;SoloGame.baseURL&#125;</span>userCenter.do<span class="subst">$&#123;params&#125;</span>`</span>, egret.HttpMethod.GET)</span><br><span class="line"></span><br><span class="line">request.send()</span><br><span class="line">request.addEventListener(egret.Event.COMPLETE, <span class="keyword">this</span>.onGetUserInfoComplete, <span class="keyword">this</span>)</span><br><span class="line">request.addEventListener(egret.IOErrorEvent.IO_ERROR, <span class="keyword">this</span>.onGetUserInfoError, <span class="keyword">this</span>)</span><br><span class="line">request.addEventListener(egret.ProgressEvent.PROGRESS, <span class="keyword">this</span>.onGetUserInfoProgress, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>监听请求状态，成功、失败、进度</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> onGetUserInfoComplete(event: egret.Event): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">var</span> request = &lt;egret.HttpRequest&gt;event.currentTarget</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">JSON</span>.parse(request.response)</span><br><span class="line"><span class="keyword">if</span> (result.status == <span class="number">200</span>) &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> onGetUserInfoError(event: egret.IOErrorEvent): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"get error : "</span> + event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> onGetUserInfoProgress(event: egret.ProgressEvent): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"get progress : "</span> + <span class="built_in">Math</span>.floor(<span class="number">100</span> * event.bytesLoaded / event.bytesTotal) + <span class="string">"%"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> params = <span class="string">`gameId=<span class="subst">$&#123;userAccountInfo.gameId&#125;</span>&amp;accesstoken=<span class="subst">$&#123;userAccountInfo.token&#125;</span>&amp;userId=<span class="subst">$&#123;userAccountInfo.userId&#125;</span>&amp;isSlot=1&amp;wealth=<span class="subst">$&#123;spinCoins&#125;</span>`</span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> egret.HttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = SoloGame.SPINREQUEST</span><br><span class="line"></span><br><span class="line">request.open(<span class="string">`http://<span class="subst">$&#123;url&#125;</span>`</span>, egret.HttpMethod.POST)</span><br><span class="line">request.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line"></span><br><span class="line">request.send(params)</span><br><span class="line"></span><br><span class="line">request.addEventListener(egret.Event.COMPLETE, <span class="keyword">this</span>.onSpinGetComplete, <span class="keyword">this</span>)</span><br><span class="line">request.addEventListener(egret.IOErrorEvent.IO_ERROR, <span class="keyword">this</span>.onSpinGetIOError, <span class="keyword">this</span>)</span><br><span class="line">request.addEventListener(egret.ProgressEvent.PROGRESS, <span class="keyword">this</span>.onSpinGetProgress, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> onSpinGetComplete(event: egret.Event): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">var</span> request = &lt;egret.HttpRequest&gt;event.currentTarget</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">JSON</span>.parse(request.response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.status == <span class="number">200</span>) &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">SoloGame.SPINRESULT = <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> onSpinGetIOError(event: egret.IOErrorEvent): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"get error : "</span> + event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> onSpinGetProgress(event: egret.ProgressEvent): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"get progress : "</span> + <span class="built_in">Math</span>.floor(<span class="number">100</span> * event.bytesLoaded / event.bytesTotal) + <span class="string">"%"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在游戏使用的网络请求，http协议，常用的get、post方法实例&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.egret.com/cn/2d/net/sendHTTP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考官方文档&lt;/a
      
    
    </summary>
    
      <category term="Egret" scheme="https://luoyec.cn/categories/Egret/"/>
    
    
      <category term="HTTP" scheme="https://luoyec.cn/tags/HTTP/"/>
    
      <category term="网络请求" scheme="https://luoyec.cn/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="GET" scheme="https://luoyec.cn/tags/GET/"/>
    
      <category term="POST" scheme="https://luoyec.cn/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>Egret Loading 页面实现方法</title>
    <link href="https://luoyec.cn/2017/08/16/cl4e29qc1000p989e6b6onegl/"/>
    <id>https://luoyec.cn/2017/08/16/cl4e29qc1000p989e6b6onegl/</id>
    <published>2017-08-16T03:29:48.000Z</published>
    <updated>2017-08-17T08:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现Loading页面的方法有好多，这里的方法是，使用EUI皮肤的加载页，可配置型和可定制型程度更高，也更易用。但不是最好的方法。</p><h2 id="资源的处理"><a href="#资源的处理" class="headerlink" title="资源的处理"></a>资源的处理</h2><p>加载页的UI资源是限于preload组资源加载的，所以这两个资源组需要分开处理。加载完并处理相关动画之后才开始加载preload资源组。</p><h2 id="资源分组"><a href="#资源分组" class="headerlink" title="资源分组"></a>资源分组</h2><p>将loading页面需要用到的资源分一个loading资源组出来。<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502853165784.jpg" alt=""></p><h2 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h2><p>  调整资源加载顺序</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502853444407.jpg" alt=""></p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502853568727.jpg" alt=""></p><h3 id="main-ts"><a href="#main-ts" class="headerlink" title="main.ts"></a>main.ts</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Main <span class="keyword">extends</span> eui.UILayer &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载进度界面</span></span><br><span class="line"><span class="comment">     * loading process interface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> loadingView: LoadingUI;</span><br><span class="line">    <span class="keyword">protected</span> createChildren(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.createChildren();</span><br><span class="line">        <span class="comment">//inject the custom material parser</span></span><br><span class="line">        <span class="comment">//注入自定义的素材解析器</span></span><br><span class="line">        <span class="keyword">let</span> assetAdapter = <span class="keyword">new</span> AssetAdapter();</span><br><span class="line">        egret.registerImplementation(<span class="string">"eui.IAssetAdapter"</span>, assetAdapter);</span><br><span class="line">        egret.registerImplementation(<span class="string">"eui.IThemeAdapter"</span>, <span class="keyword">new</span> ThemeAdapter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化Resource资源加载库</span></span><br><span class="line">        RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE, <span class="keyword">this</span>.onConfigComplete, <span class="keyword">this</span>);</span><br><span class="line">        RES.loadConfig(<span class="string">"resource/default.res.json"</span>, <span class="string">"resource/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件加载完成,开始预加载皮肤主题资源和preload资源组。</span></span><br><span class="line"><span class="comment">     * Loading of configuration file is complete, start to pre-load the theme configuration file and the preload resource group</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onConfigComplete(event: RES.ResourceEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">        RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE, <span class="keyword">this</span>.onConfigComplete, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// load skin theme configuration file, you can manually modify the file. And replace the default skin.</span></span><br><span class="line">        <span class="comment">//加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。</span></span><br><span class="line">        <span class="keyword">let</span> theme = <span class="keyword">new</span> eui.Theme(<span class="string">"resource/default.thm.json"</span>, <span class="keyword">this</span>.stage);</span><br><span class="line">        theme.addEventListener(eui.UIEvent.COMPLETE, <span class="keyword">this</span>.onThemeLoadComplete, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, <span class="keyword">this</span>.onResourceLoadComplete, <span class="keyword">this</span>);</span><br><span class="line">        RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, <span class="keyword">this</span>.onResourceLoadError, <span class="keyword">this</span>);</span><br><span class="line">        RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS, <span class="keyword">this</span>.onResourceProgress, <span class="keyword">this</span>);</span><br><span class="line">        RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, <span class="keyword">this</span>.onItemLoadError, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        RES.loadGroup(<span class="string">"loading"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> isThemeLoadEnd: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主题文件加载完成,开始预加载</span></span><br><span class="line"><span class="comment">     * Loading of theme configuration file is complete, start to pre-load the </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onThemeLoadComplete(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.isThemeLoadEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.createScene();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> isResourceLoadEnd: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * preload资源组加载完成</span></span><br><span class="line"><span class="comment">     * preload resource group is loaded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onResourceLoadComplete(event: RES.ResourceEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.groupName == <span class="string">'loading'</span>) &#123;</span><br><span class="line">            <span class="comment">//设置加载进度界面</span></span><br><span class="line">            <span class="keyword">this</span>.loadingView = <span class="keyword">new</span> LoadingUI();</span><br><span class="line">            <span class="keyword">this</span>.stage.addChild(<span class="keyword">this</span>.loadingView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.groupName == <span class="string">"preload"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stage.removeChild(<span class="keyword">this</span>.loadingView);</span><br><span class="line">            RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, <span class="keyword">this</span>.onResourceLoadComplete, <span class="keyword">this</span>);</span><br><span class="line">            RES.removeEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, <span class="keyword">this</span>.onResourceLoadError, <span class="keyword">this</span>);</span><br><span class="line">            RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, <span class="keyword">this</span>.onResourceProgress, <span class="keyword">this</span>);</span><br><span class="line">            RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, <span class="keyword">this</span>.onItemLoadError, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.isResourceLoadEnd = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.createScene();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用安卓接口，获取用户信息       </span></span><br><span class="line">            <span class="keyword">let</span> userInfo = <span class="built_in">window</span>.JsAndroidWebView.sendInfoToJs()</span><br><span class="line">            sessionStorage.setItem(<span class="string">'androidUserInfo'</span>, userInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> createScene() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isThemeLoadEnd &amp;&amp; <span class="keyword">this</span>.isResourceLoadEnd) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startCreateScene();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源组加载出错</span></span><br><span class="line"><span class="comment">     *  The resource group loading failed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onItemLoadError(event: RES.ResourceEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">"Url:"</span> + event.resItem.url + <span class="string">" has failed to load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源组加载出错</span></span><br><span class="line"><span class="comment">     * Resource group loading failed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onResourceLoadError(event: RES.ResourceEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">"Group:"</span> + event.groupName + <span class="string">" has failed to load"</span>);</span><br><span class="line">        <span class="comment">//忽略加载失败的项目</span></span><br><span class="line">        <span class="comment">//ignore loading failed projects</span></span><br><span class="line">        <span class="keyword">this</span>.onResourceLoadComplete(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * preload资源组加载进度</span></span><br><span class="line"><span class="comment">     * loading process of preload resource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> onResourceProgress(event: RES.ResourceEvent): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.groupName == <span class="string">"preload"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadingView.setProgress(event.itemsLoaded, event.itemsTotal);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> textfield: egret.TextField;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建场景界面</span></span><br><span class="line"><span class="comment">     * Create scene interface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> startCreateScene(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">new</span> GameScene())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Loading页"><a href="#Loading页" class="headerlink" title="Loading页"></a>Loading页</h2><h3 id="LoadingUISkin-exml-皮肤"><a href="#LoadingUISkin-exml-皮肤" class="headerlink" title="LoadingUISkin.exml 皮肤"></a>LoadingUISkin.exml 皮肤</h3><p>给一个蓝色的矩形背景。</p><p>包含用于显示进度条的外框以及一小段进度条。</p><p>并且在代码中，添加一个序列帧动画到当前皮肤中。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502853632002.jpg" alt=""></p><h3 id="LoadingUI-ts"><a href="#LoadingUI-ts" class="headerlink" title="LoadingUI.ts"></a>LoadingUI.ts</h3><p>添加到动画帧到舞台中，在每一次的资源数回调函数中，播放动画，实现每次加载一个资源，人物的脚步开始运动。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LoadingUI <span class="keyword">extends</span> eui.Component &#123;</span><br><span class="line">    <span class="keyword">private</span> solomc: egret.MovieClip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.once(eui.UIEvent.COMPLETE, <span class="keyword">this</span>.uiComplete,<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.skinName = <span class="string">'src/LoadingUISkin.exml'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> uiComplete(e:eui.UIEvent)&#123;</span><br><span class="line">        <span class="keyword">this</span>.initMC()</span><br><span class="line">        RES.loadGroup(<span class="string">"preload"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> initMC(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = RES.getRes(<span class="string">'solo_loading_json'</span>)</span><br><span class="line">        <span class="keyword">let</span> txtr = RES.getRes(<span class="string">'solo_loading_png'</span>) </span><br><span class="line">        <span class="keyword">let</span> mcFactory: egret.MovieClipDataFactory = <span class="keyword">new</span> egret.MovieClipDataFactory(data, txtr)</span><br><span class="line">        <span class="keyword">this</span>.solomc = <span class="keyword">new</span> egret.MovieClip(mcFactory.generateMovieClipData(<span class="string">'loading'</span>))</span><br><span class="line">        <span class="keyword">this</span>.solomc.x = <span class="number">220</span></span><br><span class="line">        <span class="keyword">this</span>.solomc.y = <span class="number">500</span></span><br><span class="line">        <span class="keyword">this</span>.addChild(<span class="keyword">this</span>.solomc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> loadingLabel: eui.Label</span><br><span class="line">    <span class="keyword">private</span> loadingBorder: eui.Image</span><br><span class="line">    <span class="keyword">private</span> loadingPer: eui.Image</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> setProgress(current: <span class="built_in">number</span>, total: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.solomc.gotoAndPlay(<span class="string">'moving'</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> percentage: <span class="built_in">string</span> = (current / total * <span class="number">100</span>).toFixed(<span class="number">0</span>).toString()</span><br><span class="line">        <span class="keyword">this</span>.loadingLabel.text = <span class="string">`<span class="subst">$&#123;percentage&#125;</span>`</span></span><br><span class="line">        <span class="keyword">this</span>.loadingPer.width = (<span class="keyword">this</span>.loadingBorder.width - <span class="number">6</span>) * <span class="built_in">parseFloat</span>(percentage) / <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502854056576.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现Loading页面的方法有好多，这里的方法是，使用EUI皮肤的加载页，可配置型和可定制型程度更高，也更易用。但不是最好的方法。&lt;/p&gt;
&lt;h2 id=&quot;资源的处理&quot;&gt;&lt;a href=&quot;#资源的处理&quot; class=&quot;headerlink&quot; title=&quot;资源的处理&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Egret" scheme="https://luoyec.cn/categories/Egret/"/>
    
    
      <category term="Egret" scheme="https://luoyec.cn/tags/Egret/"/>
    
      <category term="加载页" scheme="https://luoyec.cn/tags/%E5%8A%A0%E8%BD%BD%E9%A1%B5/"/>
    
      <category term="序列帧动画" scheme="https://luoyec.cn/tags/%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>数组、栈、队列</title>
    <link href="https://luoyec.cn/2017/08/12/cl4e29qgf0092989eyrs24y0e/"/>
    <id>https://luoyec.cn/2017/08/12/cl4e29qgf0092989eyrs24y0e/</id>
    <published>2017-08-12T09:48:42.000Z</published>
    <updated>2017-08-12T09:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的创建与初始化"><a href="#数组的创建与初始化" class="headerlink" title="数组的创建与初始化"></a>数组的创建与初始化</h2><ul><li>new关键字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><ul><li>数组字面量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = []</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>检测某个对象是不是数组</p><h3 id="ES3中的方法"><a href="#ES3中的方法" class="headerlink" title="ES3中的方法"></a>ES3中的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（value <span class="keyword">instanceof</span> <span class="built_in">Array</span>）&#123;</span><br><span class="line"><span class="comment">//如果是数组，执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页面中包含多个框架，那实际上就存在两个以上的不同全局执行环境，从而存在两个以上的不同版本的Array构造函数。</p><h3 id="ES5中的方法，也是现在使用的方法"><a href="#ES5中的方法，也是现在使用的方法" class="headerlink" title="ES5中的方法，也是现在使用的方法"></a>ES5中的方法，也是现在使用的方法</h3><p>兼容性： IE9+</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value) &#123;</span><br><span class="line"><span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toString(): 返回数组中每个值的字符串形式拼接而成的一个以逗号隔开的字符串。</span><br><span class="line"></span><br><span class="line">valueOf()：返回的仍然是数组</span><br><span class="line"></span><br><span class="line">toLocaleString(): 在大多数情况与前两者相同，不同之初是调用数组中每一项的toLocaleString（），而不是toString（）方法。</span><br></pre></td></tr></table></figure><h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><h3 id="通过下标直接赋值"><a href="#通过下标直接赋值" class="headerlink" title="通过下标直接赋值:"></a>通过下标直接赋值:</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">numbers[<span class="number">5</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push()  <span class="comment">//可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度</span></span><br><span class="line"></span><br><span class="line">pop() <span class="comment">//从数组 末尾移除最后一项</span></span><br></pre></td></tr></table></figure><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shift() <span class="comment">//移除数组中的第一个项并返回，同时数组长度减一</span></span><br><span class="line"></span><br><span class="line">push() <span class="comment">//向数组末端添加元素</span></span><br><span class="line"></span><br><span class="line">unshift() <span class="comment">//在数组前端任意项并返回新数组的长度</span></span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat() 方法"></a>concat() 方法</h4><p>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello, "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hello.concat(<span class="string">"Kevin"</span>, <span class="string">" have a nice day."</span>)); <span class="comment">/* Hello, Kevin have a nice day. */</span></span><br></pre></td></tr></table></figure><h4 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice() 方法"></a>slice() 方法</h4><p>返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502518771526.jpg" alt=""></p><h4 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice() 方法"></a>splice() 方法</h4><p>通过删除现有元素和/或添加新元素来更改一个数组的内容</p><p>返回值: 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFish = [<span class="string">'angel'</span>, <span class="string">'clown'</span>, <span class="string">'mandarin'</span>, <span class="string">'sturgeon'</span>];</span><br><span class="line"></span><br><span class="line">myFish.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'drum'</span>); </span><br><span class="line"><span class="comment">// 在索引为2的位置插入'drum'</span></span><br><span class="line"><span class="comment">// myFish 变为 ["angel", "clown", "drum", "mandarin", "sturgeon"]</span></span><br><span class="line"></span><br><span class="line">myFish.splice(<span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 从索引为2的位置删除一项（也就是'drum'这一项）</span></span><br><span class="line"><span class="comment">// myFish 变为 ["angel", "clown", "mandarin", "sturgeon"]</span></span><br></pre></td></tr></table></figure><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><h4 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf() 方法"></a>indexOf() 方法</h4><p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line">a.indexOf(<span class="number">2</span>); <span class="comment">// 0 </span></span><br><span class="line">a.indexOf(<span class="number">6</span>); <span class="comment">// -1</span></span><br><span class="line">a.indexOf(<span class="number">7</span>); <span class="comment">// 2</span></span><br><span class="line">a.indexOf(<span class="number">8</span>); <span class="comment">// 3</span></span><br><span class="line">a.indexOf(<span class="number">9</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf(<span class="number">3</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// element doesn't exist in array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lastIndexOf-方法"><a href="#lastIndexOf-方法" class="headerlink" title="lastIndexOf() 方法"></a>lastIndexOf() 方法</h4><p>lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p><p>参数    描述<br>searchvalue    必需。规定需检索的字符串值。<br>fromindex    可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">7</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>对数组中的每一项运行给定函数，如果函数对每一项都返回true，则返回true</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>对数组中的每一项运行给定函数，返回给函数会返回true的数组</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>对数组中的每一项运行给定函数。这个方法没有返回值</p><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>对数组中的每一项运行给定函数，返回每次函数调用返回结果组成的数组。</p><h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>对数组中的每一项运行给定函数，如果任一个函数返回true，则返回true</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>从数组第一项开始，逐个遍历到最后。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum + value;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// total is 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="reduceRight（）"><a href="#reduceRight（）" class="headerlink" title="reduceRight（）"></a>reduceRight（）</h4><p>则从数组的最后一项开始，向前遍历到第一项。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待添加的元素都保存在栈的末尾，称作栈顶，另一端叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        items.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty())</span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.push(<span class="number">6</span>)</span><br><span class="line">stack.push(<span class="number">8</span>)</span><br><span class="line">stack.print()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">luoyecs-iMac:js数据结构与算法 LW-luoyec$ node stack.js</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">3,6,8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循FIFO（先进先出，也成为先来先服务）原则的一组有序的项。队列的尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        items.shift()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        items = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty())</span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="number">1</span>)</span><br><span class="line">queue.enqueue(<span class="number">2</span>)</span><br><span class="line">queue.enqueue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">queue.print()</span><br><span class="line"></span><br><span class="line">queue.dequeue()</span><br><span class="line"></span><br><span class="line">queue.print()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;数组的创建与初始化&quot;&gt;&lt;a href=&quot;#数组的创建与初始化&quot; class=&quot;headerlink&quot; title=&quot;数组的创建与初
      
    
    </summary>
    
      <category term="JS数据结构与算法" scheme="https://luoyec.cn/categories/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="https://luoyec.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://luoyec.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道四:注释</title>
    <link href="https://luoyec.cn/2017/08/12/cl4e29qfh007f989expqouud5/"/>
    <id>https://luoyec.cn/2017/08/12/cl4e29qfh007f989expqouud5/</id>
    <published>2017-08-11T17:06:29.000Z</published>
    <updated>2017-08-11T17:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对注释的态度"><a href="#对注释的态度" class="headerlink" title="对注释的态度"></a>对注释的态度</h1><p>注释的恰当用法是弥补我们在用代码表达意图是遭遇的失败。</p><p>程序员应当复杂将注释保持咋可维护、有关联、精确的高度。我同意这种说法，但我更主张把力气用在写清楚代码上，直接保证无须编写注释。</p><p>只是只在移除地方有：代码。只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。所以，尽管有时也需要注释，我们也应该花心思尽量减少注释量。</p><h1 id="注释不能美化糟糕的代码"><a href="#注释不能美化糟糕的代码" class="headerlink" title="注释不能美化糟糕的代码"></a>注释不能美化糟糕的代码</h1><p>与其花时间编写糟糕代码的注释，不如花时间清洁那堆糟糕的代码。</p><h1 id="用代码来阐述"><a href="#用代码来阐述" class="headerlink" title="用代码来阐述"></a>用代码来阐述</h1><p>很多时间，简单到只需要创建一个描述与注释所表达的同一意思的函数即可。</p><p>用更好的函数名代替注释<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502345231869.jpg" alt=""></p><h1 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h1><p> 唯一真正好的注释是你想办法不去写的注释。</p><h2 id="法律信息"><a href="#法律信息" class="headerlink" title="法律信息"></a>法律信息</h2><p> 每隔源文件开头放置的标准注释<br> <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502345366596.jpg" alt=""></p><p>这类注释不应是合同或法典，如有可能，就指向一份标准许可或外部文件。</p><h2 id="提供信息的注释"><a href="#提供信息的注释" class="headerlink" title="提供信息的注释"></a>提供信息的注释</h2><p>  有时，利用注释来提供基本信息，例如解释在某个抽象方法中返回值<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502345555639.jpg" alt=""><br>但是把函数重新命名为responderBeingTested, 注释就是多余的了。</p><h2 id="对意图的解释"><a href="#对意图的解释" class="headerlink" title="对意图的解释"></a>对意图的解释</h2><p>  注释不仅提供有关实现的有用信息，而且还可以提供某个决定后面的意图。即在注释中告诉别人你的想法。</p><h2 id="阐释"><a href="#阐释" class="headerlink" title="阐释"></a>阐释</h2><p>  用注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读形式，会是有用的。不过，通常更好的方法是尽量让参数或返回值自身就足够清除。</p><p>  当然要注意的是，要确认注释的正确性。</p><h2 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h2><p>  用于警告其他程序员会出现某种后果的注释。<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502345998391.jpg" alt=""></p><h2 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h2><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502346050409.jpg" alt=""></p><p>TODO是一种程序员认为应该做，但由于某些原因还没做的工作。他可能是要提醒删除某个不必要的特性，或者要求他人注意某个问题。</p><p>IDE都提供了TODO注释的定位及高亮功能，定期查看，删除不在需要的注释。</p><h2 id="放大"><a href="#放大" class="headerlink" title="放大"></a>放大</h2><p>  用注释强调某件事的重要性<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502346189103.jpg" alt=""></p><h2 id="公共API中的文档注释"><a href="#公共API中的文档注释" class="headerlink" title="公共API中的文档注释"></a>公共API中的文档注释</h2><p>  如果在编写公共API，就应该编写良好的文档</p><h1 id="坏注释"><a href="#坏注释" class="headerlink" title="坏注释"></a>坏注释</h1><p> 大多数注释都属于此类，通常坏注释都是糟糕代码的支撑或接口，或者对错误决策的修正。基本上等于程序员自说自话。</p><h2 id="喃喃自语"><a href="#喃喃自语" class="headerlink" title="喃喃自语"></a>喃喃自语</h2><p>如果只是因为你觉得应该或者因为过程需要添加注释，那就是无谓之举。如果你决定写注释，就必须花时间写好注释。</p><h2 id="多余的注释"><a href="#多余的注释" class="headerlink" title="多余的注释"></a>多余的注释</h2><p>这种注释并不能比代码本身提供更多信息，它没能证明代码的意义，也没能给出代码的意图或逻辑。</p><p>多余的注释：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502359078882.jpg" alt=""></p><h2 id="误导性注释"><a href="#误导性注释" class="headerlink" title="误导性注释"></a>误导性注释</h2><p>  避免描述不够准确、歧义、误导性的注释，如果连你自己都没搞懂注释的意义，为什么期待别人能懂呢？</p><h2 id="循规式注释"><a href="#循规式注释" class="headerlink" title="循规式注释"></a>循规式注释</h2><p>  每隔函数都要有说明或者每个变量都要有注释。这类注释徒然让代码变得散乱，满口胡言，令人迷糊不解。</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502359318645.jpg" alt=""></p><h2 id="日志式注释"><a href="#日志式注释" class="headerlink" title="日志式注释"></a>日志式注释</h2><h2 id="废话注释"><a href="#废话注释" class="headerlink" title="废话注释"></a>废话注释</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502359447933.jpg" alt=""></p><p>用整理代码的决心替代创造废话的冲动吧。你会发现自己成为更优秀、更快乐的程序员。</p><h2 id="可怕的废话"><a href="#可怕的废话" class="headerlink" title="可怕的废话"></a>可怕的废话</h2><h2 id="能用函数或者变量就别用注释"><a href="#能用函数或者变量就别用注释" class="headerlink" title="能用函数或者变量就别用注释"></a>能用函数或者变量就别用注释</h2><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502470237720.jpg" alt=""></p><h2 id="括号后的注释"><a href="#括号后的注释" class="headerlink" title="括号后的注释"></a>括号后的注释</h2><p> 尽管这对于含有深度嵌套结构函数可能有意义，但只会给我们更愿意编写短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的事缩短函数。</p><h2 id="注释掉的代码"><a href="#注释掉的代码" class="headerlink" title="注释掉的代码"></a>注释掉的代码</h2><p> 别这么干，直接注释代码，会让你的同事怀疑这代码到底有什么用，造成混乱。</p><h2 id="非本地信息"><a href="#非本地信息" class="headerlink" title="非本地信息"></a>非本地信息</h2><p> 假如你一定要写注释，请确保描述了离它最近的代码。</p><h2 id="信息过多"><a href="#信息过多" class="headerlink" title="信息过多"></a>信息过多</h2><p> 别在注释中添加历史性话题、或者无关的细节描述。</p><h2 id="不明显的联系"><a href="#不明显的联系" class="headerlink" title="不明显的联系"></a>不明显的联系</h2><p> 注释及其描述代码之间的联系应该显而易见。</p><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p> 作者的另一本书《敏捷软件开发：原则、模式与实践》</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502471043353.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502471061738.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502471076573.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对注释的态度&quot;&gt;&lt;a href=&quot;#对注释的态度&quot; class=&quot;headerlink&quot; title=&quot;对注释的态度&quot;&gt;&lt;/a&gt;对注释的态度&lt;/h1&gt;&lt;p&gt;注释的恰当用法是弥补我们在用代码表达意图是遭遇的失败。&lt;/p&gt;
&lt;p&gt;程序员应当复杂将注释保持咋可维护、有关
      
    
    </summary>
    
      <category term="代码整洁之道" scheme="https://luoyec.cn/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁" scheme="https://luoyec.cn/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
      <category term="提高" scheme="https://luoyec.cn/tags/%E6%8F%90%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>Git 工作流指南（总结&amp;&amp;实践）</title>
    <link href="https://luoyec.cn/2017/08/10/cl4e29qc60010989ec8r10g10/"/>
    <id>https://luoyec.cn/2017/08/10/cl4e29qc60010989ec8r10g10/</id>
    <published>2017-08-10T15:18:21.000Z</published>
    <updated>2017-08-10T15:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译序"><a href="#译序" class="headerlink" title="译序"></a>译序</h1><blockquote><p>操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。</p></blockquote><blockquote><p>工作流其实不是一个初级主题，背后的本质问题其实是 有效的项目流程管理 和<br>高效的开发协同约定，而不仅是Git或SVN等VCS或SCM工具的使用。</p></blockquote><blockquote><p>关于Git工作流主题，网上体系的中文资料不多，主要是零散的操作说明，希望这篇文章能让你更深入理解并在工作中灵活有效地使用起来。</p></blockquote><blockquote><p>Gitflow工作流是经典模型，处于核心位置，体现了工作流的经验和精髓。随着项目过程复杂化，你会感受到这个工作流中的深思熟虑和威力！</p></blockquote><h1 id="工作流指南"><a href="#工作流指南" class="headerlink" title="工作流指南"></a>工作流指南</h1><blockquote><p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览公司团队中最常用的几种Git工作流让大家可以上手使用。</p></blockquote><h2 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h2><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501233460214.jpg" alt="集中式工作流"></p><blockquote><p>但使用Git加强开发的工作流，Git有相比SVN的几个优势。 首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分修改独立开来 —— 即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。</p></blockquote><blockquote><p>其次，Git提供了强壮的分支和合并模型。不像SVN，Git的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。</p></blockquote><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><blockquote><p>本工作流只用到master这一个分支。</p></blockquote><blockquote><p>开发者开始先克隆中央仓库。在自己的项目拷贝中像SVN一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。</p></blockquote><blockquote><p>要发布修改到正式项目中，开发者要把本地master分支的修改『推』到中央仓库中。这相当于svn commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501233676237.jpg" alt="上部分为中央仓库"></p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><blockquote><p>如果开发者本地的提交历史和中央仓库有分歧，Git会拒绝push提交，防止覆盖中央仓库的正式提交</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501233844558.jpg" alt="开发者拉取更新，解决冲突，再次提交"></p><blockquote><p>在开发者提交自己功能修改到中央库前，需要先fetch在中央库的新增提交，rebase自己提交到中央库提交历史之上。 这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的SVN的工作流中一样。</p></blockquote><blockquote><p>如果本地修改和上游提交有冲突，Git会暂停rebase过程，给你手动解决冲突的机会。Git解决合并冲突，用和生成提交一样的git status和git add命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，Git可以很简单中止整个rebase操作，重来一次（或者让别人来帮助解决）。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote><p>有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。</p></blockquote><h4 id="初始化好中央仓库"><a href="#初始化好中央仓库" class="headerlink" title="初始化好中央仓库"></a>初始化好中央仓库</h4><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501234128670.jpg" alt="中央仓库"></p><h4 id="所有人克隆中央仓库"><a href="#所有人克隆中央仓库" class="headerlink" title="所有人克隆中央仓库"></a>所有人克隆中央仓库</h4><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501234462110.jpg" alt="克隆中央仓库"></p><p>大家好，我是小明</p><p>小明克隆中央仓库，并且add commit， 不断开发，直至完成<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> clone ssh:<span class="comment">//user@host/path/to/repo.git</span></span><br><span class="line"></span><br><span class="line"><span class="number">3273</span>ecf (HEAD -&gt; master, origin/master) HEAD@&#123;<span class="number">0</span>&#125;: commit: 完成开发</span><br><span class="line">f2faa43 HEAD@&#123;<span class="number">1</span>&#125;: commit: 正在开发</span><br><span class="line"><span class="number">335</span>a4b4 HEAD@&#123;<span class="number">2</span>&#125;: commit (<span class="attribute">initial</span>): 准备阶段</span><br></pre></td></tr></table></figure></p><p>小明发布功能，因此此时中央仓库是空，小明可以直接提价到中央仓库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> push origin master</span><br></pre></td></tr></table></figure><blockquote><p>注意，origin是在小明克隆仓库时Git创建的远程中央仓库别名。master参数告诉Git推送的分支。 由于中央仓库自从小明克隆以来还没有被更新过，所以push操作不会有冲突，成功完成。</p></blockquote><hr><p>大家好，我是小红</p><p>小红也clone了中央仓库，并且进行了歼星舰项目开发，也不断到add commit，直至开发完成</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> clone http:<span class="comment">//luoyec@103.224.81.114:6605/luoyec/git_practise.git</span></span><br><span class="line"></span><br><span class="line">ddc6c37 HEAD@&#123;<span class="number">5</span>&#125;: commit: 舰艇开发完成</span><br><span class="line"><span class="number">2899</span>f26 HEAD@&#123;<span class="number">6</span>&#125;: commit: 引擎装载完成</span><br><span class="line"><span class="number">29</span>b95cc HEAD@&#123;<span class="number">7</span>&#125;: commit (<span class="attribute">initial</span>): 材料准备中</span><br></pre></td></tr></table></figure><p>小红也想发布自己功能，但此时，中央仓库也有小明提交但代码，本地历史已经和中央仓库有分岐了，Git不想理你，并扔给你一堆提示信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">luoyecs-iMac:git_practise LW-luoyec$ git push</span><br><span class="line">To http:<span class="comment">//103.224.81.114:6605/luoyec/git_practise.git</span></span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'http://luoyec@103.224.81.114:6605/luoyec/git_practise.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e<span class="selector-class">.g</span>., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> <span class="selector-tag">details</span>.</span><br></pre></td></tr></table></figure><blockquote><p>这避免了小红覆写正式的提交。她要先pull小明的更新到她的本地仓库合并上她的本地修改后，再重试。</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501236684426.jpg" alt="git pull"></p><p>小红用git pull合并上游的修改到自己的仓库中。 这条命令类似svn update——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git pull --rebase <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>==–rebase==选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部，如下图所示：<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501236860358.jpg" alt="小红的仓库"></p><p>如果你忘加了这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用rebase而不是生成一个合并提交。</p><p>小红解决合并冲突</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501236974942.jpg" alt="解决合并冲突"></p><h3 id="冲突解决工具diffmerge"><a href="#冲突解决工具diffmerge" class="headerlink" title="冲突解决工具diffmerge"></a>冲突解决工具diffmerge</h3><p><a href="https://www.sourcegear.com/diffmerge/" target="_blank" rel="noopener">下载地址DMG版</a><br>全局配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge<span class="selector-class">.tool</span> diffmerge</span><br><span class="line">git config --global mergetool<span class="selector-class">.diffmerge</span><span class="selector-class">.cmd</span> <span class="string">"/Applications/DiffMerge.app/Contents/MacOS/diffmerge --merge --result=\$MERGED \$LOCAL \$BASE \$REMOTE"</span></span><br><span class="line">git config --global mergetool<span class="selector-class">.keepBackup</span> false</span><br><span class="line"> </span><br><span class="line">git config --global diff<span class="selector-class">.tool</span> diffmerge</span><br><span class="line">git config --global difftool<span class="selector-class">.diffmerge</span><span class="selector-class">.cmd</span> <span class="string">"/Applications/DiffMerge.app/Contents/MacOS/diffmerge \$LOCAL \$REMOTE"</span></span><br></pre></td></tr></table></figure><p>当出现冲突时，执行命令，弹出窗口手动解决冲突</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> mergetool</span><br></pre></td></tr></table></figure><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501260875775.jpg" alt="中间是合并后结果"></p><p>完成合并，保存退出图形化工具<br>已经手动解决了冲突，这是让rebase继续工作，执行命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;冲突文件/.  表示所有修改文件&gt;</span><br><span class="line">git rebase --continue   <span class="comment">//rebase继续工作</span></span><br><span class="line">git push    <span class="comment">//代码成功提交</span></span><br></pre></td></tr></table></figure><p><strong>ps:</strong></p><blockquote><p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：</p></blockquote><p>==git rebase –abort 是无风险的操作，会回到rebase操作之前的状态，2个分支的commits毫发无损。<br>git rebase –skip 是高风险的操作，引起冲突的commits会被丢弃（这部分代码修改会丢失）。==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//解决冲突失败，或者向重新解决冲突</span><br><span class="line"><span class="meta">$</span>git rebase --abort</span><br><span class="line">//Skip是跳过这个错误，继续本次操作</span><br><span class="line">git rebase --skip</span><br></pre></td></tr></table></figure><h2 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h2><blockquote><p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。<br>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。<br>另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。</p></blockquote><h3 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h3><blockquote><p>开发者每次在开始新功能前先创建一个新分支。<br>功能分支应该有个有描述性的名字，比如animated-menu-items或issue-#1061</p></blockquote><blockquote><p>在master分支和功能分支之间，Git是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。</p></blockquote><blockquote><p>功能分支也可以（且应该）push到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。<br>由于master是仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题</p></blockquote><h3 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><p>一旦完成某个功能的开发，不是立即合并到master，而是push到中央仓库到功能分之，并且在分支上发起一个push requests请求合并到master。在修改成为主干代码前，这让其他的开发者有机会去review变更。</p><blockquote><p>一个开发者开发功能需要帮助时，要做的就是发起一个Pull<br>Request，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。</p></blockquote><blockquote><p>一旦Pull Request被接受了，发布功能要做的就和集中式工作流就很像了。 首先，确定本地的master分支和上游的master分支是同步的。然后合并功能分支到本地master分支并push已经更新的本地master分支到中央仓库。</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>小红开始开发一个新功能<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501262212390.jpg" alt="小红的新功能"><br>在开始开发功能钱，小红需要一个独立到分支，这里新建一个分支</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-b 不存在则创建， 基于master但new-feature分支</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> new-feature master</span><br></pre></td></tr></table></figure><p>小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>小红完成开发，push功能分支到中央仓库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-u选项设置本地分支去跟踪远程对应的分支, 之后到开发可以省略-u</span></span><br><span class="line">git push -u origin new-feature</span><br></pre></td></tr></table></figure><p>这样功能分支就被提交到中央仓库，这里可以看到有两个分支<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501262689950.jpg" alt="新增到功能分支"></p><p>小红在她的Git GUI客户端中发起Pull Request，请求合并marys-feature到master，团队成员会自动收到通知。这时候小黑，对新功能有自己对想法，决定拉取new-feature到本地，进行修改。</p><p>小黑对新功能的开发</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保当前最新的</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment">//查看当前所有对分支，可以看到小红提交的分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">commit</span><br><span class="line">push</span><br></pre></td></tr></table></figure><p>小黑完成了开发，准备将新功能合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）</p><p>发布流程<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检出到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment">//拉取最新仓库</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment">//new-feature分支到和已经和远程一致的本地master分支</span></span><br><span class="line">git pull origin new-feature</span><br><span class="line"><span class="comment">//更新远程master分支</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><blockquote><p>无论谁来做合并，首先要检出master分支并确认是它是最新的。然后执行git pull origin<br>marys-feature合并marys-feature分支到和已经和远程一致的本地master分支。 你可以使用简单git merge<br>marys-feature命令，但前面的命令可以保证总是最新的新功能分支。 最后更新的master分支要重新push回到origin。</p></blockquote><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p>Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264112296.jpg" alt="Gitflow"></p><p>Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p><p>Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。 除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。 当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。</p><h3 id="工作方式-2"><a href="#工作方式-2" class="headerlink" title="工作方式"></a>工作方式</h3><p>Gitflow工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并push分支到要中央仓库中。</p><h3 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h3><p>相对使用仅有的一个master分支，Gitflow工作流使用2个分支来记录项目的历史。master分支存储了正式发布的历史，而develop分支作为功能的集成分支。 这样也方便master分支上的所有提交分配一个版本号。<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264213351.jpg" alt="历史分支"></p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。 但功能分支不是从master分支上拉出新分支，==而是使用develop分支作为父分支==。当新功能完成时，合并回develop分支。 新功能提交应该从不直接与master分支交互。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264288286.jpg" alt="新功能分支不直接与master分支交互"></p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264382340.jpg" alt="develop分支发布"><br>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上checkout一个发布分支。 新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上—— ==这个分支只应该做Bug修复、文档生成和其它面向发布任务==。 一旦对外发布的工作都完成了，发布分支合并到master分支并分配一个版本号打好Tag。 另外，这些从新建发布分支以来的做的修改要合并回develop分支。</p><p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。</p><p>常用的分支约定：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于新建发布分支的分支: develop</span><br><span class="line">用于合并的分支: master</span><br><span class="line">分支命名: release-* 或 release/*</span><br></pre></td></tr></table></figure><h3 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h3><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264616862.jpg" alt="分支维护"><br>维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从master分支fork出来的分支。 修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。</p><p>为Bug修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。 你可以把维护分支想成是一个直接在master分支上处理的临时发布。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ul><li>创建开发分支<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264701624.jpg" alt="新分支"><br>第一步为master分支配套一个develop分支。简单来做可以本地创建一个空的develop分支，push到服务器上</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>以后这个分支将会包含了项目的全部历史，而master分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好develop分支的跟踪分支：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh:<span class="comment">//user@host/path/to/repo.git</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> develop origin/develop</span><br></pre></td></tr></table></figure><p>现在每个开发都有了这些历史分支的本地拷贝。</p><ul><li>小红和小明开始开发新功能<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501264926856.jpg" alt="各自新建功能分支"></li></ul><p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于master分支，而是应该基于develop分支：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> some-feature develop</span><br></pre></td></tr></table></figure><p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><ul><li>小红完成功能开发<br>添加了提交后，小红觉得她的功能OK了。如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。 否则她可以直接合并到她本地的develop分支后push到中央仓库：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge some-feature</span><br><span class="line">git push</span><br><span class="line">git branch -d some-feature</span><br></pre></td></tr></table></figure><p>第一条命令在合并功能前确保develop分支是最新的。注意，功能决不应该直接合并到master分支。 冲突解决方法和集中式工作流一样。</p><ul><li>小红开始准备发布<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501265120984.jpg" alt="功能发布"><br>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。 像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个基于develop对分支用于版本发布，此时并不会影响其他开发者</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> release-<span class="number">0.1</span> develop</span><br></pre></td></tr></table></figure><p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p><p>只要小红创建这个分支并push到中央仓库，这个发布就是功能冻结的。任何不在develop分支中的新功能都推到下个发布循环中。</p><ul><li>小红完成发布<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501265265791.jpg" alt="完成发布"><br>一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。 另外，如果小红的团队要求Code Review，这是一个发起Pull Request的理想时机。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">两次检出，两次合并，为的是合并到master和develop</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge release-<span class="number">0.1</span></span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge release-<span class="number">0.1</span></span><br><span class="line">git push</span><br><span class="line">git branch -d release-<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。只要有合并到master分支，就应该打好Tag以方便跟踪。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="selector-tag">a</span> <span class="number">0.1</span> -m <span class="string">"Initial public release"</span> master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>Git有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。 可以配置一个勾子，在你push中央仓库的master分支时，==自动构建==好对外发布。</p><ul><li>最终用户发现Bug<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501265444329.jpg" alt="bug分支"><br>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。 为了处理Bug，小红（或小明）从master分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回master分支：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从master分支中拉出一个bug分支，解决完后合并到master</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> issue-<span class="number">#001</span> master</span><br><span class="line"># Fix the bug</span><br><span class="line">git checkout master</span><br><span class="line">git merge issue-<span class="number">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-<span class="number">#001</span></span><br><span class="line">git push</span><br><span class="line">git branch -d issue-<span class="number">#001</span></span><br></pre></td></tr></table></figure><p>到了这里，但愿你对集中式工作流、功能分支工作流和Gitflow工作流已经感觉很舒适了。 你应该也牢固的掌握了本地仓库的潜能，push/pull模式和Git健壮的分支和合并模型。</p><h2 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a>Forking工作流</h2><p>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能==接受不信任==贡献者（contributor）的提交。</p><p>Forking工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501265628687.jpg" alt="fork仓库成为私有仓库"><br>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。 开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。 这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。</p><p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。 也让这个工作流成为开源项目的理想工作流。</p><h3 id="工作方式-3"><a href="#工作方式-3" class="headerlink" title="工作方式"></a>工作方式</h3><p>和其它的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上。 但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。</p><p>这个仓库拷贝作为他个人公开仓库 —— 其它开发者不允许push到这个仓库，但可以pull到修改（后面我们很快就会看这点很重要）。 在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。</p><p>要提交本地修改时，push提交到自己公开仓库中 —— 而不是正式仓库中。 然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。 对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。</p><p>为了集成功能到正式代码库，==维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错， 合并变更到自己本地的master分支， 然后pushmaster分支到服务器的正式仓库中==。 到此，贡献的提交成为了项目的一部分，其它的开发者应该执行pull操作与正式仓库同步自己本地仓库。</p><h3 id="正式仓库"><a href="#正式仓库" class="headerlink" title="正式仓库"></a>正式仓库</h3><p>在Forking工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。 从技术上来看，各个开发者仓库和正式仓库在Git看来没有任何区别。 事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。</p><h3 id="Forking工作流的分支使用方式"><a href="#Forking工作流的分支使用方式" class="headerlink" title="Forking工作流的分支使用方式"></a>Forking工作流的分支使用方式</h3><p>所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。 各个开发者应该用分支隔离各个功能，就像在功能分支工作流和Gitflow工作流一样。 唯一的区别是这些分支被共享了。在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和Gitflow工作流中是直接被push到正式仓库中。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><ul><li>项目维护者初始化正式仓库<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266118510.jpg" alt=""><br>和任何使用Git项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。 通常这个仓库也会作为项目维护者的公开仓库。</li></ul><p>公开仓库应该是裸仓库，不管是不是正式代码库。 所以项目维护者会运行像下面的命令来搭建正式仓库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host</span><br><span class="line">git init --bare /path/to/repo.git</span><br></pre></td></tr></table></figure><p>Bitbucket和Stash提供了一个方便的GUI客户端以完成上面命令行做的事。 这个搭建中央仓库的过程和前面提到的工作流完全一样。 如果有现存的代码库，维护者也要push到这个仓库中。</p><ul><li>开发者fork正式仓库</li></ul><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266203182.jpg" alt=""><br>其它所有的开发需要fork正式仓库。 可以用git clone命令用SSH协议连通到服务器， 拷贝仓库到服务器另一个位置 —— 是的，fork操作基本上就只是一个服务端的克隆。 Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。</p><p>这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。</p><ul><li>开发者克隆自己fork出来的仓库<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266243908.jpg" alt=""></li></ul><p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。</p><p>在这个示例中，假定用Bitbucket托管了仓库。记住，如果这样的话各个开发者需要有各自的Bitbucket账号， 使用下面命令克隆服务端自己的仓库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//user@bitbucket.org/user/repo.git</span></span><br></pre></td></tr></table></figure><p>相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名 （这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https:<span class="comment">//bitbucket.org/maintainer/repo</span></span><br></pre></td></tr></table></figure><p>需要自己用上面的命令创建upstream别名。这样可以简单地保持本地仓库和正式仓库的同步更新。 注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https:<span class="comment">//user@bitbucket.org/maintainer/repo.git</span></span><br></pre></td></tr></table></figure><p>这时在克隆和pull正式仓库时，需要提供用户的密码。</p><ul><li>开发者开发自己的功能<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266413725.jpg" alt=""><br>在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、提交修改和新建分支：</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"># Edit <span class="built_in">some</span> code</span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure><p>所有的修改都是私有的直到push到自己公开仓库中。如果正式项目已经往前走了，可以用git pull命令获得新的提交：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git pull upstream master</span></span><br></pre></td></tr></table></figure><ul><li>开发者发布自己的功能<br>由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266500822.jpg" alt=""></li></ul><p>一旦开发者准备好了分享新功能，需要做二件事。 首先，通过push他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。 他的origin远程别名应该已经有了，所以要做的就是：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">feature</span>-branch</span><br></pre></td></tr></table></figure><p>这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。</p><p>第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。 Bitbucket和Stash提供了Pull Request按钮，弹出表单让你指定哪个分支要合并到正式仓库。 一般你会想集成你的功能分支到上游远程仓库的master分支中。</p><ul><li>项目维护者集成开发者的功能</li></ul><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266604190.jpg" alt=""><br>当项目维护者收到pull request，他要做的是决定是否集成它到正式代码库中。有二种方式来做：</p><p>直接在pull request中查看代码<br>pull代码到他自己的本地仓库，再手动合并<br>第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。 但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支， 合并到他本地的master分支，解决冲突：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https:<span class="comment">//bitbucket.org/user/repo feature-branch</span></span><br><span class="line"># 查看变更</span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><p>变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其它的开发者都能访问到：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。</p><ul><li>开发者和正式仓库做同步<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501266715570.jpg" alt=""><br>由于正式代码库往前走了，其它的开发需要和正式仓库做同步：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git pull upstream master</span></span><br></pre></td></tr></table></figure><p>如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。 但不要害怕，这个工作流实际上就是在功能分支工作流之上引入另一个抽象层。 不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。</p><p>示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但同样的方法可以把贡献集成到任一个仓库中。 比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。</p><p>这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。</p><h3 id="参考链接：xirongGit仓库"><a href="#参考链接：xirongGit仓库" class="headerlink" title="参考链接：xirongGit仓库"></a>参考链接：<a href="https://github.com/xirong/my-git" target="_blank" rel="noopener">xirongGit仓库</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;译序&quot;&gt;&lt;a href=&quot;#译序&quot; class=&quot;headerlink&quot; title=&quot;译序&quot;&gt;&lt;/a&gt;译序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="Git" scheme="https://luoyec.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://luoyec.cn/tags/Git/"/>
    
      <category term="多人合作" scheme="https://luoyec.cn/tags/%E5%A4%9A%E4%BA%BA%E5%90%88%E4%BD%9C/"/>
    
      <category term="SVN" scheme="https://luoyec.cn/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Git基础入门</title>
    <link href="https://luoyec.cn/2017/08/10/cl4e29qc90014989ex27rnbop/"/>
    <id>https://luoyec.cn/2017/08/10/cl4e29qc90014989ex27rnbop/</id>
    <published>2017-08-10T15:13:02.000Z</published>
    <updated>2017-08-10T15:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git分支管理多人合作</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init  //不可以手动修改.git目录$ vim readme   //新建一个readme文件$ git add readme.md  //把文件添加到暂缓区$ git commit -m &quot;wrote a readme file&quot; //把文件提交到仓库</span><br></pre></td></tr></table></figure><h1 id="在github仓库，第一次创建"><a href="#在github仓库，第一次创建" class="headerlink" title="在github仓库，第一次创建"></a>在github仓库，第一次创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# React-Node&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/lyctea/React-Node.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h1 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status  //查看仓库的当前状态$ git diff   //查看difference, 没问题则 add--&gt;commit$ git log    //最近到最远的提交日志 信息太多可以加--pretty=oneline</span><br></pre></td></tr></table></figure><h1 id="回退机制"><a href="#回退机制" class="headerlink" title="回退机制"></a>回退机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  //历史日志,可以查看所有操作,如果在回退以后又想再次回到之前的版本$ git reset --hard d020e0c  //跳转到指定的commit</span><br></pre></td></tr></table></figure><h1 id="工作区-暂缓区-分支"><a href="#工作区-暂缓区-分支" class="headerlink" title="工作区 暂缓区 分支"></a>工作区 暂缓区 分支</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add  //从工作区添加到暂缓区$ git commit //从暂缓区添加到分支</span><br></pre></td></tr></table></figure><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- resetTest.txt  //让工作区恢复到最近一次commit或者add时的状态$ git reset HEAD resetTest.txt  //当已经add的文件, 回退到工作区, 然后使用checkout可以撤销修改</span><br></pre></td></tr></table></figure><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm resetTest.txt  //删除本地文件$ git checkout -- resetTest.txt  //不想删除, 检出 保持工作区和仓库一致$ git rm resetTest.txt      //从仓库中删除$ git commit -m &quot;rm test&quot;   //并且commit</span><br></pre></td></tr></table></figure><h1 id="远程仓库-SSH"><a href="#远程仓库-SSH" class="headerlink" title="远程仓库 SSH"></a>远程仓库 SSH</h1><h2 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><h2 id="登陆GitHub-点“Add-SSH-Key”-填上任意Title，在Key文本框里粘贴id-rsa-pub文件的内容"><a href="#登陆GitHub-点“Add-SSH-Key”-填上任意Title，在Key文本框里粘贴id-rsa-pub文件的内容" class="headerlink" title="登陆GitHub 点“Add SSH Key” 填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容"></a>登陆GitHub 点“Add SSH Key” 填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</h2><h2 id="在github上创建仓库"><a href="#在github上创建仓库" class="headerlink" title="在github上创建仓库"></a>在github上创建仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git //连接远程仓库 origin是远程仓库名字$ git push -u origin master  //把本地仓库内容推送到远程库上/*推送报错, 以下解决方法 :可以通过如下命令进行代码合并【注：pull=fetch+merge]git pull --rebase origin master此时再执行语句 git push -u origin master即可完成代码上传到github*/</span><br></pre></td></tr></table></figure><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><h3 id="第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告-这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。"><a href="#第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告-这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。" class="headerlink" title="第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告, 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。"></a>第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告, 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</h3><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><hr><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev$ git checkout dev/*    也可以一条命令 git checkout  -b dev  //创建并切换*/    $ git branch  //列出所有分支，当前分支前面会标一个*号</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev //合并指定分支到当前分支</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev //Git鼓励大量使用分支 合并后删除</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>新建一个分支, 并且commit , 当新建分支内容和master分支没有冲突的时候, 可以用自动合并分支处理.当出现冲突时, 自动合并失效, 需要手动处理冲突 . 解决完之后, commit版本 删除新建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容*/$ git log --graph --pretty=oneline --abbrev-commit  //查看合并分支的情况$ git log --graph  //查看分支合并图</span><br></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*    强制禁用Fast forward模式，Git就会在merge时生成一个新的commit*/$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><h3 id="建议使用的分支管理策略"><a href="#建议使用的分支管理策略" class="headerlink" title="建议使用的分支管理策略"></a>建议使用的分支管理策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</span><br></pre></td></tr></table></figure><h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件开发中，BUG 就像家常便饭一样。BUG 就需要修复，在Git中，由于分支是如此的强大，所以，BUG 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*    概览：master合并merge解决好的bug后，不要先把dev解印，先合并master，获取里面的bug方案后，在解印。解印时会有提示冲突，需手动改一次文件。        1：在  dev 下正常开发中，说有1个bug要解决，首先我需要把dev分支封存stash        2：在master下新建一个issue-101分支，解决bug，成功后        3：在master下合并issue-101        4：在 dev  下合并master，  这样才同步了里面的bug解决方案        5：解开dev封印stash pop，系统自动合并 &amp; 提示有冲突，因为封存前dev写了东西，此时去文件里手动改冲突        6：继续开发dev，最后add，commit        7：在master下合并最后完成的dev        代码过程如下：*/1： $ git stash2： $ git checkout master   $ git checkout -b issue-101    //去文件里修bug    $ git add README.md    $ git commit -m &quot;fix-issue-101&quot;3： $ git checkout master   $ git merge --no-ff -m &quot;m-merge-issue-101&quot; issue-101   $ git branch -d issue-1014： $ git checkout dev    $ git merge --no-ff -m &quot;dev-merge-m&quot; master5： $ git stash list  //查看冻结列表,以便恢复    $ git stash pop            //提示冲突，去文件手动改正            Auto-merging README.md            CONFLICT (content): Merge conflict in README.md6： //继续开发 ... ... ，完成后一并提交    $ git add README.md    $ git commit -m &quot;fixconflict &amp; append something&quot;7： $ git checkout master    $ git merge --no-ff -m &quot;m-merge-dev&quot; dev    $ git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="冻结与解冻"><a href="#冻结与解冻" class="headerlink" title="冻结与解冻"></a>冻结与解冻</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash  //冻结当前为提交,但是已经add的工作状态$ git stash pop  //解冻, 并在状态列表中删除$ git stash list  //列出所有的状态$ git stash apply //解冻, 但并不删除状态$ git stash drop //删除状态</span><br></pre></td></tr></table></figure><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发新功能也是在dev的基础上, 新建一个Feature分支, 完成之后, 切换回dev分支, 进行合并,解决冲突等, 如果开发完的Feature分支buxuyaole, 可以使用 git branch -D 去删除没有合并的分支</span><br></pre></td></tr></table></figure><hr><h1 id="多人合作"><a href="#多人合作" class="headerlink" title="多人合作"></a>多人合作</h1><h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug 分支只用于在本地修复bug ，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</span><br></pre></td></tr></table></figure><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete remote_branch //删除远程分支$ git remote -v  //查看远程仓库信息$ git checkout -b dev origin/dev  //创建远程origin的dev分支到本地</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*多人协作的工作模式通常是这样：首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。*/</span><br></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来</span><br></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*切换到需要发布版本的分支*/$ git tag v1.0    //创建标签$ git tag       //显示标签$ git log --pretty=oneline --abbrev-commit //定位到历史commit 然后打标签$ git tag v0.9 60f96c3 $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 //-a指定标签名，-m指定说明文字$ git tag -d v0.1 //删除标签$ git push origin v1.0  //推送标签到远程$ git push origin --tags  //一次性推送所有标签    /*如果标签已经推送到远程那么*/$ git tag -d v0.9  //先删除本地$ git push origin :refs/tags/v0.9  //在删除远程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git分支管理多人合作&lt;/p&gt;
&lt;h1 id=&quot;创建版本库&quot;&gt;&lt;a href=&quot;#创建版本库&quot; class=&quot;headerlink&quot; title=&quot;创建版本库&quot;&gt;&lt;/a&gt;创建版本库&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="Git" scheme="https://luoyec.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://luoyec.cn/tags/Git/"/>
    
      <category term="基础" scheme="https://luoyec.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="廖雪峰" scheme="https://luoyec.cn/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git常见问题</title>
    <link href="https://luoyec.cn/2017/08/10/cl4e29qc80013989eojitv7kp/"/>
    <id>https://luoyec.cn/2017/08/10/cl4e29qc80013989eojitv7kp/</id>
    <published>2017-08-10T15:09:05.000Z</published>
    <updated>2017-08-10T15:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子：git和svn的区别（集中式vs分布式），谈谈优劣？"><a href="#引子：git和svn的区别（集中式vs分布式），谈谈优劣？" class="headerlink" title="引子：git和svn的区别（集中式vs分布式），谈谈优劣？"></a>引子：git和svn的区别（集中式vs分布式），谈谈优劣？</h1><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" target="_blank" rel="noopener">廖雪峰 git集中式vs分布式</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">阮一峰 git分支管理策略</a></p><blockquote><p>其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。</p></blockquote><h1 id="工作区、暂存区、版本库的概念？"><a href="#工作区、暂存区、版本库的概念？" class="headerlink" title="工作区、暂存区、版本库的概念？"></a>工作区、暂存区、版本库的概念？</h1><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">参考</a><br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501300963266.jpg" alt=""></p><h1 id="分支的概念？"><a href="#分支的概念？" class="headerlink" title="分支的概念？"></a>分支的概念？</h1><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">阮一峰 git分支管理策略</a><br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501298977415.jpg" alt="gitflow"></p><h1 id="git-status-、git-add-、git-commit-三个命令的作用及区别，详细谈谈？"><a href="#git-status-、git-add-、git-commit-三个命令的作用及区别，详细谈谈？" class="headerlink" title="git status 、git add 、git commit 三个命令的作用及区别，详细谈谈？"></a>git status 、git add 、git commit 三个命令的作用及区别，详细谈谈？</h1><ul><li><p>git status命令能展示工作目录和stage区的状态. 使用他你能看到那些修改被staged到， git status不显示已经commit到项目历史中去的信息. 看项目历史的信息要使用git log.<a href="http://www.cnblogs.com/irocker/p/git-status.html" target="_blank" rel="noopener">参考</a></p></li><li><p>git add 文件welcome.txt从工作区被提交到暂存区，但此时文件并没有真正进入到版本库当中，文件目前只处于一个中间状态。</p></li><li><p>git commit(将暂存区文件提交到版本库中) 这个命令将处于中间状态的文件（暂存区的文件)提交到版本库中,这时才算真正完成了一次提交过程。</p></li></ul><h1 id="HEAD的概念"><a href="#HEAD的概念" class="headerlink" title="HEAD的概念"></a>HEAD的概念</h1><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">参考</a></p><blockquote><p>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。<br>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p></blockquote><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501299603131.jpg" alt=""></p><blockquote><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p></blockquote><h1 id="git中最常用的命令-12个"><a href="#git中最常用的命令-12个" class="headerlink" title="git中最常用的命令(12个)"></a>git中最常用的命令(12个)</h1><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单by阮一峰</a><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line">git checkout   //切换到指定分支，并更新工作区</span><br><span class="line">git reset//重制文件 重置暂缓区 工作区</span><br><span class="line">git rm //删除工作区文件</span><br><span class="line">git push    //推送到远程仓库</span><br><span class="line">git pull//拉取远程仓库</span><br><span class="line">git <span class="keyword">clone</span><span class="title">//下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="title">git</span> branch//分支管理</span><br><span class="line">git merge   //合并冲突</span><br><span class="line">git <span class="keyword">tag</span><span class="title">//标签管理</span></span><br></pre></td></tr></table></figure></p><h1 id="如何初始化项目，如何连接远程仓库？"><a href="#如何初始化项目，如何连接远程仓库？" class="headerlink" title="如何初始化项目，如何连接远程仓库？"></a>如何初始化项目，如何连接远程仓库？</h1><ul><li>初始化一个空项目，所有的开发者clone到本地，这种方式自动连接到远程仓库</li><li>本地目录下git init一个空项目，配置开发环境后 add–&gt;commit； 新建一个远程仓库，使用git remote add ,连接到远程仓库，第一次推送 git push -u origin master</li></ul><h1 id="gitignore文件的作用写法？"><a href="#gitignore文件的作用写法？" class="headerlink" title=".gitignore文件的作用写法？"></a>.gitignore文件的作用写法？</h1><ul><li><ol><li>在已忽略文件夹中不忽略指定文件夹</li></ol></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/node_modules/</span>*</span><br><span class="line">!<span class="regexp">/node_modules/</span>layer/</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>在已忽略文件夹中不忽略指定文件</li></ol></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/node_modules/</span>*</span><br><span class="line">!<span class="regexp">/node_modules/</span>layer/layer.js</span><br></pre></td></tr></table></figure><p>【注意项】注意写法 要忽略的文件夹一定要结尾 /* ，否则不忽略规则将无法生效</p><ul><li><ol start="3"><li>其他规则写法 (附)</li></ol></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　以斜杠“/”开头表示目录；</span><br><span class="line"></span><br><span class="line">　以星号“*”通配多个字符；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　以问号“?”通配单个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　以方括号“<span class="comment">[]</span>”包含单个字符的匹配列表；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</span><br></pre></td></tr></table></figure><h1 id="Git冲突及如何解决冲突"><a href="#Git冲突及如何解决冲突" class="headerlink" title="Git冲突及如何解决冲突"></a>Git冲突及如何解决冲突</h1><h2 id="Gti下游的概念"><a href="#Gti下游的概念" class="headerlink" title="Gti下游的概念"></a>Gti下游的概念</h2><p>当dev分支是基于master分支，dev分支不断的commit，但是master分支没有修改，这时候可以直接合并分支，不会产生冲突。 即dev上的节点是master的下游时可以直接合并</p><p>当master也进行了commit， 这时候可能会产生冲突</p><h2 id="merge的几种方式"><a href="#merge的几种方式" class="headerlink" title="merge的几种方式"></a>merge的几种方式</h2><ul><li>fast-forword 快速合并， 改变HEAD指针指向</li><li>no-ff 新创建一个commit，再改变HEAD指针指向</li></ul><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>拆分成两个操作： git fetch（拉取更新，新建一个分支）  git merge（合并“远程分支”到本地master分支）</p><h2 id="冲突发生的场景"><a href="#冲突发生的场景" class="headerlink" title="冲突发生的场景"></a>冲突发生的场景</h2><ul><li><p>当需要合并分支的时候，另一个分支上的同一份代码已经被修改过</p></li><li><p>执行git push， 提交代码时，最新仓库中的代码与本地工作区代码存在冲突</p></li></ul><h2 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h2><h3 id="不借助第三方工具"><a href="#不借助第三方工具" class="headerlink" title="不借助第三方工具"></a>不借助第三方工具</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000" target="_blank" rel="noopener">廖雪峰git教程，分支合并解决冲突（场景一）</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//新建并切换到新分支</span><br><span class="line">git checkout -v dev</span><br><span class="line"></span><br><span class="line">//修改data.js 并且add commit</span><br><span class="line">git add data.js</span><br><span class="line">git commit -m 'edit data'</span><br><span class="line"></span><br><span class="line">//dev分支完成开发，此时检出到master分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">//修改master分支同一个文件，也add commit</span><br><span class="line">git add data.js</span><br><span class="line">git commit -m 'add something'</span><br><span class="line"></span><br><span class="line">//尝试合并dev分支到master分支</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">//提示需要手动解决冲突，解决完成后，将修改到冲突文件add commit</span><br><span class="line">git add data.js</span><br><span class="line">git commit -m 'fixed merge'</span><br><span class="line"></span><br><span class="line">//冲突解决之后，推送到远程仓库</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">//当不在需要dev分支，则可以删除之</span><br><span class="line">git branch -d dev</span><br><span class="line"></span><br><span class="line">//如果仍然需要dev分支继续开发，则需要同步远程仓库到dev分支上</span><br><span class="line">git pull orign master</span><br></pre></td></tr></table></figure><h3 id="借助第三方工具（场景二）"><a href="#借助第三方工具（场景二）" class="headerlink" title="借助第三方工具（场景二）"></a>借助第三方工具（场景二）</h3><p>拉取远程仓库中最新的代码，提示冲突，查看冲突<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line">git status  <span class="comment">//查看当前冲突文件</span></span><br><span class="line">git mergetool  <span class="comment">//打开diffmerge工具合并解决冲突</span></span><br></pre></td></tr></table></figure></p><h4 id="图形化工具diffmerge"><a href="#图形化工具diffmerge" class="headerlink" title="图形化工具diffmerge"></a>图形化工具diffmerge</h4><p><a href="https://www.sourcegear.com/diffmerge/" target="_blank" rel="noopener">下载地址DMG版</a><br>全局配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge<span class="selector-class">.tool</span> diffmerge</span><br><span class="line">git config --global mergetool<span class="selector-class">.diffmerge</span><span class="selector-class">.cmd</span> <span class="string">"/Applications/DiffMerge.app/Contents/MacOS/diffmerge --merge --result=\$MERGED \$LOCAL \$BASE \$REMOTE"</span></span><br><span class="line">git config --global mergetool<span class="selector-class">.keepBackup</span> false</span><br><span class="line"> </span><br><span class="line">git config --global diff<span class="selector-class">.tool</span> diffmerge</span><br><span class="line">git config --global difftool<span class="selector-class">.diffmerge</span><span class="selector-class">.cmd</span> <span class="string">"/Applications/DiffMerge.app/Contents/MacOS/diffmerge \$LOCAL \$REMOTE"</span></span><br></pre></td></tr></table></figure><p>当出现冲突时，执行命令，弹出窗口手动解决冲突</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> mergetool</span><br></pre></td></tr></table></figure><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501260875775.jpg" alt="中间是合并后结果"></p><p>完成合并，保存退出图形化工具<br>已经手动解决了冲突，这是让rebase继续工作，执行命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;冲突文件/.  表示所有修改文件&gt;</span><br><span class="line">git rebase --continue   <span class="comment">//rebase继续工作</span></span><br><span class="line">git push    <span class="comment">//代码成功提交</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突中的异常处理"><a href="#解决冲突中的异常处理" class="headerlink" title="解决冲突中的异常处理"></a>解决冲突中的异常处理</h3><blockquote><p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//解决冲突失败，或者向重新解决冲突</span><br><span class="line"><span class="meta">$</span>git rebase --abort</span><br><span class="line">//Skip是跳过这个错误，继续本次操作</span><br><span class="line"><span class="meta">$</span>git rebase --skip</span><br></pre></td></tr></table></figure><p>==git rebase –abort 是无风险的操作，会回到rebase操作之前的状态，2个分支的commits毫发无损。<br>git rebase –skip 是高风险的操作，引起冲突的commits会被丢弃（这部分代码修改会丢失）。==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引子：git和svn的区别（集中式vs分布式），谈谈优劣？&quot;&gt;&lt;a href=&quot;#引子：git和svn的区别（集中式vs分布式），谈谈优劣？&quot; class=&quot;headerlink&quot; title=&quot;引子：git和svn的区别（集中式vs分布式），谈谈优劣？&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Git" scheme="https://luoyec.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://luoyec.cn/tags/Git/"/>
    
      <category term="基础" scheme="https://luoyec.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="命令" scheme="https://luoyec.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道三:函数</title>
    <link href="https://luoyec.cn/2017/08/09/cl4e29qfe0079989eyvtv7luj/"/>
    <id>https://luoyec.cn/2017/08/09/cl4e29qfe0079989eyvtv7luj/</id>
    <published>2017-08-09T15:40:05.000Z</published>
    <updated>2017-08-09T15:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何写好函数？</p><h1 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h1><h2 id="函数到底要多长"><a href="#函数到底要多长" class="headerlink" title="函数到底要多长"></a>函数到底要多长</h2><p>每个程序每个函数只有两行、三行或者四行。每个函数都一目了然。每个函数都只说明一件事。而且，每隔函数都依序把你带到下一个函数。这就是函数应该达到的短小程度。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502272924373.jpg" alt=""></p><h2 id="代码块和缩进"><a href="#代码块和缩进" class="headerlink" title="代码块和缩进"></a>代码块和缩进</h2><p>  if语句、else语句、while语句等，其中的代码块应该只有一行。该行应该是一个函数调用。这样不能保持函数短小，而且，因为块内调用的函数拥有较具有说明性的名称，从而增加了文档上的价值。</p><p>  这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不应该多于一层或两层。当然这也的函数易于阅读和理解。</p><h1 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a>只做一件事</h1><p>  函数应该做一件事。做好这件事。只做这件事。</p><p>  如果函数只是做了该函数名下统一抽象层上的步骤，则函数还是只做了一件事。所以判断函数是否不止做了一件事，还有一个方法，==就是看是否能再拆除一个函数，该函数不仅只是单纯地重新诠释其实现==。</p><p>  只做一件事的函数无法合理的切分为多个区段。</p><h1 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h1><p>  ==要确保函数只做一件事，函数中的语句都要在同一抽象层级上。==</p><p>  函数中混杂不同的抽象层级，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。</p><h2 id="自顶向下读代码：-向下原则"><a href="#自顶向下读代码：-向下原则" class="headerlink" title="自顶向下读代码： 向下原则"></a>自顶向下读代码： 向下原则</h2><p>  每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能根据抽象层级向下阅读，这就叫向下规则。</p><h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>  switch的几个问题。太长，当类型复杂起来时，会更长。其次，不止做了一件事。第三，违反了单一权责原则，因为有好几个修改它的理由。第四，违反了开放闭合原则，因为每次添加新类型时，就必须修改之。</p><p>  解决方法，对于switch语句，如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其它部分看不到。</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502275120642.jpg" alt=""></p><h1 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a>使用描述性的名称</h1><p>  testableHtml改为SetupTeardownIncluderender; isTestable或includeSetupAndTeardownPages，<br>  长的函数名具有描述性，要比描述性的长注释好。可以使用眸中约定，让函数名称中的多个单词更容易阅读，然后使用这些单词给函数取个能说清其功能的名称。</p><p>  模块名用名词，而函数名用动词描述。</p><h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>  最理想的参数数量是零，其次是一个，再次是两个。除非有足够的理由才能用三个以上参数。</p><h2 id="一元函数的普遍形式"><a href="#一元函数的普遍形式" class="headerlink" title="一元函数的普遍形式"></a>一元函数的普遍形式</h2><p>  一元函数即单个参数的函数，大体上分为两种：</p><ul><li>操作该参数，将其输出</li><li>事件，有输入参数而无输出参数，程序将函数看作是一个事件，使用参数修改系统状态</li></ul><h2 id="标识参数"><a href="#标识参数" class="headerlink" title="标识参数"></a>标识参数</h2><p>将布尔值作为参数用于标识是不值得推荐的做法，如果真要这么做， 应当把函数拆分成两个不带标识参数的函数。</p><h2 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h2><p>拥有两个参数比拥有一个参数的函数更复杂难懂，可以利用一些机制转换成一元函数。</p><h2 id="三元函数"><a href="#三元函数" class="headerlink" title="三元函数"></a>三元函数</h2><p>三个参数的函数，排序、琢磨、忽略的问题都会成倍体现。</p><h1 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h1><p>函数承诺只做一件事，但有时，会对自己类中的变量做出未能预期的改动，或是对全局变量造成了影响。</p><p>这种函数不能以简单的命名让人误解，并且也违法了一个函数只做一件事的规则。</p><h2 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h2><p>应该避免使用输出参数，如果函数必须修改某种状态，就修改所属对象的状态吧</p><h1 id="分隔指令与询问"><a href="#分隔指令与询问" class="headerlink" title="分隔指令与询问"></a>分隔指令与询问</h1><p>函数要么做什么事，要么回答什么事，但两者不可兼得。函数应该修改某对象状态或是返回该对象的有关信息。两样都干会导致混乱。</p><p>把指令和询问拆分成两个函数<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502288159582.jpg" alt=""></p><h1 id="如何在实践中写好函数"><a href="#如何在实践中写好函数" class="headerlink" title="如何在实践中写好函数"></a>如何在实践中写好函数</h1><p>  一开始都冗长而复杂，有太多的缩进和嵌套循环。有过长的参数列表，名称随意取的，也会有重复代码。</p><p>  然后打磨这些代码，分解函数、修改名称、消除重复。缩短和安置方法，有时候还拆散类。同时保持测试通过。</p><p>  最后，遵循本章的规则，组装好这些函数。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> ==大师级程序员把系统当做故事来讲，而不是当做程序来写==。</p><h1 id="SetupTeardownIncluder程序"><a href="#SetupTeardownIncluder程序" class="headerlink" title="SetupTeardownIncluder程序"></a>SetupTeardownIncluder程序</h1><p> <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502293054470.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502293079369.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502293141596.jpg" alt=""></p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502293153919.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何写好函数？&lt;/p&gt;
&lt;h1 id=&quot;短小&quot;&gt;&lt;a href=&quot;#短小&quot; class=&quot;headerlink&quot; title=&quot;短小&quot;&gt;&lt;/a&gt;短小&lt;/h1&gt;&lt;h2 id=&quot;函数到底要多长&quot;&gt;&lt;a href=&quot;#函数到底要多长&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="代码整洁之道" scheme="https://luoyec.cn/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁" scheme="https://luoyec.cn/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
      <category term="提高" scheme="https://luoyec.cn/tags/%E6%8F%90%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>Express Getting Started实践</title>
    <link href="https://luoyec.cn/2017/08/09/cl4e29qc5000y989eaqab0dts/"/>
    <id>https://luoyec.cn/2017/08/09/cl4e29qc5000y989eaqab0dts/</id>
    <published>2017-08-08T22:43:10.000Z</published>
    <updated>2017-08-09T15:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>新建一个目录, 初始化项目</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp</span><br><span class="line">cd myapp</span><br><span class="line">npm init  <span class="comment">//可以手动输入入口文件,如entry point: (index.js)</span></span><br></pre></td></tr></table></figure><p>安装express依赖</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br><span class="line">npm install express --no-save   <span class="comment">//也可以不将express添加到依赖中</span></span><br></pre></td></tr></table></figure><h2 id="新建一个Hello-World-示例"><a href="#新建一个Hello-World-示例" class="headerlink" title="新建一个Hello World 示例"></a>新建一个Hello World 示例</h2><p>修改目录下index.js文件如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express = require(<span class="string">'express'</span>)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, function (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, function () &#123;</span><br><span class="line">  console.log(<span class="string">'Example app listening on port 3000!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行这个应用用一下命令:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>打开浏览器 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> , 就能看到输入 ‘Hello World!’</p><h2 id="使用Express-的脚手架构建项目"><a href="#使用Express-的脚手架构建项目" class="headerlink" title="使用Express 的脚手架构建项目"></a>使用Express 的脚手架构建项目</h2><p>使用脚手架工具, 可以快速的创建项目骨架,<br>全局安装express-generator</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-generator -g</span><br></pre></td></tr></table></figure><p>-h命令参数 可以看到打印的信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$express</span> -h</span><br><span class="line">Usage: express [options] [dir]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --help           output usage information</span><br><span class="line">        --version        output the version number</span><br><span class="line">    -e, --ejs            add ejs engine support</span><br><span class="line">        --pug            add pug engine support</span><br><span class="line">        --hbs            add handlebars engine support</span><br><span class="line">    -H, --hogan          add hogan<span class="selector-class">.js</span> engine support</span><br><span class="line">    -v, --view &lt;engine&gt;  add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)</span><br><span class="line">    -c, --css &lt;engine&gt;   add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)</span><br><span class="line">        --git            add .gitignore</span><br><span class="line">    -f, --force          force on non-empty directory</span><br></pre></td></tr></table></figure><p>使用一下命令可以快速构建指定项目名的应用, 并且可以同时指定模板引擎</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">express --view=pug myapp</span><br><span class="line"></span><br><span class="line">   create : myapp</span><br><span class="line">   create : myapp/package.json</span><br><span class="line">   create : myapp/app.js</span><br><span class="line">   create : myapp/public</span><br><span class="line">   create : myapp/public/javascripts</span><br><span class="line">   create : myapp/public/images</span><br><span class="line">   create : myapp/routes</span><br><span class="line">   create : myapp/routes/index.js</span><br><span class="line">   create : myapp/routes/users.js</span><br><span class="line">   create : myapp/public/stylesheets</span><br><span class="line">   create : myapp/public/stylesheets/style.css</span><br><span class="line">   create : myapp/views</span><br><span class="line">   create : myapp/views/index.pug</span><br><span class="line">   create : myapp/views/layout.pug</span><br><span class="line">   create : myapp/views/error.pug</span><br><span class="line">   create : myapp/bin</span><br><span class="line">   create : myapp/bin/www</span><br></pre></td></tr></table></figure><p>进到工作目录中,安装依赖, 并运行项目</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myapp</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>On MacOS or Linux系统,执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> DEBUG=myapp:* npm start</span><br></pre></td></tr></table></figure><p>On Windows系统, 执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> set DEBUG=myapp:* &amp; npm start</span><br></pre></td></tr></table></figure><p>同样打开浏览器 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></p><p>通过脚手架创建的项目,  目录结构如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> directories, <span class="number">9</span> files</span><br></pre></td></tr></table></figure><h2 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h2><p>应用的路由处理客户端通过URL或路径等特定的http请求方法(GET POST …)的请求<br>每一个路由当被匹配的时候, 都由一个或者多个的处理函数<br>定义路由的方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure><p>这里需要注意的几个点</p><ul><li>app是express的实例</li><li>METHOD是HTTP请求方方法, 小写</li><li>PATH是服务器路径</li><li>HANDLER是当路由匹配的时候执行的方法</li></ul><h3 id="路由简单实例"><a href="#路由简单实例" class="headerlink" title="路由简单实例"></a>路由简单实例</h3><p>相应’Hello World!’字符串在主页上</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, function(req,res)&#123;</span><br><span class="line">res.send(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相应一个post方法的请求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, function (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Got a POST request'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应PUT方法的请求, 匹配/user 路由</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.put(<span class="string">'/user'</span>, function(req, res)&#123;</span><br><span class="line">res.send(<span class="string">'Got a PUT request a /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相应DELETE方法的请求, 匹配/user 路由</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.delete(<span class="string">'/user'</span>, function (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Got a DELETE request at /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在express中的静态文件"><a href="#在express中的静态文件" class="headerlink" title="在express中的静态文件"></a>在express中的静态文件</h2><p>静态文件, 图片 css javascript等,  使用express内置的中间件express.static处理. </p><p>通过命名的目录包含这些静态资源文件, express.static中间件函数开始直接为这些文件提供支持.<br>例如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.user(express.static(<span class="string">'public'</span>))</span><br></pre></td></tr></table></figure><p>现在可以加载这些文件了  ps:使用的是相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/images/kitten.jpg</span></span><br><span class="line">http:<span class="comment">//localhost:3000/css/style.css</span></span><br><span class="line">http:<span class="comment">//localhost:3000/js/app.js</span></span><br><span class="line">http:<span class="comment">//localhost:3000/images/bg.png</span></span><br><span class="line">http:<span class="comment">//localhost:3000/hello.html</span></span><br></pre></td></tr></table></figure><p>如果有多个静态资源目录, 调用express.static中间件多次即可</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>))</span><br></pre></td></tr></table></figure><p>express会按顺序设置这些静态文件</p><h3 id="虚拟前缀"><a href="#虚拟前缀" class="headerlink" title="虚拟前缀"></a>虚拟前缀</h3><p>创建一个虚拟的前缀(这个前缀并不存在与服务器的文件系统中)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>))</span><br></pre></td></tr></table></figure><p>现在可以通过这个虚拟的前缀访问到静态资源文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/static/images/kitten.jpg</span></span><br><span class="line">http:<span class="comment">//localhost:3000/static/css/style.css</span></span><br><span class="line">http:<span class="comment">//localhost:3000/static/js/app.js</span></span><br><span class="line">http:<span class="comment">//localhost:3000/static/images/bg.png</span></span><br><span class="line">http:<span class="comment">//localhost:3000/static/hello.html</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>express.static使用相对路径加载静态文件当你加载你的node程序, 如果你从其他路径运行的express 应用,<br>一个更安全的策略是使用绝对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>, express.static(path.join(__dirname, <span class="string">'public'</span>)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Getting-started&quot;&gt;&lt;a href=&quot;#Getting-started&quot; class=&quot;headerlink&quot; title=&quot;Getting started&quot;&gt;&lt;/a&gt;Getting started&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://luoyec.cn/categories/Nodejs/"/>
    
    
      <category term="Nodejs" scheme="https://luoyec.cn/tags/Nodejs/"/>
    
      <category term="Express" scheme="https://luoyec.cn/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>socket.io入门实践</title>
    <link href="https://luoyec.cn/2017/08/09/cl4e29qes0063989ex74vg8vu/"/>
    <id>https://luoyec.cn/2017/08/09/cl4e29qes0063989ex74vg8vu/</id>
    <published>2017-08-08T22:39:08.000Z</published>
    <updated>2017-08-09T15:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>相关链接：<br><a href="https://socket.io/get-started/chat/" target="_blank" rel="noopener">socket.io官网</a><br><a href="https://segmentfault.com/a/1190000004925844#articleHeader0" target="_blank" rel="noopener">零基础搭建网页聊天室（socket.io使用教程）</a></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>  创建一个基础的聊天应用, 这不需要Node.js和Scocket.io基础</p><h1 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h1><p>  首先是package.json文件, 用于配置依赖并且安装express框架</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save express@<span class="number">4.15</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"socket-chat-example"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"my first socket.io app"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"^4.15.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个index.js文件作为node服务器入口文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let app = require(<span class="string">'express'</span>)()</span><br><span class="line">let http = require(<span class="string">'http'</span>).Server(app)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(`&lt;h1&gt;Hello World!&lt;/h1&gt;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, ()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'listening on *.3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行命令, 开启http服务, 在浏览器打开3000端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501409938240.jpg" alt=""></p><h1 id="提供HTML"><a href="#提供HTML" class="headerlink" title="提供HTML"></a>提供HTML</h1><p>直接返回标签容易让人混乱, 这里重构代码, 新建一个index.html文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Socket<span class="selector-class">.IO</span> chat&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;</span><br><span class="line">      <span class="selector-tag">body</span> &#123; <span class="attribute">font</span>: <span class="number">13px</span> Helvetica, Arial; &#125;</span><br><span class="line">      <span class="selector-tag">form</span> &#123; <span class="attribute">background</span>: <span class="number">#000</span>; <span class="attribute">padding</span>: <span class="number">3px</span>; <span class="attribute">position</span>: fixed; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">      form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;</span><br><span class="line">      <span class="selector-tag">form</span> <span class="selector-tag">button</span> &#123; <span class="attribute">width</span>: <span class="number">9%</span>; <span class="attribute">background</span>: rgb(<span class="number">130</span>, <span class="number">224</span>, <span class="number">255</span>); <span class="attribute">border</span>: none; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</span><br><span class="line">      <span class="selector-id">#messages</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span><br><span class="line">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span> &#123; <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>; &#125;</span><br><span class="line">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span>:nth-child(odd) &#123; <span class="attribute">background</span>: <span class="number">#eee</span>; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span> id=<span class="string">"messages"</span>&gt;&lt;/ul&gt;</span><br><span class="line">    &lt;<span class="selector-tag">form</span> action=<span class="string">""</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">input</span> id=<span class="string">"m"</span> autocomplete=<span class="string">"off"</span> /&gt;&lt;button&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>并修改服务器路由, 发送一个html文件而不是标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.sendFile(__dirname + &apos;/index.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新运行<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501410528099.jpg" alt=""></p><h1 id="整合Socket-io"><a href="#整合Socket-io" class="headerlink" title="整合Socket .io"></a>整合Socket .io</h1><blockquote><p>整合Socket .io 分为客户端和服务器端两部分,其中客户端不需要而外加载, 只需要作为全局变量使用即可</p></blockquote><p>客户端配置,修改index.html文件, 在前加入js代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;script src=<span class="string">"/socket.io/socket.io.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    let socket = io()</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>修改index.js文件, 监听l连接与连接断开事件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket)=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'a user connected'</span>)</span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, ()=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'user disconnect'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在控制台中可以查看用户连接事件<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501420254937.jpg" alt=""></p><h1 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h1><blockquote><p>socket .io最主要的作用就是你可以触发和监听任何你想要的事件，任何对象都可以编码成json，并且二进制数据也是支持的</p></blockquote><p>修改index.html 将输入框内容，通过‘chat message’事件发送给服务器</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/socket.io/socket.io.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://code.jquery.com/jquery-1.11.1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $(function ()&#123;</span><br><span class="line">        <span class="selector-tag">var</span> socket = io()</span><br><span class="line">        $(<span class="string">'form'</span>).submit(function()&#123;</span><br><span class="line">          socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val())</span><br><span class="line">          $(<span class="string">'#m'</span>.val(<span class="string">''</span>))</span><br><span class="line">          return false</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>修改服务器index.js文件, 监听客户端的发送消息事件, 并将消息打印在控制台</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket)=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'a user connected'</span>)</span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, ()=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'user disconnect'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    socket.on(<span class="string">'chat message'</span>, (msg)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'message: '</span> + msg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在客户端输入信息, 服务器就能监听到了<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501421463087.jpg" alt=""></p><h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p> 如果向每个连接的客户端都发送事件, 可以使用io.emit()方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.emit('some event', &#123; for: 'everyone' &#125;);</span><br></pre></td></tr></table></figure><p>如果是想某个特定的sokect连接发送事件,可以使用broadcast标志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, function(socket)&#123;</span><br><span class="line">  socket.broadcast.emit('hi');</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里将事件发送给每一个连接的客户端, 修改index.js文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket)=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'a user connected'</span>)</span><br><span class="line">    <span class="comment">//监听连接断开事件</span></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, ()=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'user disconnect'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听客户端发送消息事件</span></span><br><span class="line">    socket.on(<span class="string">'chat message'</span>, (msg)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'message: '</span> + msg)</span><br><span class="line">        <span class="comment">//向所有客户端广播事件</span></span><br><span class="line">        io.emit(<span class="string">'chat message'</span>, msg)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改index.html文件,  监听事件, 将消息动态插入到ui列表中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(function () &#123;</span><br><span class="line">    <span class="selector-tag">var</span> socket = io()</span><br><span class="line">    $(<span class="string">'form'</span>).submit(function () &#123;</span><br><span class="line">      socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val())</span><br><span class="line">      $(<span class="string">'#m'</span>).val(<span class="string">''</span>)</span><br><span class="line">      return false</span><br><span class="line">    &#125;)</span><br><span class="line">    socket.on(<span class="string">'chat message'</span>, function (msg) &#123;</span><br><span class="line">      $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>打开两个客户端, 实现了简单的聊天室功能<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1501422414118.jpg" alt=""></p><h1 id="功能更完善的聊天室应用"><a href="#功能更完善的聊天室应用" class="headerlink" title="功能更完善的聊天室应用"></a>功能更完善的聊天室应用</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:<span class="comment">//github.com/socketio/chat-example.git</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相关链接：&lt;br&gt;&lt;a href=&quot;https://socket.io/get-started/chat/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;socket.io官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.co
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://luoyec.cn/categories/Nodejs/"/>
    
    
      <category term="node" scheme="https://luoyec.cn/tags/node/"/>
    
      <category term="socket" scheme="https://luoyec.cn/tags/socket/"/>
    
      <category term="聊天室" scheme="https://luoyec.cn/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道二：有意义的命名</title>
    <link href="https://luoyec.cn/2017/08/08/cl4e29qff007c989e8nnxho2u/"/>
    <id>https://luoyec.cn/2017/08/08/cl4e29qff007c989e8nnxho2u/</id>
    <published>2017-08-08T15:21:20.000Z</published>
    <updated>2017-08-09T15:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名的几条简单规则"><a href="#命名的几条简单规则" class="headerlink" title="命名的几条简单规则"></a>命名的几条简单规则</h1><h2 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a>名副其实</h2><p>变量、函数和类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502188535042.jpg" alt="一种更好的命名方式"></p><p>虽然一些代码没有复杂的表达式，问题不在于代码的简洁度，而在于代码的模糊度：即上下文在代码中未被明确的体现的程度。所以简介的代码需要了解例如数组下标的意义，一些值和变量的意义，这是什么类型，返回会返回这数据类型的值等</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502189302860.jpg" alt="过于简洁的代码"></p><p>  优化方案：</p><ul><li><p>比如，我们在开发一种扫雷游戏，我们发现盘面是名为theList的单元格列表，那就将其名称改为gameBoard， 我们还发现，下表其实是一种状态值，而状态值为4标识“已标记”。只要改为由意义的名称，代码就会得到相当程度的改进</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502189860719.jpg" alt="改进列表与下表名称"></p></li><li><p>更进一步，不用个int数组标识单元格，而是另外写一个类。该类包括一个名副其实的函数（成为isFlagged），从而掩盖那个魔术数</p></li></ul><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502189968607.jpg" alt="抽象成一个类"></p><h2 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h2><p>  一些专有名词不应该用作变量名，如 “hp”，“aix”，“sco”等；避免使用在不同的地方但是区别较小的名称，想区分模块某处的XYZControllerForEffcientHandilingOfStrings和另一处的XYZControllerForEfficienStoorageOfStrings，会话很长时间。</p><p>  以同样的方式拼写出相同概念才是信息，拼写前后不一致就是误导。极端的例子， 使用消息字符l和大写字母O作为变量名。</p><h2 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h2><p>  不要为了满足编译器而写代码，光是添加数字或是废话是远远不够的，即便这足以让编译器满意。如果名称必须相异，那其意思也应该不同才对。</p><p>  以数字系列命名（a1、a2）是依义命名的反面，容易误导，完全没有提供正确信息。</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502190748501.jpg" alt="应该避免的数字系列命名"></p><p>  变量名无意义的废话是不必要的，也无助于区分。假如你有一个Product类，还有一个ProductInfo或者是ProductData类，虽然名称不同，但却无区别。</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502191078360.jpg" alt="缺少约定，不知道该调用哪个函数"></p><h2 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h2><p>  命名的变量应该具有良好的可读性<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502191269808.jpg" alt="易读性较好的命名方式"></p><h2 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h2><p>  查找MAX_CLASSES_FER_STUDENT很容易，而查找e很困难。单字母名称仅用于短方法中的本地变量。名称的长短应与其作用域大小相对应。若常量或者变量可能在多处使用，则应赋予其便于搜索的名称。</p><p>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502191510487.jpg" alt="便于搜索的命名方式"></p><h2 id="避免使用编码"><a href="#避免使用编码" class="headerlink" title="避免使用编码"></a>避免使用编码</h2><p>  把类型或者作用域编进名称里，突然增加了了解码的负担。没有理由要求每位新人都在弄清应付的代码之外，还要再搞懂另一种编码“语言”</p><h3 id="成员前缀"><a href="#成员前缀" class="headerlink" title="成员前缀"></a>成员前缀</h3><p>  也不必使m_ 前缀来表明成员变量。应当把类和函数做得足够小，消除对成员前缀的需求。</p><p><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502192031761.jpg" alt="不必使用前缀标识"></p><h1 id="类名及方法名"><a href="#类名及方法名" class="headerlink" title="类名及方法名"></a>类名及方法名</h1><p>  类名对象应该是名字或名词短语，如Customer、WikiPage、Account等，并且类名不应该是动词。</p><p>  方法名应当是动词或动词短语，如postPayment、deletePage或save等。属性访问器、修改器和判断应该根据其值命名，并依据==Javabean标准加上get、set或is前缀==。<br>  <img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502203476059.jpg" alt=""></p><h1 id="别扮可爱"><a href="#别扮可爱" class="headerlink" title="别扮可爱"></a>别扮可爱</h1><p>  如果名称太耍宝，那就只有同作者一般有幽默感的人才能记住。</p><h2 id="每个概念对应一个词"><a href="#每个概念对应一个词" class="headerlink" title="每个概念对应一个词"></a>每个概念对应一个词</h2><p>  给每个抽象概念选一个词，避免在多个类中使用相同名称的方法名，这不便于区分方法所属的类。</p><h2 id="别用双关语"><a href="#别用双关语" class="headerlink" title="别用双关语"></a>别用双关语</h2><p>  避免将同一个单词用于不同目的。同一术语用于不同概念，基本就是双关了。</p><h2 id="使用解决方案领域名称"><a href="#使用解决方案领域名称" class="headerlink" title="使用解决方案领域名称"></a>使用解决方案领域名称</h2><p>  只有程序员才会读你的代码，所以，尽量使用计算机科学术语、算法名、模式名、数学名。</p><h2 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h2><h2 id="不添加无意义的语境"><a href="#不添加无意义的语境" class="headerlink" title="不添加无意义的语境"></a>不添加无意义的语境</h2><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>   多数时候我们并不记忆类名和方法名，我们使用现代工具对付这些细节，好让自己集中精力把代码写得更好。</p><p>   可以试试以上的规则，看看代码可读性是否还可以提高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命名的几条简单规则&quot;&gt;&lt;a href=&quot;#命名的几条简单规则&quot; class=&quot;headerlink&quot; title=&quot;命名的几条简单规则&quot;&gt;&lt;/a&gt;命名的几条简单规则&lt;/h1&gt;&lt;h2 id=&quot;名副其实&quot;&gt;&lt;a href=&quot;#名副其实&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="代码整洁之道" scheme="https://luoyec.cn/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁" scheme="https://luoyec.cn/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
      <category term="提高" scheme="https://luoyec.cn/tags/%E6%8F%90%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道一:代码整洁</title>
    <link href="https://luoyec.cn/2017/08/08/cl4e29qfb0077989enw7htqd9/"/>
    <id>https://luoyec.cn/2017/08/08/cl4e29qfb0077989enw7htqd9/</id>
    <published>2017-08-08T06:23:46.000Z</published>
    <updated>2017-08-09T15:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码整洁"><a href="#代码整洁" class="headerlink" title="代码整洁"></a>代码整洁</h1><p>这是本有关编写好程序的书，它充斥着代码。我们需要从各个方面来考察这些代码。从顶向下，从里而外。读完之后就知道许多关于代码的事了。</p><p>而且，我们还能说出好代码和糟糕代码之间的差异。我们将知道如何写出好代码，我们也会知道，如何将糟糕代码改成好代码。</p><h1 id="要有代码"><a href="#要有代码" class="headerlink" title="要有代码"></a>要有代码</h1><p>有一种观点， 随着自动化发展，人工智能技术的进步， 代码是可以自动生成，而不再需要人工编写。</p><p>而问题在于，代码呈现了需求的细节，在某些层面上，这些细节无法被忽略和抽象，并且将需求明确到机器可以执行的细节程度，这就是编程所做的工作。</p><p>即使是人类，也造不出满足客户模糊感觉的成功系统。我们永远无法抛弃必要的精确性–所以代码永存。</p><h1 id="糟糕的代码及混乱的代价"><a href="#糟糕的代码及混乱的代价" class="headerlink" title="糟糕的代码及混乱的代价"></a>糟糕的代码及混乱的代价</h1><p>随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降的时，管理层只能增加更多的人手到项目中，期望提高生产力，可是新人并不熟悉系统的设计，也搞不清楚什么样的修改更符合设计的意图，什么样的修改违背设计意图。于是制造了更多的混乱。<br><img src="http://image.talkmoney.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1502168553540.jpg" alt=""></p><h2 id="作为程序员应有态度"><a href="#作为程序员应有态度" class="headerlink" title="作为程序员应有态度"></a>作为程序员应有态度</h2><p>很多时候讲问题归咎于经理， 客户，其实他们期望从我们这里得到必要的信息，然后才能做出程度和保证，即便他们没有开口问，我们也不应该羞于告知自己的想法。对于项目的规划我们脱不了干系，并对失败负有责任，特别是当失败与糟糕的代码有关时！</p><p>另一方面，程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。</p><p>还需要注意的是，在项目开发中，制造混乱无助于赶上工期，混乱只会拖慢你，叫你错过期限。赶上期限的唯一方法–做得更快的方法–就是始终极可能的保持代码的整洁。</p><h1 id="代码整洁的艺术"><a href="#代码整洁的艺术" class="headerlink" title="代码整洁的艺术"></a>代码整洁的艺术</h1><p>写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”。这种“代码感”就是关键所在。简而言之，==编写整洁代码的程序员就像是艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统==。</p><h1 id="什么是整洁代码"><a href="#什么是整洁代码" class="headerlink" title="什么是整洁代码"></a>什么是整洁代码</h1><blockquote><p>我喜欢优雅和搞笑的代码，代码逻辑应当直截了当，叫缺陷难以隐蔽，尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省的引诱别人做没规矩的优化，搞出一堆混乱来，整洁代码只做好一件事情。<br><em>Bjarne Stroustrup C++语言发明者</em></p></blockquote><p>优雅的定义：外表或举止令人愉悦的优美和雅观；令人愉悦的精致和简单。</p><p>破窗理论：窗户破损的建筑让人觉得似乎无人照管，于是别人也不再关心，放任窗户继续破损。最终自己也参与破坏活动，在外墙上涂鸦，任垃圾堆积，一扇破损的窗户开辟了大厦走向倾颓的道路。</p><p>整洁的代码力求集中，每个函数、每隔类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。</p><blockquote><p>整洁的代码简单直接，整洁代码如同优雅的散文，整洁的代码从不隐藏设计者 的意图，充满干净利落的抽象和直截了当的控制语句。<br><em>Grady Booch 《面向对象分析与设计》作者</em></p></blockquote><blockquote><p>简单代码，以其重要顺序：</p><ul><li>能通过所有测试</li><li>没有重复代码</li><li>体现系统中全部的设计理念</li><li>包括尽量少的实体，比如类，方法，函数等<br>在以上诸项中，我最在意代码重复，如果同一段代码反复出现，就表示某种想法未在代码中得到良好表现，我尽力去找出到底那是什么，然后再尽力清晰地表达出来。<br>在我看来，有意义的命名是体现表达力的一种方式；如果对象功能太多，最好是切分为两个或多个对象；如果方法功能太多，我总是使用抽象手段重构之，从而得到一个较为清晰地说明自身功能的方法。以及另外数个说明如何实现这些功能的方法。<br>这么多年下来，我发现所有的程序都由极为相似的元素构成，例如“在集中中查找某元素”，不管是员工记录数据库，还是哈希表，或者是数组。我们都会发现自己想要从集合中查找某一特定条目，一旦出现这种情况，我通常会把实现手段封装到更抽象的方法或者类中<br><em>Ron Jeffries 《C#极限编程探险》作者</em></li></ul></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书同样也不担保你成为好程序员。它不担保能给你“代码感觉”。它能做的，只是展示好程序员的思维过程，还有他们使用的技巧、技术、工具。</p><p>和艺术书一样，本书也充满细节。代码会很多，你会看到好代码，也会看到糟糕的代码。你会看到糟糕的代码如何装换成好代码。你会看到启发、规则和技巧的列表。你会看到一个又一个例子。但这始终取决于你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码整洁&quot;&gt;&lt;a href=&quot;#代码整洁&quot; class=&quot;headerlink&quot; title=&quot;代码整洁&quot;&gt;&lt;/a&gt;代码整洁&lt;/h1&gt;&lt;p&gt;这是本有关编写好程序的书，它充斥着代码。我们需要从各个方面来考察这些代码。从顶向下，从里而外。读完之后就知道许多关于代码的事
      
    
    </summary>
    
      <category term="代码整洁之道" scheme="https://luoyec.cn/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="读书笔记" scheme="https://luoyec.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁" scheme="https://luoyec.cn/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
      <category term="提高" scheme="https://luoyec.cn/tags/%E6%8F%90%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB及Robo工具安装</title>
    <link href="https://luoyec.cn/2017/08/05/cl4e29qdk003s989eje9w1mub/"/>
    <id>https://luoyec.cn/2017/08/05/cl4e29qdk003s989eje9w1mub/</id>
    <published>2017-08-05T02:08:28.000Z</published>
    <updated>2017-08-05T04:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源:</p><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">Install MongoDB Community Edition with Homebrew</a> </p><h2 id="mongodb安装："><a href="#mongodb安装：" class="headerlink" title="mongodb安装："></a>mongodb安装：</h2><p>安装 mongodb      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mongodb</span><br></pre></td></tr></table></figure><p>安装 TLS/SSL Support        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mongodb --with-openssl</span><br></pre></td></tr></table></figure><p>安装 Release of MongoDB 最新开发版，不是必须        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mongodb —devel</span><br></pre></td></tr></table></figure><p>新建目录数据库        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /data/db</span><br></pre></td></tr></table></figure><p>目录权限不足时 xxx是用户名luoyec        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown xxx /data/db</span><br></pre></td></tr></table></figure><p>启动mongoldb 服务     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br></pre></td></tr></table></figure><p>启动query database 新建终端. 可以开始各种数据库指令     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ show dab  //显示已经存在的数据库               </span><br><span class="line">$ use somedbname  //创建（使用）某个数据库                </span><br><span class="line">$ exit  //退出</span><br></pre></td></tr></table></figure><p>把mongodb/bin加入$PATH    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> export MONGO_PATH=/usr/local/mongodb    </span><br><span class="line"><span class="meta">$</span> export PATH=$PATH:$MONGO_PATH/bin</span><br></pre></td></tr></table></figure><h2 id="安装Robo可视化工具"><a href="#安装Robo可视化工具" class="headerlink" title="安装Robo可视化工具"></a>安装Robo可视化工具</h2><p><a href="https://robomongo.org/download" target="_blank" rel="noopener">直接官网下载安装即可</a> </p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>新建 /data/db  目录 ， 用于存放各个数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /data/db</span><br></pre></td></tr></table></figure></p><p>启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br></pre></td></tr></table></figure></p><p>启动命令行工具，另起一个终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br></pre></td></tr></table></figure></p><p>用可视化工具连接数据库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Install MongoDB C
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://luoyec.cn/categories/Nodejs/"/>
    
    
      <category term="mongodb" scheme="https://luoyec.cn/tags/mongodb/"/>
    
      <category term="robo" scheme="https://luoyec.cn/tags/robo/"/>
    
      <category term="工具使用" scheme="https://luoyec.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>

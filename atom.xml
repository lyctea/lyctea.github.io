<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤丶晴的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luoyec.cn/"/>
  <updated>2018-06-11T09:14:07.265Z</updated>
  <id>https://luoyec.cn/</id>
  
  <author>
    <name>luoyecong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx 部署静态页面</title>
    <link href="https://luoyec.cn/2018/06/11/cjitl6x48003p0f6pahusebtl/"/>
    <id>https://luoyec.cn/2018/06/11/cjitl6x48003p0f6pahusebtl/</id>
    <published>2018-06-11T09:14:01.244Z</published>
    <updated>2018-06-11T09:14:07.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-部署静态页面"><a href="#Nginx-部署静态页面" class="headerlink" title="Nginx 部署静态页面"></a>Nginx 部署静态页面</h1><p>在前后端分离的项目中，前端经过编译生成的文件中，往往只包含一个 <code>index.html</code> 入口文件。可以利用 <code>Nginx</code> 进行简单配置就可以实现在部署到服务器端。</p><blockquote><p>🐸 如果是 <code>nodejs</code> 的项目可以利用 <code>pm2</code> 进行部署，如果是 <code>egg</code> 的项目可以利用 <code>egg</code> 的工具 <code>egg-scripts</code> 进行部署</p></blockquote><h2 id="Nginx-的全局配置"><a href="#Nginx-的全局配置" class="headerlink" title="Nginx 的全局配置"></a>Nginx 的全局配置</h2><p>通过 <code>yum</code> 安装 <code>Nginx</code> 的配置文件在 <code>/etc/nginx/nginx.conf</code> 下。</p><p>其中 <code>include /etc/nginx/default.d/*.conf;</code> 引入在目录下的所有配置文件，原则上每个配置文件对应一个静态页面文件。</p><blockquote><p>⚠️ <code>include</code> 的坑：<code>include</code> 的位置应该在第一个 server 块后面<br>⚠️ 权限问题导致的 403： 修改 <code>conf</code> 配置 <code>user</code> 字段为 <code>root</code>（默认是 <code>nginx</code> ）</p></blockquote><p><strong>完整的 nginx.conf 配置：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="comment"># include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="attribute">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">            <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate "/etc/pki/nginx/server.crt";</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key "/etc/pki/nginx/private/server.key";</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="default-conf-的配置"><a href="#default-conf-的配置" class="headerlink" title="default.conf 的配置"></a>default.conf 的配置</h2><p>在 <code>/etc/nginx/default.d</code> 目录下配置，新建文件，一个简单的文件模板如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /root/node-project/pm2test;</span><br><span class="line">        <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 注意这里只包含 <code>server</code> 块</p><h2 id="相关命令行"><a href="#相关命令行" class="headerlink" title="相关命令行"></a>相关命令行</h2><p><strong>检查配置文件是否配置正确</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p><strong>修改配置后，刷新配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><strong>杀死 nginx 进程，重启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 nginx</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p><strong>启动 nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>利用 <code>nginx</code> 反向代理可以解决前端开中的跨域问题，而不需要服务端配合。具体请参考：<a href="http://luoyec.cn/2017/11/18/cjh5m1vhr003gsz6pr58ed54r/">Nginx 反向代理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-部署静态页面&quot;&gt;&lt;a href=&quot;#Nginx-部署静态页面&quot; class=&quot;headerlink&quot; title=&quot;Nginx 部署静态页面&quot;&gt;&lt;/a&gt;Nginx 部署静态页面&lt;/h1&gt;&lt;p&gt;在前后端分离的项目中，前端经过编译生成的文件中，往往只包含一
      
    
    </summary>
    
      <category term="工程化" scheme="https://luoyec.cn/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="nginx" scheme="https://luoyec.cn/tags/nginx/"/>
    
      <category term="部署" scheme="https://luoyec.cn/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 快速入门与专业应用</title>
    <link href="https://luoyec.cn/2018/05/14/cjitl6x4m004i0f6pizqe9mbx/"/>
    <id>https://luoyec.cn/2018/05/14/cjitl6x4m004i0f6pizqe9mbx/</id>
    <published>2018-05-14T02:03:57.255Z</published>
    <updated>2018-05-14T02:09:43.470Z</updated>
    
    <content type="html"><![CDATA[<p>摘抄自： 《 Vue.js 前端开发- 快速入门与专业应用》</p><h1 id="Vue-js-快速入门与专业应用"><a href="#Vue-js-快速入门与专业应用" class="headerlink" title="Vue.js 快速入门与专业应用"></a>Vue.js 快速入门与专业应用</h1><h2 id="Vue-js-简介"><a href="#Vue-js-简介" class="headerlink" title="Vue.js 简介"></a>Vue.js 简介</h2><p><code>Vue.js</code> 的组件化理念和 <code>ReactJS</code> 异曲同工——“一切都是组件”，可以将任意封装好的代码注册成标签，例如:<code>Vue.component(&#39;example&#39;, Example)</code>，可以在模板中以 <code>&lt;example&gt;&lt;/ example&gt;</code> 的形式调用。</p><p><code>Vue.js</code> 的使用都是通过构造函数 <code>Vue({option})</code> 创建一个 <code>Vue</code> 的实例: <code>var vm = new Vue({})</code>。一个 <code>Vue</code> 实例相当于一个 <code>MVVM</code> 模式中的 <code>ViewModel</code>。</p><p>在实例化的时候，我们可以传入一个选项对象，包含数据、模板、挂载元素、方法、生 命周期钩子等选项。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525933032850.jpg" alt=""></p><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p><strong>模板</strong></p><p><code>el</code> :类型为字符串，<code>DOM</code> 元素或函数。其作用是为实例提供挂载元素。</p><p><code>template</code> :类型为字符串。默认会将 <code>template</code> 值替换挂载元素(即 <code>el</code> 值对应的元素)， 并合并挂载元素和模板根节点的属性(如果属性具有唯一性，类似 <code>id</code>，则以模板根节点为准)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="number">123</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script id=<span class="string">"tpl"</span> type=<span class="string">"x-template"</span>&gt;   &lt;div class='tpl'&gt;</span><br><span class="line">   &lt;p&gt;This is a tpl from script tag&lt;/p&gt;   &lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  var vm = new Vue(&#123;    el : '#app',</span></span><br><span class="line"><span class="string">   template : '#tpl'   &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>Vue</code> 实例中需要有一个根元素，模板的定义只能有一个根元素，建议模板定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=<span class="string">"tpl"</span> type=<span class="string">"x-template"</span>&gt;</span><br><span class="line">  &#123;<span class="string">' '</span>&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tpl"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="tpl"&gt; ...&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 实例通过 <code>data</code> 属性定义数据，这些数据可以在实例对应的模板中进行绑定并使用。需要注意的是传入 data 是一个对象，那么 <code>Vue</code> 实例会代理起所有 <code>data</code> 对象中的所有属性，而不会对传入的对象进行深拷贝。</p><p>可以通过 <code>Vue</code> 实例 <code>vm</code> 中的 <code>$data</code> 来获取声明数据，需要注意的是，只有初始化传入的对象才是响应式的，在声明完实例后再增加的属性，将不会是响应式的</p><p><code>Vue</code> 推荐在初始化的时候将所有的变量都设定好，如果没有值，额可以用 <code>undefined</code> 或<code>null</code> 占位。</p><p>另外，组件的实例可以通过 props 获取数据，同 data ，也需要在初始化时预设好。<br>通过 <code>methods</code> 对象来定义方法，并使用 <code>v-on</code> 指令来监听 <code>DOM</code> 事件</p><p><code>Vue</code> 实例也支持自定义事件，可以在初始化时传入 <code>event</code> 对象，通过实例的 <code>$emit</code> 方法进行触发。这套机制常在组件间相互通信的情况中，例如子组件冒泡触发父组件事件方法，或者父组件广播某个事件，子组件对其进行监听等。（⚠️ <code>Vue 2.x</code> 中已经废弃 <code>events</code> 属性，不再支持事件广播，推荐直接使用 <code>Vue</code> 实例的全局方法 <code>$on()/$emit()</code>， 或者使用插件 <code>vuex</code> 来处理）</p><p><strong>生命周期</strong></p><p><code>Vue</code> 实例在创建时有一系列初始化步骤，例如建立数据观察，编译模板，创建数据绑定等，这些过程中，可以通过生命周期钩子函数<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p><ul><li><code>beforeCreate()</code> : 在实例开始初始化时同步调用，此时数据观测、事件都尚未初始化</li><li><code>created()</code>：在实例创建之后调用，此时已经完成数据绑定、事件方法，但尚未开始 <code>DOM</code> 编译，即未挂在到 <code>document</code></li><li><code>beforeMount()</code>:</li><li><code>mounted()</code>: 在编译结束时调用，此时指令已经生效，数据变化已经能触发 <code>DOM</code> 更新，但不保证 <code>$el</code> 已插入文档</li><li><code>beforeDestroy()</code>: 在开始销毁实例时调用，此时实例仍然有效</li><li><code>destroyed()</code>: 在实例被销毁之后调用，此时所有的绑定和实例指令都已经解绑，子实例也被销毁。</li><li><code>beforeUpdate()</code>: 在实例挂载之后，再次更新实例（例如更新 <code>data</code>）时会调用该方法，此时尚未更新 <code>DOM</code> 结构</li><li><code>updated()</code>: 在实例挂载之后，再次更新实例并在实例更新完 <code>DOM</code> 之后被调用</li><li><code>activated()</code>:2.0 新增的生命周期钩子，需要配合动态组件 <code>keep-live</code> 属性使用。在动态组件初始化渲染的过程中调用该方法。</li><li><code>deactivated()</code> :2.0 新增的生命周期钩子，需要配合动态组件 <code>keep-live</code> 属性使用。在动 态组件移出的过程中调用该方法。</li></ul><ul><li><p>数据绑定，<code>Vue</code> 的核心是一个响应式的数据绑定系统，简历绑定后， <code>DOM</code> 将和数据保持同步，这样就无需手动维护 <code>DOM</code>，使代码能够更加简洁易懂、提升效率。</p></li><li><p>指令，可以理解为当表达式的值发生改变时，会有些特殊行为作用到绑定的 <code>DOM</code> 上，指定通常直接书写在模板的 <code>HTML</code> 元素中，而为了有别于普通的属性， <code>Vue</code> 是带有前缀的 <code>v-</code> 属性</p></li><li><p>表单控件，<code>Vue</code> 中提供 <code>v-model</code> 的指令对表单元素进行双向绑定，在修改表单元素值的同时，实例 <code>vm</code> 中对应是属性值也会同时更新，反之亦然。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"message"</span> /&gt;</span><br><span class="line">&lt;span&gt;Your input is : &#123;&#123; message &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;label&gt;&lt;input type="radio" value="male" v-model="gender "&gt; 男 &lt;/</span>lable&gt;</span><br><span class="line">&lt;label&gt;&lt;input type="radio" value="female" v-model="gender "&gt; 女 &lt;/lable&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; gender &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ gender 值即为选中的 radio 元素的 value 值。</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 声明周期流程图中包含了模板的渲染顺序</p></blockquote><p><strong><code>Class</code> 与 <code>Style</code> 绑定</strong><br><code>class</code> 属性，我们绑定的数据可以是对象和数组，绑定修改的是元素的 <code>class</code> 属性，内联样式绑定，<code>style</code> 属性绑定数据的内联样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"alertStyle"</span>&gt;&lt;/div&gt; data : &#123;</span><br><span class="line">  alertStyle : &#123;</span><br><span class="line">   color : <span class="string">'red'</span>,</span><br><span class="line">   fontSize : <span class="string">'20px'</span>  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法，允许将多个样式绑定到同一个元素上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"[ styleObjectA, styleObjectB]"</span> .&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>自动添加前缀，在使用 <code>transform</code> 这类属性时，<code>v-bind:style</code> 会根据需要自动添加厂商前缀</p><p>条件渲染，<code>Vue.js</code> 提供 <code>v-if，v-show，v-else，v-for</code> 这几个指令来说明模板和数据间的逻辑关系，这基本就构成了模板引擎的主要部分。</p><p><code>template</code> 标签用法，<code>Vue.js</code> 提供了 <code>template</code> 标签，我们可以将指令作用到这个标 签上，但最后的渲染结果里不会有它。</p><p><strong>事件绑定与监听</strong><br>通过 <code>v-on</code> 可以绑定实例选项属性 <code>methods</code> 中的方法作为事件的处理器，<code>v-on</code>：后参数接受所有的原生事件名称。</p><p>同一元素上也可以通过 <code>v-on</code> 绑定多个相同事件函数，执行顺序为顺序执行<br><code>&lt;div v-on:click=&quot;sayFrom(&#39;first&#39;)&quot; v-on:click =&quot;sayFrom(&#39;second)&quot;&gt;</code></p><p><strong>修饰符</strong><br><code>Vue</code> 为指令 <code>v-on</code> 提供了多个修饰符，方便我们处理一些 <code>DOM</code> 事件的细节，并且修饰符可以串联使用</p><ul><li><code>.stop</code>: <code>event.stopPropagation()</code></li><li><code>.prevent</code>: <code>event.preventDefault()</code></li><li><code>.capture</code>: 使用 <code>capture</code> 模式添加事件监听器</li><li><code>.self</code>: 只当事件是从监听元素本身触发时才触发回调</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是 <code>Vue</code> 中一个重要的特性，重要提供一种机制将数据的变化映射为 <code>DOM</code> 行为。在 <code>Vue</code> 中通过数据驱动，一般情况不会直接修改 <code>DOM</code>，通过大量内置的指令进行 <code>DOM</code> 操作，也可以开发自定义指令。</p><ul><li><code>v-bind</code>: 主要用于动态绑定 <code>DOM</code> 元素属性，即属性实际的值是由 <code>vm</code> 实例中 <code>data</code> 属性提供的</li><li><code>v-model</code>: 用于表单控件</li><li><code>v-if / v-else/ v-show</code>: 展示对应模板内容</li><li><code>v-for</code>: 模板渲染</li><li><code>v-on</code>: 事件绑定</li><li><code>v-text</code>: 作用是更新元素的 <code>textContent</code>，闪现问题？⚠️</li><li><code>v-HTML</code>：作用是更新元素的 <code>innerHTML</code></li><li><code>v-el</code>：为 <code>DOM</code> 元素注册一个索引，使得可以直接访问 <code>DOM</code> 元素</li><li><code>v-ref</code>： 类似于 <code>v-el</code>，只不过这是作用域子组件上，实例可以通过 <code>$refs</code> 访问子组件</li><li><code>v-pre</code>：跳过编译这个元素和子元素，现实原始双花括号</li><li><code>v-cloak</code>：官方推荐可以和 <code>css</code> 规则 <code>[v-cloak]{ display :none }</code> 一起使用，可以隐藏未编译的 <code>Mustache</code> 标签直到实例准备完毕。<code>&lt;div v-cloak&gt;&lt;/div&gt;</code></li><li><code>v-once</code>: 用于标明元素或组件只渲染一次</li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器本质是一个函数，接受管道符前面的值作为初始值，同时也能接受额外的参数，返回值为经过处理后的输出值。多个过滤器可以串联。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA <span class="string">'arg1'</span> <span class="string">'arg2'</span> &#125;&#125; &#123;&#123; message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure><p>双向过滤器，在写回 <code>data</code> 绑定属性中的过滤器，成为双向过滤器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"price | cents"</span> &gt;</span><br><span class="line"><span class="comment">// 该过滤器的作用是处理价钱的转化，一般数据库中保存的单位都为分，避免浮点运算 Vue.filter('cents', &#123;</span></span><br><span class="line">  read : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (value / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">  write : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value * <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;   <span class="attr">el</span> : <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">   price : <span class="number">150</span>  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>过渡系统是 <code>Vue</code> 为 <code>DOM</code> 动画效果提供的一个特性，它能在元素从 <code>DOM</code> 中插入或移除时触发 <code>CSS</code> 过渡（<code>transition</code>）和动画（<code>animation</code>），也就是说在 <code>DOM</code> 元素发生变化时为其添加特定的 <code>class</code> 类名，从而产生过渡效果。除了 <code>CSS</code> 过渡外，<code>Vue.js</code> 的过渡系统也 支持 <code>javascript</code> 的过渡，通过暴露过渡系统的钩子函数，我们可以在 <code>DOM</code> 变化的特定时机对 其进行属性的操作，产生动画效果。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件注册 <code>var MyComponent = Vue.extend({ ... });</code>，这样我们获得了一个组件构造器，但现在无法直接使用这个组件，需要将组件注册到应用中。<code>Vue</code> 提供了两种注册方法，分别是全局注册和局部注册。</p><p>全局注册，需要在根实例初始化之前注册，这样才能使组件在任意实例中被使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent);</span><br></pre></td></tr></table></figure><p>对于组件的命名，<code>W3C</code> 规范是字母小写且包含一个短横杠“-”。</p><p>局部注册，限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;This is a child component&lt;/p&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; \</span></span><br><span class="line"><span class="string">   &lt;p&gt;This is a parent component&lt;/p&gt;     &lt;my-child&gt;&lt;/my-child&gt; \</span></span><br><span class="line"><span class="string">   &lt;/div&gt;'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-child'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;This is a parent component&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;This is a child component&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;;</span></span><br></pre></td></tr></table></figure><p>组件接受的选项大部分与 <code>Vue</code> 实例一样，区别</p><ul><li><code>data</code> 属性，通过函数返回</li><li>也就是说子组件的模板和模块中是 无法直接调用父组件的数据，所以通过 <code>props</code> 将父组件的数据传递给子组件，子组件在接受数 据时需要显式声明 <code>props</code>，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-child'</span>, &#123;</span><br><span class="line">  props : [<span class="string">'parent'</span>],</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123; parent &#125;&#125; is from parent'</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;my-child parent=<span class="string">"This data"</span>&gt;&lt;/my-child&gt; //-&gt; &lt;p&gt;This data is from</span><br><span class="line">parent &lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>组件间通信</strong><br><code>Vue.js</code> 在组件间通信这一部分既提供了直接访问组件实例 的方法，也提供了自定义事件机制，通过广播、派发、监听等形式进行跨组件的函数调用。</p><ul><li><code>$parent</code>: 父组件实例。</li><li><code>$children</code>: 包含所有子组件实例。</li><li><code>$root</code>: 组件所在的根实例。</li></ul><p><strong>自定义事件触发机制</strong></p><ul><li><code>$emit</code>: 在实例本身上触发</li><li><code>$dispatch</code>: 派发事件，事件沿着父链冒泡，并且在第一次触发回调后自动停止，除非触发函数明确返回 <code>true</code>，才会继续向上冒泡</li><li><code>$broadcast</code>:广播事件，事件向下传递给所有后代</li></ul><p><strong>自组件索引</strong></p><ul><li><code>this.childre</code></li><li>子组件定义指定 <code>v-ref</code> 父组件获取子组件 <code>this.$refs.first</code></li></ul><h2 id="Vue-js-常用插件"><a href="#Vue-js-常用插件" class="headerlink" title="Vue.js 常用插件"></a>Vue.js 常用插件</h2><p><code>Vue-router</code><br><code>vue-router</code>的基本作用就是讲每个路径映射到对应的组件，并通过修改路由进行组件间的切换。</p><p><code>Vue-resource</code><br>所以这里就和大家介绍下 <code>Vue.js</code> 的插件 <code>Vue- resouce</code>，它同样对异步请求进行了封装，方便我们同服务端进行数据的交互。</p><p><code>Vue-devtools</code>:它可以在 <code>chrome</code> 的开发者模式下直接查看当前页面的 <code>Vue</code> 实例的组件结构和内部属性，方便我们直接观测。</p><h2 id="状态管理-VueX"><a href="#状态管理-VueX" class="headerlink" title="状态管理 VueX"></a>状态管理 VueX</h2><p><code>Vuex</code> 是状态管理模式的一种实现库，主要以插件的形式和 <code>Vue.js</code> 进行配合使用，能够 使我们在 <code>Vue.js</code> 中管理复杂的组件事件流。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1526010695904.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘抄自： 《 Vue.js 前端开发- 快速入门与专业应用》&lt;/p&gt;
&lt;h1 id=&quot;Vue-js-快速入门与专业应用&quot;&gt;&lt;a href=&quot;#Vue-js-快速入门与专业应用&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 快速入门与专业应用&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://luoyec.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://luoyec.cn/tags/vue/"/>
    
      <category term="框架" scheme="https://luoyec.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数组去重</title>
    <link href="https://luoyec.cn/2018/05/06/cjitl6x39001k0f6p5yt99ots/"/>
    <id>https://luoyec.cn/2018/05/06/cjitl6x39001k0f6p5yt99ots/</id>
    <published>2018-05-06T11:50:18.040Z</published>
    <updated>2018-05-06T11:50:23.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-数组去重"><a href="#JavaScript-数组去重" class="headerlink" title="JavaScript 数组去重"></a>JavaScript 数组去重</h1><p><strong>方法一</strong></p><p>双循环，外循环遍历整个数组，内层循环进行比较，如果有相同的值则跳过，不同则 push 进结果数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                j = ++i <span class="comment">// 如果后面的元素等于当前外层循环遍历的元素，则跳过该元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(arr[i]) <span class="comment">//i有两种请求，一直是正常遍历的，一种是经过跳跃的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arra = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arra.distinct()) <span class="comment">//返回[3,4,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br>利用 <code>splice</code> 方法直接在原数组上将相同的元素删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                len--</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arra = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arra.distinct()) <span class="comment">//返回[3,4,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>方法三</strong><br>利用对象的属性不能相同的特点进行去重，但存在 数值型 1 和字符型 1 是同一个的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        i,</span><br><span class="line">        obj = &#123;&#125;,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">            <span class="comment">//如果能查找到，证明数组元素重复了,则不会放到结果数组中</span></span><br><span class="line">            obj[arr[i]] = <span class="number">1</span></span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a.distinct()) <span class="comment">//1,2,3,4,5,6,56</span></span><br></pre></td></tr></table></figure><p><strong>方法四</strong><br>利用<code>ES6 Set</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> resultarr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="built_in">console</span>.log(resultarr) <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p><strong>方法五</strong><br>利用 <code>indexOf</code> 和 <code>forEach</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        result = [],</span><br><span class="line">        len = arr.length</span><br><span class="line"></span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, arr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里利用map，filter方法也可以实现</span></span><br><span class="line">        <span class="keyword">var</span> bool = arr.indexOf(v, i + <span class="number">1</span>) <span class="comment">//从传入参数的下一个索引值开始寻找是否存在重复</span></span><br><span class="line">        <span class="keyword">if</span> (bool === <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.distinct()</span><br><span class="line"><span class="built_in">console</span>.log(b.toString()) <span class="comment">//1,23,2,3</span></span><br></pre></td></tr></table></figure><p><strong>方法六</strong><br>利用数组递归去重，先排序，然后从最后开始比较，遇到相同则删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.distinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">this</span>,</span><br><span class="line">        len = arr.length</span><br><span class="line">    arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对数组进行排序才能方便比较</span></span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] === arr[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            loop(index - <span class="number">1</span>) <span class="comment">//递归loop函数进行去重</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(len - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">56</span>, <span class="number">45</span>, <span class="number">56</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.distinct()</span><br><span class="line"><span class="built_in">console</span>.log(b.toString()) <span class="comment">//1,2,3,4,5,6,45,56</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-数组去重&quot;&gt;&lt;a href=&quot;#JavaScript-数组去重&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 数组去重&quot;&gt;&lt;/a&gt;JavaScript 数组去重&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;方法一&lt;/stron
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="排序算法" scheme="https://luoyec.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript排序算法</title>
    <link href="https://luoyec.cn/2018/05/06/cjitl6x3t002q0f6pqcbhq7v6/"/>
    <id>https://luoyec.cn/2018/05/06/cjitl6x3t002q0f6pqcbhq7v6/</id>
    <published>2018-05-06T03:59:25.542Z</published>
    <updated>2018-05-06T03:59:37.568Z</updated>
    
    <content type="html"><![CDATA[<p>参考：《数据结构与算法 JavaScript 描述》<br><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo 数据可视化</a></p><h1 id="JavaScript-排序算法"><a href="#JavaScript-排序算法" class="headerlink" title="JavaScript 排序算法"></a>JavaScript 排序算法</h1><p>排序算法的核心思想是对一组数据按照一定的顺序重新排列。重新排序时用到一组嵌套的 <code>for</code> 循环，其中外循环会遍历数组的每一项，内循环则用于比较元素。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>之所以叫冒泡排序，是因为排序时，数据会像起跑一样从数组的一端漂浮到另一端。算法在数组中移动，比较相邻的数据，当左侧大于右侧数据时将他们进行交换。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、第一轮排序之后就能将最大数放到最后，那么经过 n-1 轮，就能完成所有的排序，所以需要遍历的次数是 n-1</span></span><br><span class="line"><span class="comment"> * 2、内层循环中，max - i 而不是 max？ 因为没经过一轮都会讲最大数放到后面，不再需要对这些已经排序的值进行再次遍历</span></span><br><span class="line"><span class="comment"> * 3、为什么需要标志位，当一次遍历之后发现没有进行任何交换，说明次数数组已经完成排序，跳出循环，返回结果即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = data.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; max - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = data[j]</span><br><span class="line">                data[j] = data[j + <span class="number">1</span>]</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j]</span><br><span class="line">                done = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testArr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6579</span>, <span class="number">7569</span>, <span class="number">23.32</span>, <span class="number">234</span>, <span class="number">234</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(testArr))</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序从数组的开头开始，将第一个元素和其他<strong>每一个</strong>元素进行比较，检查所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便完成了排序。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外层循环遍历 n-1 次</span></span><br><span class="line"><span class="comment"> * 内层循环，没经过一次，找出最小值的坐标，循环结束后交互外循环坐标和最小坐标元素</span></span><br><span class="line"><span class="comment"> * 内层循环是依次减少的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> example = [<span class="number">8</span>, <span class="number">94</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">21</span>, <span class="number">39</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectSort(example))</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序有两个循环，外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及后面的那个元素进行比较。如果外循环中选中的元素比内循环中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组长度为1时，不需要排序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// tmp 是需要被插入的元素</span></span><br><span class="line">        <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历已经排序的元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j - <span class="number">1</span>] &gt; tmp) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">            --j</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort([<span class="number">1</span>, <span class="number">45</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的工作原理是，通过定义一个间隔序列来小时排序过程中进行比较的元素之间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分实际应用常见，算法要用到间隔序列可以提前定义好。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525575968269.jpg" alt=""></p><p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 动态定义间隔序列 1 4 13</span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = [<span class="number">8</span>, <span class="number">94</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">21</span>, <span class="number">39</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(shellSort(example))</span><br></pre></td></tr></table></figure><p>外循环控制间隔序列的移动，也就是说，算法在第一次处理数据集时，会检查所有间隔为 4 的元素，下一次检查间隔为 1 的元素。在开始最后一次处理是时，大部分元素都将在正确的位置，算法就不必对很多元素进行交换，这也是希尔排序高效的地方。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是序列的。</p><p>首先要在列表中选择一个元素作为基准值 (<code>pivot</code>)。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525577492984.jpg" alt=""></p><p>快速排序的算法和伪代码：</p><ul><li>选择一个基准元素，将列表分隔成两个子序列</li><li>对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面</li><li>分别对较小元素的子序列和较大元素的子序列重复步骤 1 和步骤 2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> left = [] <span class="comment">//小于基准存放数组</span></span><br><span class="line">    <span class="keyword">var</span> right = [] <span class="comment">// 大于基准存放数组</span></span><br><span class="line">    <span class="keyword">var</span> pivot = arr[<span class="number">0</span>] <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qSort(left).concat(pivot, qSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span> + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(qSort(a))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：《数据结构与算法 JavaScript 描述》&lt;br&gt;&lt;a href=&quot;https://visualgo.net/zh/sorting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;visualgo 数据可视化&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Jav
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="排序算法" scheme="https://luoyec.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AJAX 工作原理及概述</title>
    <link href="https://luoyec.cn/2018/05/04/cjitl6x2f00050f6pg8vtx6p2/"/>
    <id>https://luoyec.cn/2018/05/04/cjitl6x2f00050f6pg8vtx6p2/</id>
    <published>2018-05-04T07:11:14.446Z</published>
    <updated>2018-05-04T07:11:33.599Z</updated>
    
    <content type="html"><![CDATA[<p>参考： <a href="https://segmentfault.com/a/1190000004322487" target="_blank" rel="noopener">你真的会使用 XMLHttpRequest 吗？</a></p><h1 id="AJAX-工作原理及概述"><a href="#AJAX-工作原理及概述" class="headerlink" title="AJAX 工作原理及概述"></a>AJAX 工作原理及概述</h1><p><code>AJAX</code> 使用 <code>XMLHttpRequest</code> 对象与服务器通信，它可以使用 <code>JSON、XML、HTML</code>和文本等多种格式发送和接受。<code>AJAX</code> 最吸引人的是它的异步特性，也就是说可以在不重新刷新页面的情况下雨服务器通信，交换数据，更新页面。</p><p>最主要的两个特性：</p><ul><li>在不重新加载页面的情况下发送请求给服务器</li><li>接受并使用从服务器发来的数据</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>Ajax</code> 的原理简单来说通过 <code>XmlHttpRequest</code> 对象来向服务器发异步请求，从服务器获得数据，然后用 <code>javascript</code> 来操作 <code>DOM</code> 而更新页面。这其中最关键的一步就是从服务器获得请求数据。</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><p>创建 <code>XMLHttpRequest</code> 对象，需要注意兼容性问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造表单数据</span></span><br><span class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">    formData.append(<span class="string">'username'</span>, <span class="string">'johndoe'</span>)</span><br><span class="line">    formData.append(<span class="string">'id'</span>, <span class="number">123456</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 xhr 对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.timeout = <span class="number">3000</span></span><br><span class="line">    xhr.responseType = <span class="string">'text'</span></span><br><span class="line">    <span class="comment">//创建一个 post 请求， 第三个布尔值参数是同步还是异步, 默认是异步</span></span><br><span class="line">    xhr.open(<span class="string">'POST'</span>, <span class="string">'/server'</span>, <span class="literal">true</span>)</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span> || <span class="keyword">this</span>.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">    xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    xhr.send(formData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置请求头 xhr.setRequestHeader('X-Text', 'one')</span></span><br><span class="line"><span class="comment"> * 获取响应头</span></span><br><span class="line"><span class="comment">*/</span><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 指定响应类型</span></span><br><span class="line"><span class="string">`</span>responseType<span class="string">` 是 `</span>xhr level <span class="number">2</span><span class="string">` 新增的属性，用来指定 `</span>xhr.response<span class="string">` 的数据类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![][2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/path/to/image.png'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//可以将`xhr.responseType`设置为`"blob"`也可以设置为`" arrayBuffer"`</span></span><br><span class="line"><span class="comment">//xhr.responseType = 'arrayBuffer';</span></span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">this</span>.response;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h2 id="如何获取-response-数据"><a href="#如何获取-response-数据" class="headerlink" title="如何获取 response 数据"></a>如何获取 response 数据</h2><p><code>xhr</code> 提供了 3 个属性来获取请求返回的数据，分别是：<code>xhr.response、xhr.responseText、xhr.responseXML</code></p><ul><li><p><code>xhr.response</code> - 默认值：空字符串<code>&quot;&quot;</code> - 当请求完成时，此属性才有正确的值 - 请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></p></li><li><p><code>xhr.responseText</code> - 默认值为空字符串<code>&quot;&quot;</code> - 只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、””时，<code>xhr</code> 对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错 - 只有当请求成功时，才能拿到正确值。以下 2 种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</p></li><li><p><code>xhr.responseXML</code> - 默认值为 <code>null</code> - 只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code> 对象上才有此属性，此时才能调用 <code>xhr.responseXML</code>，否则抛错 - 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下 3 种情况下值都为 <code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p></li></ul><h2 id="如何追踪-ajax-请求的当前状态"><a href="#如何追踪-ajax-请求的当前状态" class="headerlink" title="如何追踪 ajax 请求的当前状态"></a>如何追踪 ajax 请求的当前状态</h2><p>用 <code>xhr.readyState</code> 这个属性即可追踪到。这个属性是只读属性，总共有 5 种可能值，分别对应 xhr 不同的不同阶段。每次 <code>xhr.readyState</code> 的值发生变化时，都会触发 <code>xhr.onreadystatechange</code> 事件，我们可以在这个事件中进行相关状态判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(xhr.readyState)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525417528673.jpg" alt=""></p><h2 id="可以发送什么类型的数据"><a href="#可以发送什么类型的数据" class="headerlink" title="可以发送什么类型的数据"></a>可以发送什么类型的数据</h2><p><code>xhr.send(data)</code>的参数 <code>data</code> 可以是以下几种类型：</p><ul><li><code>ArrayBuffer</code></li><li><code>Blob</code></li><li><code>Document</code></li><li><code>DOMString</code></li><li><code>FormData</code></li><li><code>null</code></li></ul><h2 id="事件触发顺序"><a href="#事件触发顺序" class="headerlink" title="事件触发顺序"></a>事件触发顺序</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525417713166.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考： &lt;a href=&quot;https://segmentfault.com/a/1190000004322487&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你真的会使用 XMLHttpRequest 吗？&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;AJAX-工作
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="ajax" scheme="https://luoyec.cn/tags/ajax/"/>
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="XMLHttpRequest" scheme="https://luoyec.cn/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式练习题</title>
    <link href="https://luoyec.cn/2018/05/01/cjitl6x61007p0f6p39c98usy/"/>
    <id>https://luoyec.cn/2018/05/01/cjitl6x61007p0f6p39c98usy/</id>
    <published>2018-05-01T06:31:39.761Z</published>
    <updated>2018-05-01T06:31:52.739Z</updated>
    
    <content type="html"><![CDATA[<p>资源：<br><a href="https://www.hackerrank.com/challenges/matching-anything-but-new-line/problem" target="_blank" rel="noopener">HackerRank 正则练习</a><br><a href="https://regexper.com/#%5E%28.%7B3%7D%5C.%29%7B3%7D.%7B3%7D$" target="_blank" rel="noopener">Regexper 正则可视化</a><br><a href="https://juejin.im/post/5ac1f1106fb9a028be362731" target="_blank" rel="noopener">面试中会遇到的正则题</a></p><h1 id="正则表达式练习题"><a href="#正则表达式练习题" class="headerlink" title="正则表达式练习题"></a>正则表达式练习题</h1><h2 id="匹配连续出现的四组以-连接的字符串"><a href="#匹配连续出现的四组以-连接的字符串" class="headerlink" title="匹配连续出现的四组以 . 连接的字符串"></a>匹配连续出现的四组以 <code>.</code> 连接的字符串</h2><p>题目：<code>abc.dss.sds.wer</code></p><p>答案：<code>/^(.{3}\.){3}.{3}$/g</code> 或者 <code>^(...\.){3}...$</code></p><ul><li><code>^</code> 以什么作为开头</li><li><code>$</code> 以什么作为结尾</li><li><code>.</code> 表示匹配任意字符</li><li><code>\.</code> 转义表示匹配 <code>.</code> 字符本身</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524932841581.jpg" alt=""></p><h2 id="匹配数字而非数字"><a href="#匹配数字而非数字" class="headerlink" title="匹配数字而非数字"></a>匹配数字而非数字</h2><p>题目：<code>xxXxxXxxxx</code></p><p>答案：<code>/(\d{2}\D){2}\d{4}/</code></p><ul><li><code>\d</code> 表示匹配一个数字</li><li><code>\D</code> 表示匹配非数字字符</li><li><code>()</code> 表示一个分组</li><li><code>{2}</code> 表示重复匹配两次</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934463555.jpg" alt=""></p><h2 id="匹配空白符"><a href="#匹配空白符" class="headerlink" title="匹配空白符"></a>匹配空白符</h2><p>题目： <code>SSsSSsSS</code></p><p>答案：<code>(\S{2}\s){2}\S{2}</code></p><ul><li><code>\S</code> 表示非空白符（<code>\r\n\t\f</code>）都是空白符</li><li><code>\s</code> 表示空白符</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934661285.jpg" alt=""></p><h2 id="匹配单词字符"><a href="#匹配单词字符" class="headerlink" title="匹配单词字符"></a>匹配单词字符</h2><p>单词字符包括从 <code>a-z A-Z 0-9</code> 和 <code>_</code></p><ul><li><code>\w</code> 匹配单词字符</li><li><code>\W</code> 匹配非单词字符</li></ul><h2 id="边界匹配，以什么开始，以什么结束"><a href="#边界匹配，以什么开始，以什么结束" class="headerlink" title="边界匹配，以什么开始，以什么结束"></a>边界匹配，以什么开始，以什么结束</h2><p><code>^\d\w{4}\.$</code></p><p>匹配以数字开头的一个字符，连续四个单词字符，以 <code>.</code> 结束的字符串</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1524937039845.jpg" alt=""></p><h2 id="转换为驼峰命名"><a href="#转换为驼峰命名" class="headerlink" title="转换为驼峰命名"></a>转换为驼峰命名</h2><p><code>var s1 = &quot;get-element-by-id&quot;;</code> 给定这样一个连字符串，<code>写一个function</code> 转换为驼峰命名法形式的字符串 <code>getElementById</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'get-element-by-id'</span> <span class="comment">// getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断字符串是否包含数字"><a href="#判断字符串是否包含数字" class="headerlink" title="判断字符串是否包含数字"></a>判断字符串是否包含数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'arhs 23jyfhahr 234 ag'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/\d/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断电话号码"><a href="#判断电话号码" class="headerlink" title="判断电话号码"></a>判断电话号码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'13898762123'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否符合指定格式"><a href="#判断是否符合指定格式" class="headerlink" title="判断是否符合指定格式"></a>判断是否符合指定格式</h2><p>给定字符串 str，检查其是否符合如下格式<br>XXX-XXX-XXXX，其中 X 为 Number 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'234-234-2342'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否符合-USD-格式"><a href="#判断是否符合-USD-格式" class="headerlink" title="判断是否符合 USD 格式"></a>判断是否符合 USD 格式</h2><p>给定字符串 str，检查其是否符合美元书写格式</p><ul><li>以 $ 开始</li><li>整数部分，从个位起，满 3 个数字用 , 分隔</li><li>如果为小数，则小数部分长度为 2</li><li>正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3**</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'$1,023,032.03'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/g</span>.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-实现千位分隔符"><a href="#JS-实现千位分隔符" class="headerlink" title="JS 实现千位分隔符"></a>JS 实现千位分隔符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regx = <span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span></span><br><span class="line">    <span class="keyword">return</span> (number + <span class="string">''</span>).replace(regx, <span class="string">'$&amp;,'</span>) <span class="comment">// $&amp;表示与regx相匹配的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-url-中的参数"><a href="#获取-url-中的参数" class="headerlink" title="获取 url 中的参数"></a>获取 url 中的参数</h2><blockquote><p><code>replace()</code> 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式,<br>替换值可以是一个字符串或者一个每次匹配都要调用的函数。<br>⚠️ 返回新的字符串，而原来的字符串不会被改变。如果第二个参数是个函数，那么函数的返回值将会替换字符串中匹配到的元素，如果第一个参数是个正则，且是全局匹配模式，那么该函数将会被多次调用，每次匹配到元素都会被执行。</p></blockquote><p><code>replace()</code> 参数：</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1525150013967.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span></span><br><span class="line">    <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">' - '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newString = <span class="string">'abc12345#$*%'</span>.replace(<span class="regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer)</span><br><span class="line"><span class="built_in">console</span>.log(newString) <span class="comment">// abc - 12345 - #$*%</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析的结果以对象行使存放</span></span><br><span class="line">    <span class="keyword">var</span> arr = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  字符串查找替换方法，可以传入字符串或者正则作为第一个参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &#123;regexp&#125; 以等号连接的，前面可以有?开始，后面可以有&amp; 结束的</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; matchKey 第一个圆括号匹配到的值，也就是参数等号左边的key</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; matchValue 第而个圆括号匹配到的值，也就是参数等号右边的value</span></span><br><span class="line"><span class="comment">     * @returns 返回替换后的字符串，原有的字符串不会被改变</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    url.replace(<span class="regexp">/\??(\w+)=(\w+)&amp;?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, matchKey, matchValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!arr[matchKey]) &#123;</span><br><span class="line">            arr[matchKey] = matchValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果参数存在重复，则连接两个参数的值，存放在一个数组中</span></span><br><span class="line">            <span class="keyword">var</span> temp = arr[matchKey]</span><br><span class="line">            arr[matchKey] = [].concat(temp, matchValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断第二个参数key，绝对返回内容</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ele <span class="keyword">in</span> arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ele = key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr[ele]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = getUrlParam(<span class="string">'www.baidu.com?name=234234&amp;age=age&amp;name=tt'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h2 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'luoyecong@aliyun.com'</span></span><br><span class="line"><span class="comment">// ? 最多一个</span></span><br><span class="line"><span class="comment">// + 最少一个</span></span><br><span class="line"><span class="comment">// * 零个或多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个合法的邮箱地址有三部分组成，以 @  . 符号连接，每个部分需要符合 a-zA-z0-9_- 字符组成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmail</span>(<span class="params">email = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^([a-zA-Z\d_-])+@([a-zA-Z\d_-])+\.([a-zA-Z\d_-])+$/</span>.test(email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEmail(<span class="string">'luo2\3yec_-ong@ali23yun.com'</span>))</span><br></pre></td></tr></table></figure><h2 id="验证合法身份证号"><a href="#验证合法身份证号" class="headerlink" title="验证合法身份证号"></a>验证合法身份证号</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 身份证号码可能为15位或18位，15位为全数字，18位中前17位为数字，最后一位为数字或者X</span></span><br><span class="line"></span><br><span class="line">;<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span></span><br></pre></td></tr></table></figure><h2 id="匹配汉字"><a href="#匹配汉字" class="headerlink" title="匹配汉字"></a>匹配汉字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^[\u4e00-\u9fa5]&#123;0,&#125;$/</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 这种匹配汉字的方法并不严谨，正确的方法是通过正则的底层提供的校验，但是需要 babel 的协助，还有汉字并不包括标点，具体请参看<br><a href="https://zhuanlan.zhihu.com/p/33335629" target="_blank" rel="noopener">JavaScript 正则表达式匹配汉字</a></p></blockquote><h2 id="去除首尾的’-‘"><a href="#去除首尾的’-‘" class="headerlink" title="去除首尾的’/‘"></a>去除首尾的’/‘</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以一个或者多个 / 开始或者以一个或者多个 / 结束的</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'/asdf//'</span></span><br><span class="line">str = str.replace(<span class="regexp">/^\/+|\/+$/g</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="判断日期格式是否符合-‘2017-05-11’的形式，简单判断，只判断格式"><a href="#判断日期格式是否符合-‘2017-05-11’的形式，简单判断，只判断格式" class="headerlink" title="判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式"></a>判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^\d&#123;4&#125;\-\d&#123;1,2&#125;\-\d&#123;1,2&#125;$/</span></span><br></pre></td></tr></table></figure><h2 id="判断日期格式是否符合-‘2017-05-11’的形式，严格判断（比较复杂）"><a href="#判断日期格式是否符合-‘2017-05-11’的形式，严格判断（比较复杂）" class="headerlink" title="判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）"></a>判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/</span></span><br></pre></td></tr></table></figure><h2 id="IPv4-地址正则"><a href="#IPv4-地址正则" class="headerlink" title="IPv4 地址正则"></a>IPv4 地址正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</span></span><br></pre></td></tr></table></figure><h2 id="十六进制颜色正则"><a href="#十六进制颜色正则" class="headerlink" title="十六进制颜色正则"></a>十六进制颜色正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/</span></span><br></pre></td></tr></table></figure><h2 id="车牌号正则"><a href="#车牌号正则" class="headerlink" title="车牌号正则"></a>车牌号正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/</span></span><br></pre></td></tr></table></figure><h2 id="过滤-HTML-标签"><a href="#过滤-HTML-标签" class="headerlink" title="过滤 HTML 标签"></a>过滤 HTML 标签</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配一对&lt;&gt; 内不包括 &lt;&gt;  的</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&lt;p&gt;dasdsa&lt;/p&gt;nice &lt;br&gt; test&lt;/br&gt;'</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/&lt;[^&lt;&gt;]+&gt;/g</span></span><br><span class="line">str = str.replace(regx, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="密码强度正则，最少-6-位，包括至少-1-个大写字母，1-个小写字母，1-个数字，1-个特殊字符"><a href="#密码强度正则，最少-6-位，包括至少-1-个大写字母，1-个小写字母，1-个数字，1-个特殊字符" class="headerlink" title="密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符"></a>密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续使用前瞻，匹配多个符合要求的分组，在每个分组中，任意字符、字母、数字、特殊字符</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span></span><br></pre></td></tr></table></figure><h2 id="URL-正则"><a href="#URL-正则" class="headerlink" title="URL 正则"></a>URL 正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/</span></span><br></pre></td></tr></table></figure><h2 id="匹配标签内数据，包括标签"><a href="#匹配标签内数据，包括标签" class="headerlink" title="匹配标签内数据，包括标签"></a>匹配标签内数据，包括标签</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;OPTION value="待处理"&gt;待处理&lt;/OPTION&gt;</span></span><br><span class="line"><span class="comment">// 写一个正则表达式,匹配 "&lt;OPTION value="待处理"&gt;"</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&lt;OPTION value="待处理"&gt;待处理&lt;/OPTION&gt;'</span></span><br><span class="line"><span class="keyword">var</span> regx = <span class="regexp">/^&lt;.*?&gt;/</span></span><br><span class="line"><span class="keyword">var</span> resiult = regx.exec(str)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源：&lt;br&gt;&lt;a href=&quot;https://www.hackerrank.com/challenges/matching-anything-but-new-line/problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HackerRank 正
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="正则" scheme="https://luoyec.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 类的继承</title>
    <link href="https://luoyec.cn/2018/04/17/cjitl6x3e001w0f6pqto9127g/"/>
    <id>https://luoyec.cn/2018/04/17/cjitl6x3e001w0f6pqto9127g/</id>
    <published>2018-04-17T05:16:30.391Z</published>
    <updated>2018-04-17T05:59:53.545Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript 设计模式》总结</p><h1 id="JavaScript-类的继承"><a href="#JavaScript-类的继承" class="headerlink" title="JavaScript 类的继承"></a>JavaScript 类的继承</h1><blockquote><p>大体上，每个类由三部分组成，第一部分是构造函数内的，这是供实例化对象复制用的；第二部分是构造函数外的，直接通过点语法添加的，这是供类使用的，实例化对象是访问不到的；第三部分是类的原型中的，实例化对象可以通过其原型链间接地访问到，也是为供所有实例化对象所使用的。</p></blockquote><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类式继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.superValue = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为父类添加共有方法</span></span><br><span class="line">SuperClass.prototype.getSuperVlaue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.superValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subValue = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//为子类添加共有方法</span></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新创建的对象复制了父类的构造函数内的属性与方法并且将原型 <code>__proto__</code> 指向了父类的原型对象，这样就拥有了父类的原型对象上的属性和方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。</p><p><strong>弊端</strong></p><ul><li>父类的共有属性要是引用类型，就会在子类中被所有实例共有，因此一个子类的实例更改子类型从父类构造函数中继承来的共有属性就会直接影响到其他子类</li></ul><ul><li>子类的实现的继承是靠其原型 <code>prototype</code> 对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因此在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li></ul><h2 id="构造函数式继承（创建即继承）"><a href="#构造函数式继承（创建即继承）" class="headerlink" title="构造函数式继承（创建即继承）"></a>构造函数式继承（创建即继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 引用类型共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.books = [<span class="string">"JavaScript"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>]</span><br><span class="line">    <span class="comment">// 值类型共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类声明原型方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.books)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承父类</span></span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一个子类的实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = newSubClass(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个子类的实例</span></span><br><span class="line"><span class="keyword">var</span> instance2 = newSubClass(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523939316850.jpg" alt=""></p><p><strong>分析</strong><br><code>SuperClass.call(this, id)</code> 这是构造函数式继承的精华，由于 call 这个方法可以改变函数的作用域，因此在子类中，对 <code>SuperClass</code> 调用这个方法就是将子类的变量在父类中执行一遍，由于父类是给 <code>this</code> 绑定属性的，那么子类自然也就继承了父类的共有属性。</p><p><strong>弊端</strong><br>这种继承方式没有涉及原型 <code>prototype</code>， 所以父类的原型方法自然不会被子类继承，而如果想要被子类继承就必须放在构造函数中，这样的创建方式的每个实例都会单独的拥有一份而不能共用，也就违背了代码复用的原则。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>接上文，类式继承是通过子类原型的 <code>prototype</code> 对父类实例化来实现的，构造继承是通过在子类的构造函数作用环境中执行了一次父类的构造函数来实现的，组合继承整合这两点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="comment">//引用类型的共有属性</span></span><br><span class="line">    <span class="keyword">this</span>.books = [<span class="string">"JavaScript"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型共有方法</span></span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类式继承 子类原型继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"><span class="comment">// 子类原型方法</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523939997209.jpg" alt=""></p><p><strong>弊端</strong><br>在使用构造函数继承是执行了一遍父类的构造函数，而在实现子类原型的类式继承又调用了一遍父类的构造函数，因此父类的构造函数调用了两遍。造成不必要的资源浪费。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote><p>借助原型 prototype 可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。 – 道格拉斯·克罗克福德</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="comment">//声明一个过渡函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//  过渡对象的原型继承父对象</span></span><br><span class="line"> F.prototype = o;</span><br><span class="line"> <span class="comment">//返回过渡对象的一个实例，该实例的原型继承了父对象</span></span><br><span class="line"> reutrn <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523941042826.jpg" alt=""></p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明基对象</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">name : <span class="string">'js book'</span>,</span><br><span class="line">alikeBook = [<span class="string">'css book'</span>, <span class="string">'html book'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 通过原型继承方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> inheritObject(obj);</span><br><span class="line">o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回扩展后的对象</span></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄生式继承其实就是对原型继承的二次封装，并且在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且添加新的属性和方法。</p><h2 id="寄生组合式继承（目前最好的继承实现）"><a href="#寄生组合式继承（目前最好的继承实现）" class="headerlink" title="寄生组合式继承（目前最好的继承实现）"></a>寄生组合式继承（目前最好的继承实现）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决2.4中组合继承问题： 在使用构造函数继承时执行了一遍父类的够赞方法，而在实例化子类的时候又执行了一遍父类的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 《JavaScript中原型式继承》：借助原型 prototype 已有的对象创建一个新的对象，同时不必创建新的自定义对象类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寄生组合继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面的函数得到的对象F，拥有了对象o的全部属性（在原型链上），而修改F的属性，不会影响到o，相当于把o复制了一份。</span></span><br><span class="line"><span class="comment"> * F 对象拥有父对象的所有方法（在原型链上）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生命一个过渡函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//过渡对象的原型式父对象</span></span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="comment">//返回过渡对象的一个实例，该实例的原型继承了父对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 复制一份父类的原型副本保存在变量中， 复制了父类原型的所有属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> p = inheritObject(SuperClass.prototype)</span><br><span class="line">    <span class="comment">//修正因为重写子类原型导致子类的 constructor 属性被修改</span></span><br><span class="line">    p.constructor = subClass</span><br><span class="line">    <span class="comment">//设置子类原型</span></span><br><span class="line">    subClass.prototype = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"black"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义父类原型方法</span></span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数式继承</span></span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="comment">//子类新增属性</span></span><br><span class="line">    <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生式继承父类原型</span></span><br><span class="line">inheritPrototype(SubClass, SuperClass)</span><br><span class="line"><span class="comment">//子类新增原型方法</span></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个测试方法</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">"js book"</span>, <span class="number">2014</span>)</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">"css book"</span>, <span class="number">2013</span>)</span><br></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavaScript 实现多继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.mix = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>,</span><br><span class="line">        len = <span class="built_in">arguments</span>.length,</span><br><span class="line">        arg</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历被继承的对象</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//缓存当前对象</span></span><br><span class="line">        arg = <span class="built_in">arguments</span>[i]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> arg) &#123;</span><br><span class="line">            <span class="keyword">this</span>[property] = arg[property]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    name: <span class="string">"JavaScript"</span>,</span><br><span class="line">    alike: [<span class="string">"css"</span>, <span class="string">"js"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherBook = &#123;</span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newBook = &#123;&#125;</span><br><span class="line"></span><br><span class="line">newBook.mix(newBook, anotherBook, book)</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523942104926.jpg" alt=""></p><h2 id="ES6-class-实现继承"><a href="#ES6-class-实现继承" class="headerlink" title="ES6 class 实现继承"></a>ES6 class 实现继承</h2><p><code>class</code> 声明创建一个基于原型继承的具有给定名称的新类。</p><p>你也可以使用类表达式定义类。但是不同于类表达式，类声明不允许再次声明已经存在的类，否则将会抛出一个类型错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(width, height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">        <span class="keyword">this</span>.height = height</span><br><span class="line">        <span class="keyword">this</span>.area = width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">        <span class="keyword">this</span>.title = <span class="string">"hh"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subclass = <span class="keyword">new</span> SubClass(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subclass.area)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《JavaScript 设计模式》总结&lt;/p&gt;
&lt;h1 id=&quot;JavaScript-类的继承&quot;&gt;&lt;a href=&quot;#JavaScript-类的继承&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 类的继承&quot;&gt;&lt;/a&gt;JavaScript 类的继
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="类" scheme="https://luoyec.cn/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="https://luoyec.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 类的封装</title>
    <link href="https://luoyec.cn/2018/04/15/cjitl6x3d001s0f6pyls0v2ac/"/>
    <id>https://luoyec.cn/2018/04/15/cjitl6x3d001s0f6pyls0v2ac/</id>
    <published>2018-04-15T13:51:01.501Z</published>
    <updated>2018-04-15T13:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://blog.csdn.net/xi_2130/article/details/50276025" target="_blank" rel="noopener">js 如何创建类（封装）</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a><br><a href="https://item.jd.com/11747684.html" target="_blank" rel="noopener">《JavaScript 设计模式》</a></p><h1 id="JavaScript-类的封装"><a href="#JavaScript-类的封装" class="headerlink" title="JavaScript 类的封装"></a>JavaScript 类的封装</h1><p>在 <code>JavaScript</code> 中，类的实现是基于原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。</p><p>如果两个对象继承自同一个原型，往往意味着它们是由同一个构造函数创建并初始化的。</p><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>在 <code>JavaScript</code> 中创建一个类很容易，声明一个函数保存在一个变量中，在这个函数内部使用<code>this</code> 添加属性或者方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523793569198.jpg" alt=""></p><p>也可以通过在类的原型对象上添加属性和方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523793628214.jpg" alt=""></p><blockquote><p>⁉️ 通过 <code>prototype</code> 和 <code>this</code> 添加属性和方法有什么区别？通过 <code>this</code> 是在当前对手上添加的，每次对象被创建时这些方法和属性都会被重复创建；而通过 <code>prototype</code> 继承的方法不是对象自身的，所以当使用这些方法和属性时，会通过 <code>prototype</code> 一级一级想上查找（原型链），所有不会被重复创建（但是原型上的属性被修改是，所有继承该原型的对象都会被影响）。</p></blockquote><blockquote><p>⁉️ 什么是 <code>constructor</code> ？这是一个属性，当创建一个函数或对象时都会为期创建一个原型对象 <code>prototype</code>， 在 <code>prototype</code> 对象中又会创建一个 <code>constructor</code> 属性，那么 <code>constructor</code> 属性指向的就是拥有整个原型对象的函数或者对象。</p></blockquote><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523794135407.jpg" alt=""></p><h2 id="属性和方法的封装"><a href="#属性和方法的封装" class="headerlink" title="属性和方法的封装"></a>属性和方法的封装</h2><p>利用 <code>JavaScript</code> 的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建私有变量和私有方法。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523796141443.jpg" alt=""></p><p>思考 <code>new</code> 运算符原理，通过 <code>new</code> 实例化对象时，构造函数执行，<code>this</code> 执行新创建的对象。</p><p>类通过 <code>prototype</code> 创建的属性或者方法在类的实例对象是可以通过 <code>this</code> 访问的。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523797992598.jpg" alt=""></p><h2 id="再进一步，利用闭包进行封装"><a href="#再进一步，利用闭包进行封装" class="headerlink" title="再进一步，利用闭包进行封装"></a>再进一步，利用闭包进行封装</h2><blockquote><p>闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另一个函数。我们将这个闭包作为创建对象的构造函数，在闭包内部返回一个完整的类。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bookNum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkBook</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_book</span>(<span class="params">newID, newName, newPrice</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name, price</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">checkID</span>(<span class="params">id</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接构建原型</span></span><br><span class="line">    _book.prototype = &#123;</span><br><span class="line">        isJSBook: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   记得要返回该对象，否则会 “is not a constructor”</span></span><br><span class="line">    <span class="keyword">return</span> _book</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> Book1()</span><br></pre></td></tr></table></figure><h2 id="创建对象的安全模式"><a href="#创建对象的安全模式" class="headerlink" title="创建对象的安全模式"></a>创建对象的安全模式</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523799581237.jpg" alt=""></p><p>当忘记写 new 运算符时，是对象的直接复制，对象内部的 <code>this</code> 指向的是全局对象<code>window</code>，使用 <code>instanceof</code> 运算符判断当前 <code>this</code>，在使用闭包的封装中，是不会有整个问题的，其属性和方法都被限定在函数内部的作用域中。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523799875156.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/xi_2130/article/details/50276025&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js 如何创建类（封装）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http:
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="类" scheme="https://luoyec.cn/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="https://luoyec.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基本数据类型-对象</title>
    <link href="https://luoyec.cn/2018/04/15/cjitl6x37001g0f6pizfcp3d8/"/>
    <id>https://luoyec.cn/2018/04/15/cjitl6x37001g0f6pizfcp3d8/</id>
    <published>2018-04-14T19:03:40.058Z</published>
    <updated>2018-04-14T19:03:45.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-基本数据类型-对象"><a href="#JavaScript-基本数据类型-对象" class="headerlink" title="JavaScript 基本数据类型-对象"></a>JavaScript 基本数据类型-对象</h1><p>对象是 <code>JavaScript</code> 的基本数据类型，对象可以看做是属性的无序集合。对象不仅仅是字符串到值的映射，除了保持自身的属性，<code>JavaScript</code> 对象还可从一个称谓原型的对象中继承属性。对象的方法通常是继承的属性。这种“原型式继承”是 <code>JavaScript</code> 的核心特征。</p><p>对象的常见方法：</p><ul><li>创建 <code>create</code></li><li>设置 <code>set</code></li><li>查找 <code>query</code></li><li>删除 <code>delete</code></li><li>检测 <code>test</code></li><li>枚举 <code>enumerate</code></li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>创建对象最简单的方式就是使用对象字面量（直接量）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"min title"</span>: <span class="string">"JavaScript"</span>, <span class="comment">//属性名字有空格、连接符（-），必须要用字符串表示</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="string">"all audiences"</span> <span class="comment">// for 是保留字，必须用引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象字面量是一个表达式，每次运算都会创建并初始化一个新的对象。这就意味着，如果在一个重复调用的函数的循环内使用了对象字面量，它将创建很多对象，并且每次创建的对象的属性值都有可能不同。</p><h3 id="通过-new-创建对象"><a href="#通过-new-创建对象" class="headerlink" title="通过 new 创建对象"></a>通过 new 创建对象</h3><p>new 运算符创建并初始化一个对象。new 后跟随一个函数调用，这个函数被称为构造函数（constructor），构造函数用以初始化一个新创建的对象。</p><p>JavaScript 的原始类型都包含内置构造函数，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Arrya()</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>)</span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个 <code>JavaScript</code> 对象（<code>null</code> 除外）都和另一个对象相关联。</p><p>所有通过对象字面量创建的对象，原型都指向 <code>Object.prototype</code> (<code>obj.__proto__ === Object.prototype</code>)，通过 <code>new</code> 关键字创建的对象，其原型就是构造函数的 <code>prototype</code> 属性的值。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>ES6</code> 中新增的方法，它创建一个新对象，其中第一个采纳数是这个对象原型。 <code>Object.create()</code> 提供第二个参数，用以对对象的属性进行进一步描述。</p><p>创建一个空对象，（例如和 <code>{}、new Object()</code> 一样） ，需要传入 <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure><p>使用该方法，可以使得任意对象得以被继承，这是一个强大的特性。</p><h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>可以通过 <code>.</code> 或者方括号 <code>[]（必须是一个计算结果为字符串的表达式）</code> 运算符来获取属性的值。</p><h3 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h3><p>查询一个不存在属性并不会报错，会返回 undefined，但是如果对象不存在，那么使用查询这个不存对象的属性就会报错，null 和 undefined 都没有属性值，查询时均会报错。</p><p>利用 <code>&amp;&amp;</code> 运算符的短路行为，可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length</span><br></pre></td></tr></table></figure><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code> 运算符可以删除对象属性，但是只能删除自身属性，不能删除继承属性。（要删除继承属性，必须要定义这个属性的原型对象上删除它，但这回影响到所有继承这个原型的对象）。</p><p><code>delete</code> 不能删除可配置属性为 <code>false</code> 的属性。</p><h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><ul><li><code>in</code> 运算符，如果对象自有属性或继承属性中包含这个属性则返回 <code>true</code><br><code>javascript var o = {x: 1} &#39;x&#39; in o // true &#39;toString&#39; in o</code></li><li><code>hasOwnProperty()</code>， 用来检测给定的名字是否是对象自有的属性，继承属性将返回 <code>false</code><br><code>javascript o.hasOwnProperty(&#39;x&#39;) true o.hasOwnProperty(&#39;toString&#39;) false</code></li><li><p><code>propertyIsEnumerable()</code>，是 <code>hasOwnProperty()</code> 的增强版，检测自有属性并且该属性是可枚举的 - 通过代码增加的属性都是可枚举的，除非手动修改属性的可枚举性</p></li><li><p>使用 <code>!==</code> 判断 - 判断属性是否为 <code>undefined</code>，可用于自有属性和继承属性 - 当属性值位 <code>undefined</code> 时，则这种方法失效</p></li></ul><h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>对象序列化是指将对象的状态转换成字符串，使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 进行序列化和还原 <code>JavaScript对</code> 对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-基本数据类型-对象&quot;&gt;&lt;a href=&quot;#JavaScript-基本数据类型-对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 基本数据类型-对象&quot;&gt;&lt;/a&gt;JavaScript 基本数据类型-对象&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="对象" scheme="https://luoyec.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Object" scheme="https://luoyec.cn/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 原型及原型链</title>
    <link href="https://luoyec.cn/2018/04/14/cjitl6x36001e0f6pivd9gbvd/"/>
    <id>https://luoyec.cn/2018/04/14/cjitl6x36001e0f6pivd9gbvd/</id>
    <published>2018-04-14T08:15:53.601Z</published>
    <updated>2018-04-14T10:28:43.620Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="http://www.mollypages.org/tutorials/js.mp" target="_blank" rel="noopener">MollyPages.org</a><br><a href="http://www.cnblogs.com/liubaozhe/p/4618989.html" target="_blank" rel="noopener">javascript 原型链继承</a><br><a href="http://www.cnblogs.com/liushannet/archive/2011/09/28/2194905.html" target="_blank" rel="noopener">JavaScript：constructor 属性</a></p><h1 id="JavaScript-原型及原型链"><a href="#JavaScript-原型及原型链" class="headerlink" title="JavaScript 原型及原型链"></a>JavaScript 原型及原型链</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1523687434929.jpg" alt=""></p><h2 id="原型的基本概念"><a href="#原型的基本概念" class="headerlink" title="原型的基本概念"></a>原型的基本概念</h2><ul><li><p>所有的实例都<strong>继承</strong>自创建他们的构造函数的 <code>prototype</code> 对象</p></li><li><p>实例拥有一个特殊的实现 <code>__proto__</code>指针，它指向创建者的 <code>prototype</code> 对象</p></li><li><p>无论是否存在 <code>__proto__</code>，所有的函数都存在 <code>prototype</code> 对象，它拥有一个 <code>constructor</code> 属性指向函数自身，这个属性是只读的。</p></li><li><p><code>constructor</code> 属性始终指向创建当前对象的构造函数</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="keyword">new</span> <span class="built_in">Function</span>() &#123;<span class="keyword">this</span>.name = <span class="string">'name'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> M;</span><br><span class="line"></span><br><span class="line">M.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">m.constructor === M  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>所有对象的原型最终都会指向 <code>Object</code> 对象的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__); <span class="comment">//指向Foo构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__); <span class="comment">//指向Object构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__.__proto__); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h2><p><code>instanceof</code> 检测一个对象 A 是不是另一个对象 B 的实例的原理是：<code>查看对象B的prototype</code> 指向的对象是否在对象 A 的 <code>[[prototype]]</code> 链上。如果在，则返回 <code>true</code> ,如果不在则返回 <code>false</code>。不过有一个特殊的情况，当对象 <code>B</code> 的 <code>prototype</code> 为 null 将会报错(类似于空指针异常)。</p><h2 id="new-运算符的原理"><a href="#new-运算符的原理" class="headerlink" title="new 运算符的原理"></a>new 运算符的原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"M"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> M()</span><br></pre></td></tr></table></figure><ul><li>创建一个对象 <code>m</code>，它继承自 <code>M.prototype</code></li><li>构造函数 <code>M</code> 会被执行，执行的时候，可以传递参数。同时上下文 <code>this</code>，执行新创建的对象 <code>m</code></li><li>如果构造函数 <code>m</code> 返回了一个对象，那么 <code>new</code> 的结果将会是这个对象，而不是对象 <code>m</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://www.mollypages.org/tutorials/js.mp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MollyPages.org&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblo
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luoyec.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域通信原理及示例</title>
    <link href="https://luoyec.cn/2018/04/14/cjitl6x5q00720f6pbqjsaz7v/"/>
    <id>https://luoyec.cn/2018/04/14/cjitl6x5q00720f6pbqjsaz7v/</id>
    <published>2018-04-14T04:45:50.875Z</published>
    <updated>2018-04-14T04:46:15.411Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="http://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">前端跨域通信的几种方式</a></p><h1 id="前端跨域通信原理及示例"><a href="#前端跨域通信原理及示例" class="headerlink" title="前端跨域通信原理及示例"></a>前端跨域通信原理及示例</h1><h2 id="同源策略及限制"><a href="#同源策略及限制" class="headerlink" title="同源策略及限制"></a>同源策略及限制</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p>所谓同源是指：<strong>域名，协议，端口</strong> 相同。</p><p><code>cookie,localstorage，dom</code> 没办法相互获取 ，<code>ajax</code> 请求也不能</p><h2 id="前后端的通信方式"><a href="#前后端的通信方式" class="headerlink" title="前后端的通信方式"></a>前后端的通信方式</h2><ul><li><p><code>Ajax</code> - 通过在后台与服务器进行少量数据交换，<code>Ajax</code> 可以使网页实现异步更新 - 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 - 同源下使用的通信方式</p></li><li><p><code>WebSocket</code> - 不限制同源策略 - 基于 <code>TCP</code> 的一种新的网络协议 - 实现了浏览器与服务器全双工(<code>full-duplex</code>)通信——允许服务器主动发送信息给客户端。</p></li><li><p><code>CORS</code> - 支持跨域通信也支持同源通信 - <code>CORS</code> 机制让 <code>web</code> 服务器能跨站访问控制 - 简单请求 - 浏览器直接发送 <code>CORS</code> 跨域请求，并在 <code>header</code> 信息中增加一个 <code>Origin</code> 字段，表明这是一个跨域的请求。 - 非简单请求 - 在正式通信前进行一次 <code>Http</code> 查询请求，又称预检请求</p></li></ul><h2 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h2><ul><li><code>JSONP</code></li><li><code>HASH</code></li><li><code>postMessage</code></li><li><code>WebSocket</code></li><li><code>CORS</code></li></ul><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><strong>跨域原理</strong></p><p>利用 <code>&lt;script src=””&gt;&lt;/script&gt;</code> 中的 <code>src</code> 的地址可以跨域，动态的构造 <code>script</code> 标签，以实现跨域数据访问。</p><p>前端通过 <code>script</code> 标签以发送请求，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt src=&quot;http://www.abc.com/?data=name&amp;callback=callback_fn&quot; charset=&quot;utf-8&quot;&gt;&lt;/scirpt&gt;</span><br></pre></td></tr></table></figure><p>服务端返回的也是 <code>script</code> 标签，<code>callback</code> 就是方法名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback_fn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"callback_fn"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 <code>jsonp</code> 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function 获取一个随机的5位字符串]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; prefix [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;        [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.getName = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        prefix +</span><br><span class="line">        <span class="built_in">Math</span>.random()</span><br><span class="line">            .toString(<span class="number">36</span>)</span><br><span class="line">            .replace(<span class="regexp">/[^a-z]+/g</span>, <span class="string">""</span>)</span><br><span class="line">            .substr(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function 判断是否为函数]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; source [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;        [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.isFunction = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[object Function]"</span> === <span class="built_in">Object</span>.prototype.toString.call(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function jsonp]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; url      [请求地址]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; onsucess [成功的回调]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; onerror  [错误处理方法]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; charset  [字符集]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;          [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.jsonp = <span class="function"><span class="keyword">function</span>(<span class="params">url, onsuccess, onerror, charset</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> callbackName = util.getName(<span class="string">"tt_player"</span>)</span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">            onsuccess(<span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> script = util.createScript(url + <span class="string">"&amp;callback="</span> + callbackName, charset)</span><br><span class="line">    script.onload = script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!script.readyState || <span class="regexp">/loaded|complete/</span>.test(script.readyState)) &#123;</span><br><span class="line">            script.onload = script.onreadystatechange = <span class="literal">null</span></span><br><span class="line">            <span class="comment">// 移除该script的 DOM 对象</span></span><br><span class="line">            <span class="keyword">if</span> (script.parentNode) &#123;</span><br><span class="line">                script.parentNode.removeChild(script)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除函数或变量</span></span><br><span class="line">            <span class="built_in">window</span>[callbackName] = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">            onerror()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><code>url</code> 的 <code>#</code> 后面的内容就叫 <code>Hash</code>。<code>Hash</code> 的改变，页面不会刷新。这就是用 <code>Hash</code> 做跨域通信的基本原理。</p><p>补充：<code>url</code> 的 <code>?</code> 后面的内容叫 <code>Search</code>。<code>Search</code> 的改变，会导致页面刷新，因此不能做跨域通信。</p><p><strong>使用举例：</strong></p><p>场景：我的页面 <code>A</code> 通过 <code>iframe</code> 或 <code>frame</code> 嵌入了跨域的页面 <code>B</code>。</p><p>现在，我这个 <code>A</code> 页面想给 <code>B</code> 页面发消息，怎么操作呢？</p><p>（1）首先，在我的 <code>A</code> 页面中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"iframe"</span>)</span><br><span class="line">B.src = B.src + <span class="string">"#"</span> + <span class="string">"jsonString"</span> <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></table></figure><p>（2）然后，在 <code>B</code> 页面中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postMessage-方法"><a href="#postMessage-方法" class="headerlink" title="postMessage()方法"></a>postMessage()方法</h3><p><code>H5</code> 中新增的 <code>postMessage()</code> 方法，可以用来做跨域通信。既然是 <code>H5</code> 中新增的，那就一定要提到。</p><p>场景：窗口 <code>A (http:A.com)</code> 向跨域的窗口 <code>B (http:B.com)</code>发送信息。步骤如下。</p><p>（1）在 <code>A</code> 窗口中操作如下：向 B 窗口发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">"data"</span>, <span class="string">"http://B.com"</span>) <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>) <span class="comment">//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把请求发出去</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>)</span><br><span class="line">    ws.send(<span class="string">"Hello WebSockets!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对方发消息过来时，我接收</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received Message: "</span>, evt.data)</span><br><span class="line">    ws.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 <code>B</code> 窗口中操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(</span><br><span class="line">    <span class="string">"message"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.origin) <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.source) <span class="comment">//获取：A window对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.data) <span class="comment">//获取传过来的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><code>CORS</code> 可以理解成是既可以同步、也可以异步*的 <code>Ajax</code>。</p><p><code>fetch</code> 是一个比较新的 <code>API</code>，用来实现 <code>CORS</code> 通信。用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">"/some/url/"</span>, &#123;</span><br><span class="line">    method: <span class="string">"get"</span></span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>CORS</code> 为什么能实现跨域通信？浏览器会拦截 <code>Ajax</code>，<code>如果Ajax</code> 是跨域的，会在 <code>Http头部增加</code> <code>origin</code></p></blockquote><h3 id="CORS-和-JSONP-比较"><a href="#CORS-和-JSONP-比较" class="headerlink" title="CORS 和 JSONP 比较"></a><code>CORS</code> 和 <code>JSONP</code> 比较</h3><p><code>CORS</code> 和 <code>JSONP</code> 都是为了使 <code>web</code> 浏览器能够跨源请求，使用目的相同，但是比 <code>JSONP</code> 更强大。<code>JSONP</code> <code>只支持GET</code> 请求，而 <code>CORS</code> 支持所有类型的 <code>HTTP</code> 请求，<code>不过JSONP</code> 的优势在于支持老式浏览器以及可以向不支持 <code>CORS</code> 的网站跨源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8523576.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端跨域通信的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前端跨域通信原理及示例&quot;&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="https://luoyec.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="http" scheme="https://luoyec.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest请求</title>
    <link href="https://luoyec.cn/2018/04/13/cjitl6x4n004n0f6pgmpl5rfp/"/>
    <id>https://luoyec.cn/2018/04/13/cjitl6x4n004n0f6pgmpl5rfp/</id>
    <published>2018-04-13T15:38:53.944Z</published>
    <updated>2018-04-13T15:39:14.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XMLHttpRequest-请求"><a href="#XMLHttpRequest-请求" class="headerlink" title="XMLHttpRequest 请求"></a>XMLHttpRequest 请求</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [json 实现ajax的json]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; options [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;         [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">util.json = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> opt = &#123;</span><br><span class="line">        url: <span class="string">""</span>,</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    util.extend(opt, options)</span><br><span class="line">    <span class="keyword">if</span> (opt.url) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">        <span class="keyword">var</span> data = opt.data,</span><br><span class="line">            url = opt.url,</span><br><span class="line">            type = opt.type.toUpperCase(),</span><br><span class="line">            dataArr = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="comment">// 将ke-value的数据转成数组存放</span></span><br><span class="line">            dataArr.push(k + <span class="string">"="</span> + data[k])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">"GET"</span>) &#123;</span><br><span class="line">            url = url + <span class="string">"?"</span> + dataArr.join(<span class="string">"&amp;"</span>)</span><br><span class="line">            <span class="comment">// 删除以问号结尾的问号</span></span><br><span class="line">            xhr.open(type, url.replace(<span class="regexp">/\?$/g</span>, <span class="string">""</span>), <span class="literal">true</span>)</span><br><span class="line">            xhr.send()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">"POST"</span>) &#123;</span><br><span class="line">            xhr.open(type, url, <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 设置请求头部</span></span><br><span class="line">            xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">            xhr.send(dataArr.join(<span class="string">"&amp;"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 304 客户端可从缓存中获取数据，还可以增加 206 视频等媒体资源加载时用</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> res</span><br><span class="line">                <span class="keyword">if</span> (opt.success &amp;&amp; opt.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                    res = xhr.responseText</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">"string"</span>) &#123;</span><br><span class="line">                        res = <span class="built_in">JSON</span>.parse(res)</span><br><span class="line">                        opt.success.call(xhr, res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (opt.error &amp;&amp; opt.error <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                    opt.error.call(xhr, res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XMLHttpRequest-请求&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-请求&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest 请求&quot;&gt;&lt;/a&gt;XMLHttpRequest 请求&lt;/h1&gt;&lt;figure class
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="http" scheme="https://luoyec.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>React 服务端渲染理论</title>
    <link href="https://luoyec.cn/2018/04/05/cjitl6x4g00430f6pg4tnvoyd/"/>
    <id>https://luoyec.cn/2018/04/05/cjitl6x4g00430f6pg4tnvoyd/</id>
    <published>2018-04-05T07:09:31.232Z</published>
    <updated>2018-04-05T07:09:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>资源列表：<br><a href="https://github.com/wssgcg1213/koa2-react-isomorphic-boilerplate" target="_blank" rel="noopener">Git仓库: <code>koa2-react-isomorphic-boilerplate</code></a><br><a href="https://zhuanlan.zhihu.com/p/28322014" target="_blank" rel="noopener">Webpack工程化解决方案easywebpack</a><br><a href="https://zhuanlan.zhihu.com/p/30526168" target="_blank" rel="noopener">Egg + React + React Router ＋ Redux 服务端渲染实践</a><br><a href="https://zhuanlan.zhihu.com/p/30681341" target="_blank" rel="noopener">Egg + React 服务端渲染开发指南</a><br><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a><br><a href="http://www.alloyteam.com/2015/10/8783/" target="_blank" rel="noopener">React服务器端渲染实践小结</a></p><h1 id="React-服务端渲染理论"><a href="#React-服务端渲染理论" class="headerlink" title="React 服务端渲染理论"></a>React 服务端渲染理论</h1><p>相关的知识点：</p><ul><li>了解服务端渲染解决的问题</li><li>了解服务端渲染的基本原理</li><li>使用现有框架实现服务端渲染</li><li>进阶，dva+egg框架实现服务端渲染</li><li>进行性能测试</li></ul><h2 id="客户端渲染、服务端渲染、同构的区别"><a href="#客户端渲染、服务端渲染、同构的区别" class="headerlink" title="客户端渲染、服务端渲染、同构的区别"></a>客户端渲染、服务端渲染、同构的区别</h2><ul><li><p>客户端渲染：页面在 <code>JavaScript</code>，<code>CSS</code> 等资源文件加载完毕后开始渲染，路由为客户端路由，也就是我们经常谈到的 <code>SPA（Single Page Application）</code>。</p></li><li><p>服务端渲染：页面由服务端直接返回给浏览器，路由为服务端路由，<code>URL</code> 的变更会刷新页面，原理与 <code>ASP</code>，<code>PHP</code> 等传统后端框架类似。</p></li><li><p>同构：英文表述为 <code>Isomorphic</code> 或 <code>Universal</code>，即编写的 <code>JavaScript</code> 代码可同时运行在浏览器及 <code>Node.js</code> 两套环境中，用服务端渲染来提升首屏的加载速度，首屏之后的路由由客户端控制，即在用户到达首屏后，整个应用仍是一个 <code>SPA</code>。</p></li></ul><h2 id="总的架构"><a href="#总的架构" class="headerlink" title="总的架构"></a>总的架构</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522851689181.jpg" alt=""></p><ul><li>服务端预先获取编译好的客户端代码及其他资源。</li><li>服务端接收到用户的 <code>HTTP</code> 请求后，触发服务端的路由分发，将当前请求送至服务端渲染模块处理。</li><li>服务端渲染模块根据当前请求的 <code>URL</code> 初始化 <code>memory history</code> 及 <code>redux store</code>。</li><li>根据路由获取渲染当前页面所需要的异步请求（<code>thunk</code>）并获取数据。</li><li>调用 <code>renderToString</code> 方法渲染 <code>HTML</code> 内容并将初始化完毕的 <code>redux store</code> 塞入 <code>HTML</code> 中，供客户端渲染时使用。</li><li>客户端收到服务端返回的已渲染完毕的 <code>HTML</code> 内容并开始同步加载客户端 <code>JavaScript</code>，<code>CSS</code>，图片等其他资源。</li><li>之后的流程与客户端渲染完全相同，客户端初始化 <code>redux store</code>，路由找到当前页面的组件，触发组件的生命周期函数，再次获取数据。唯一不同的是 <code>redux store</code> 的初始状态将由服务端在 <code>HTML</code> 中塞入的数据提供，以保证客户端渲染时可以得到与服务端渲染相同的结果。受益于 <code>Virtual DOM</code> 的 <code>diff</code> 算法，这里并不会触发一次冗余的客户端渲染。</li></ul><h2 id="为什么要采用服务端渲染？"><a href="#为什么要采用服务端渲染？" class="headerlink" title="为什么要采用服务端渲染？"></a>为什么要采用服务端渲染？</h2><ul><li>利于 <code>SEO</code></li><li>加速首屏渲染速度</li><li>享受 <code>React</code> 组件式开发的优势：高复用、低耦合</li><li>前后端维护一套代码（代码同构）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;资源列表：&lt;br&gt;&lt;a href=&quot;https://github.com/wssgcg1213/koa2-react-isomorphic-boilerplate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git仓库: &lt;code&gt;koa2-react
      
    
    </summary>
    
      <category term="React" scheme="https://luoyec.cn/categories/React/"/>
    
    
      <category term="React" scheme="https://luoyec.cn/tags/React/"/>
    
      <category term="rss" scheme="https://luoyec.cn/tags/rss/"/>
    
      <category term="服务端渲染" scheme="https://luoyec.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 正则表达式</title>
    <link href="https://luoyec.cn/2018/03/31/cjitl6x3b001o0f6puv1h1y2a/"/>
    <id>https://luoyec.cn/2018/03/31/cjitl6x3b001o0f6puv1h1y2a/</id>
    <published>2018-03-31T03:02:24.965Z</published>
    <updated>2018-03-31T03:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="https://www.imooc.com/learn/706" target="_blank" rel="noopener">慕课网 JavaScript 正则表达式</a><br><a href="https://regexper.com" target="_blank" rel="noopener">正则表达式的可视化开源工具</a></p><h1 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h1><h2 id="REGEXP-对象"><a href="#REGEXP-对象" class="headerlink" title="REGEXP 对象"></a>REGEXP 对象</h2><p><code>JavaScript</code> 通过内置对象 <code>RegExp</code> 支持正则表达式，有两种方法实例化 <code>RegExp</code> 对象</p><ul><li>字面量</li><li>构造函数</li></ul><p>字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span></span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\bis\\b"</span>, <span class="string">"g"</span>)</span><br></pre></td></tr></table></figure><p>修饰符</p><blockquote><p><code>g</code>：<code>global</code> 全文搜索，不添加则搜索到第一个匹配停止<br><code>i</code>：<code>ignore case</code> 忽略大小写，默认大小写敏感<br><code>m</code>：<code>multiple lines</code> 多行搜索</p></blockquote><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式由两种基本字符类型组成</p><ul><li>原义文本字符如字母 <code>a</code>，表示的就是小写英文字母 <code>a</code></li><li>元字符元字符是在正则表达式中有特殊含义的非字母字符<br><code>* + ? $ ^ . | \ ( ) { } [ ]</code></li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522430983610.jpg" alt=""></p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul><li>一般情况下正则表达式一个字符对应字符串一个字符</li><li>表达式 <code>ab\t</code> 的含义就是 <img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432161908.jpg" alt=""></li></ul><p><strong>有时候需要匹配某一类字符</strong></p><ul><li>我们可以使用元字符 <code>[]</code> 来构建一个简单的类</li><li>所谓类是指符合某些特性的对象，一个泛指，而不是特质某个字符</li><li>表达式 <code>[abc]</code> 把字符 <code>a</code> 或 <code>b</code> 或 <code>c</code> 归为一类，表达式可以匹配这类的字符</li></ul><p><strong>字符类取反</strong></p><ul><li>使用元字符 <code>^</code> 创建 反向类/负向类</li><li>反向类的意思是不属于某类的内容</li><li>表达式 <code>[^abc]</code> 表示不是字符 <code>a</code> 或 <code>b</code> 或 <code>c</code> 的内容</li></ul><h2 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h2><ul><li>我们可以使用 [a-z] 来连接两个字符，表示从 <code>a</code> 到 <code>z</code> 的任意字符</li><li>这是个闭区间，也就是包含 <code>a</code> 和 <code>z</code> 本身</li><li>在 [] 组成的类内部是可以连写的 [a-zA-Z] <img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432684275.jpg" alt=""></li></ul><h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><p>正则表达式提供预定义类来匹配常见的字符类</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432833923.jpg" alt=""></p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>常用边界匹配字符</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522432964967.jpg" alt=""></p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>希望匹配一个连续出现 20 次数字的字符串</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522433319882.jpg" alt=""></p><h2 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h2><p>正则尽可能的匹配，例如匹配 3-6 个数字，<code>\d{3,6}</code>，在一串数字中，例如 12345678 ，匹配的结果为 123456</p><p><strong>非贪婪模式</strong><br>让正则尽可能少的匹配，也就是说一旦匹配成功不再继续尝试就是非贪婪模式，直接在量词后加上 ？ 即可，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123253253455"</span>.match(<span class="regexp">/\d&#123;3,6&#125;?/g</span>)</span><br><span class="line"><span class="comment">// ["123", "253", "253", "455"]</span></span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用 <code>( )</code> 可以达到分组的功能，使量词作用域分组，例如</p><p><code>(lyctea){3}</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456387142.jpg" alt=""></p><p>或用 | 表示或，例如</p><p><code>lyctea|luoyecong</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456487629.jpg" alt=""></p><p><code>luoye(c|cong)</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522456550113.jpg" alt=""></p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>例如将用 - 连接的日期，转成 / 表示的日期格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"2017-03-30"</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">"$2/$3/$1"</span>)</span><br><span class="line"><span class="comment">// "03/30/2017"</span></span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522457145865.jpg" alt=""></p><p><strong>忽略分组</strong><br>不希望捕获某些分组，只需要在分组内加上 ? : 就可以</p><p><code>(?:Byron).(ok)</code></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522457301448.jpg" alt=""></p><h2 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h2><ul><li>正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“前”</li><li>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言；后顾/后瞻方向相反</li><li><code>JavaScript</code> 不支持后顾</li><li>符合和不符合特定断言成为 <strong>肯定/正向</strong> 匹配和 <strong>否定/负向</strong> 匹配</li></ul><p><strong>语法（规则+断言）</strong></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522460847546.jpg" alt=""></p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配前面是单词或数字，后面是数字</span></span><br><span class="line"><span class="string">"x3*33vV"</span>.replace(<span class="regexp">/\w(?=\d)/g</span>, <span class="string">'_'</span>)；</span><br><span class="line"><span class="comment">// "_3*_3vV"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配前面是单词或数字，后面不是数字</span></span><br><span class="line"><span class="string">"x3*33vV"</span>.replace(<span class="regexp">/\w(?!\d)/g</span>, <span class="string">'_'</span>)；</span><br><span class="line"><span class="string">"x_*3___"</span></span><br></pre></td></tr></table></figure><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462277518.jpg" alt=""></p><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462262993.jpg" alt=""></p><h2 id="JS-对象属性"><a href="#JS-对象属性" class="headerlink" title="JS 对象属性"></a>JS 对象属性</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/luoyec/1522462629556.jpg" alt=""></p><h2 id="test-和-exec-方法"><a href="#test-和-exec-方法" class="headerlink" title="test 和 exec 方法"></a>test 和 exec 方法</h2><p><strong><code>RegExp.prototype.test()</code></strong></p><blockquote><p><code>test()</code> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p></blockquote><p><code>lastIndex</code>：当前匹配结果的最后一个字符的下一个字符（使用 <code>test()</code> 会分段匹配，可能会执行多次，当全文匹配完毕时，会从头匹配）</p><p><strong><code>RegExp.prototype.exec()</code></strong><br><code>exec()</code> 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <code>null</code>。</p><p>如果你只是为了判断是否匹配（<code>true</code>或 <code>false</code>），可以使用 <code>RegExp.test()</code> 方法，或者 <code>String.search()</code> 方法。</p><h2 id="字符串方法中的正则"><a href="#字符串方法中的正则" class="headerlink" title="字符串方法中的正则"></a>字符串方法中的正则</h2><p><strong>String.prototype.search()</strong><br><code>search()</code> 方法执行正则表达式和 <code>String</code> 对象之间的一个搜索匹配。</p><p><strong>String.prototype.match()</strong><br>当一个字符串与一个正则表达式匹配时， <code>match()</code> 方法检索匹配项。</p><p><strong>String.prototype.replace()</strong><br><code>replace()</code> 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。</p><blockquote><p>⚠️ 注意：原字符串不会改变。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;https://www.imooc.com/learn/706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网 JavaScript 正则表达式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://regexper.c
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="RegExp" scheme="https://luoyec.cn/tags/RegExp/"/>
    
      <category term="正则" scheme="https://luoyec.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>浏览器存储、HTTP缓存、SSR</title>
    <link href="https://luoyec.cn/2018/03/24/cjitl6x62007t0f6puz9191xb/"/>
    <id>https://luoyec.cn/2018/03/24/cjitl6x62007t0f6puz9191xb/</id>
    <published>2018-03-24T14:32:19.000Z</published>
    <updated>2018-03-24T14:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资源：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存 MDN</a><br><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a></p><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521824473690.jpg" alt=""></p><p><code>HTTP</code> 请求是无状态的，一次连接关闭，使用 <code>Cookie</code>去维持客户端状态，维护用户的登录信息。服务端可以判断这个请求是来自哪个客户端。</p><p>总结两点功能：</p><ul><li>用于浏览器端和服务器端的交互</li><li>客户端自身数据的存储</li></ul><p><code>Cookie</code> 存储的限制：</p><ul><li>作为浏览器存储，大小 4kb 左右（<code>存储数据能力被localstorage</code> 替代）</li><li>需要设置过期时间 <code>expire</code></li><li><code>httponly</code>：当前这个 <code>Cookie</code> 只能用户 <code>http</code> 传输，而不能用 <code>js</code> 进行读写</li><li><code>Cookie</code>中在相关域名下面 – <code>CND</code> 的流量损耗 - 在同一个域名下的所有请求，都会携带请求<ul><li><code>CDN</code> 的域名和主站的域名要分开</li></ul></li></ul><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><ul><li><code>HTML5</code> 设计专门用来浏览器存储的</li><li>大小为 5MB 左右</li><li>尽在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>浏览器本地缓存方案</li></ul><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><ul><li>会话级别的浏览器存储</li><li>大小为 <code>5MB</code> 左右</li><li>尽在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>对于表单信息的维护</li></ul><h2 id="IndexDB"><a href="#IndexDB" class="headerlink" title="IndexDB"></a>IndexDB</h2><p><code>IndexDB</code> 是一种低级 <code>API</code>，用于客户端存储大量结构化数据。该 <code>API</code> 使用索引来实现对该数据的高性能搜索。虽然 <code>Web Storage</code> 对于储存较少的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexDB</code> 提供了解决方案。</p><p>为应用创建离线版本。</p><h2 id="Service-Workers-产生的意义"><a href="#Service-Workers-产生的意义" class="headerlink" title="Service Workers 产生的意义"></a>Service Workers 产生的意义</h2><blockquote><p><code>Service workers</code><br>本质上充当 <code>Web</code> 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。</p></blockquote><p><code>Service workers</code>是一个脚本。浏览器独立与当前网页，将其在后台运行，为实现一些不依 赖页面或者用户交互的特性打开了一扇大门，在未来这些特性将包括推送消息，背景后台同步，<code>geofencing</code>（地理围栏定位），但他将退出的第一个首要特性，就是拦截和处理网络请求的能力，包括变成方式来管理被缓存的响应。</p><p>使用拦截网络请求的能力，可以实现离线应用。</p><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p><code>PWA（Progressive Web APPs）</code> 是一种 <code>Web App</code> 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写就能看出来，这事一个<strong>渐进式</strong>的 <code>WebApp</code> ，是通过一系列新的 <code>Web</code> 特性。配合优秀的 <code>UI</code> 交互设计，逐步的增强 <code>Web APP</code> 的用户体验。</p><ul><li>可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现 “未连接到互联网”的页面。</li><li>快速：针对网页渲染及网路数据访问有较好的优化。</li><li>融入（<code>Engaging</code>）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。</li></ul><blockquote><p>⚠️ <code>lighthouse</code>：<code>chorm</code> 扩展插件，检查网站性能，SEO 等</p></blockquote><h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><blockquote><p>重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。</p></blockquote><h1 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server Side Rendering"></a>Server Side Rendering</h1><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521898842131.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资源：&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 缓存 MDN&lt;/a&gt;&lt;br&gt;&lt;a hre
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="离线存储" scheme="https://luoyec.cn/tags/%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>懒加载与预加载，重绘与回流</title>
    <link href="https://luoyec.cn/2018/03/24/cjitl6x5u007b0f6pdbv7lim0/"/>
    <id>https://luoyec.cn/2018/03/24/cjitl6x5u007b0f6pdbv7lim0/</id>
    <published>2018-03-23T16:40:34.000Z</published>
    <updated>2018-03-23T16:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="懒加载与预加载"><a href="#懒加载与预加载" class="headerlink" title="懒加载与预加载"></a>懒加载与预加载</h1><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul><li>图片进入可视区域之后请求图片资源 - 进入可视区域之后修改 src 属性</li><li><code>UI</code> 与电商等图片资源很多，页面很长的业务场景使用</li><li>减少无效资源的加载</li><li>并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用</li></ul><p>实现方式：需要去监听 <code>scroll</code> 事件，在 <code>scrool</code> 滚动事件的回调中</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521813324228.jpg" alt=""></p><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ul><li>图片等静态资源在使用之前的提前请求</li><li>资源使用时能从缓存中加载，提升用户体验</li><li>页面展示的依赖关系维护</li></ul><p>实现方式：</p><ul><li>使用 <code>XMLHttpRequest</code> 对象</li><li>使用 <code>Image</code> 对象</li><li>使用 <code>preload.js</code> 库</li></ul><h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><ul><li>理解浏览器重绘与回流的机制</li><li>对于一些经典的案例进行分析</li><li>重绘与回流的案例实战</li></ul><p><strong>css 性能会让 JavaScript 变慢？</strong><br>在加载 <code>css</code> 的时候，<code>js</code> 的执行被阻塞，在 <code>js</code> 中执行的时候，页面的渲染也是被阻塞的。</p><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521815434613.jpg" alt=""></p><p>频繁触发重绘与回流，会导致 <code>UI</code> 频繁渲染，最终导致 <code>js</code> 执行效率。</p><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><ul><li><p>当 <code>render tree</code> 中的一部分（或全部）因为元素的规模尺寸，<strong>布局</strong>，隐藏改变而需要重新构建，这就成为回流（<code>reflow</code>）</p></li><li><p>当页面布局和几何属性改变时就需要回流</p></li></ul><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当 <code>render tree</code> 的一些元素需要更新属性，二者属性只是影响元素的外观，风格，而不会影响<strong>布局</strong>的，比如 <code>background-color</code> 。则成为重绘。</p><p><strong>综上，回流一定会触发重绘，重绘不一定会触发回流。</strong></p><h3 id="触发页面重新布局的属性"><a href="#触发页面重新布局的属性" class="headerlink" title="触发页面重新布局的属性"></a>触发页面重新布局的属性</h3><ul><li>盒子模型相关属性会触</li><li>定位属性及浮动也会触发</li><li>改变节点内部文字结构</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521816177011.jpg" alt=""></p><p>将频发重绘回流的 <code>DOM</code> 元素单独作为一个独立图层，那么这个 <code>DOM</code> 元素的重绘和回流的影响只会在这个图层中。</p><p><code>Chrome</code> 创建图层的条件：</p><ul><li>3D 或透视变换 <code>CSS</code> 属性（<code>perspective transform</code>）</li><li>使用加速视频解码的 <code>video</code> 节点</li><li>拥有 3D （<code>WebGL</code>） 上下文或加速的 2D 上下文的 <code>canvas</code> 节点</li><li>混合插件（如 <code>Flash</code>）</li><li>对自己的 <code>opacity</code> 做 <code>CSS</code> 动画或使用一个动画 <code>webkit</code> 变换的元素</li><li>拥有加速 <code>CSS</code> 过滤器的元素</li><li>元素有一个包含复合层的后代节点</li><li>元素由一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素</li></ul><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li>避免使用触发重绘、回流的 CSS 属性</li><li>将重绘、 回流的影响返回限制在单独的图层之内</li></ul><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521821670261.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;懒加载与预加载&quot;&gt;&lt;a href=&quot;#懒加载与预加载&quot; class=&quot;headerlink&quot; title=&quot;懒加载与预加载&quot;&gt;&lt;/a&gt;懒加载与预加载&lt;/h1&gt;&lt;h2 id=&quot;懒加载&quot;&gt;&lt;a href=&quot;#懒加载&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="懒加载，预加载" scheme="https://luoyec.cn/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>资源合并与压缩</title>
    <link href="https://luoyec.cn/2018/03/23/cjitl6x6g008q0f6pl0tbszm7/"/>
    <id>https://luoyec.cn/2018/03/23/cjitl6x6g008q0f6pl0tbszm7/</id>
    <published>2018-03-23T05:31:52.000Z</published>
    <updated>2018-03-23T05:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br>[什么是 CDN–阿里云][1]</p><ul><li>理解减少 <code>HTTP</code> 请求数量和减少请求资源大小的两个优化点</li><li>掌握压缩与合并的原理</li><li>掌握通过在线网站和 <code>fis3</code> 两种实现压缩的与合并的方法</li></ul><h2 id="HTTP-请求过程及潜在的性能优化点"><a href="#HTTP-请求过程及潜在的性能优化点" class="headerlink" title="HTTP 请求过程及潜在的性能优化点"></a>HTTP 请求过程及潜在的性能优化点</h2><p>❓ 浏览器的一个请求从发送到返回都经历了什么？</p><p>❓ <code>DNS</code> 是否可用通过魂村减少 <code>DNS</code> 查询时间</p><p>❓ 网络请求的过程走最近的网络环境？</p><p>❓ 相同的静态资源是否可用缓存</p><p>❓ 是否减少请求 <code>HTTP</code> 请求大小？</p><p>❓ 减少 <code>HTTP</code> 请求</p><p>❓ 服务端渲染</p><h2 id="Google-首页案例学习"><a href="#Google-首页案例学习" class="headerlink" title="Google 首页案例学习"></a>Google 首页案例学习</h2><ul><li><code>HTML</code> 压缩</li><li><code>CSS</code> 压缩</li><li><code>JS</code> 的压缩和混淆</li><li>文件合并</li><li>开启 <code>gzip</code></li></ul><h3 id="HTML-压缩"><a href="#HTML-压缩" class="headerlink" title="HTML 压缩"></a>HTML 压缩</h3><p><code>HTML</code> 代码压缩就是压缩这些在文本文件中有意义，但是在 <code>HTML</code> 中不显示的字符，包括空格、制表符、换行符等，还有一些其他有意义的字符，如 <code>HTML</code> 注释也可以压缩。</p><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>后端模板引擎渲染压缩</li></ul><h3 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h3><ul><li>无效代码删除</li><li>css 语义合并</li></ul><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>使用 <code>clean-css</code></li></ul><h3 id="JS-的压缩和混淆"><a href="#JS-的压缩和混淆" class="headerlink" title="JS 的压缩和混淆"></a>JS 的压缩和混淆</h3><ul><li>无效字符的删除</li><li>剔除注释</li><li>代码语义的缩减和优化</li><li>代码保护</li></ul><p>压缩的方法：</p><ul><li>使用在线网站进行压缩</li><li><code>nodejs</code> 提供了 <code>html-minifier</code> 工具</li><li>使用 <code>uglifyjs2</code></li></ul><h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><p>![][2]</p><p>文件合并的弊端：</p><ul><li>首屏渲染问题</li><li>缓存失效问题 - 增加 <code>MD5</code> 戳，用来标识文件是否更改 - 采用文件合并会存在大面积缓存失效</li></ul><p>文件合并的策略：</p><ul><li>公共库合并</li><li>不同页面的合并 - 单页应用被路由到的时候才去请求 <code>JS</code></li><li>见机行事，随机应变</li></ul><p>合并的方法：</p><ul><li>使用在线网站进行合并</li><li><p>使用 <code>nodejs</code> 实现文件合并</p><p>[1]: <a href="https://help.aliyun.com/document_detail/27101.html?spm=a2c4g.11174283.2.3.85hgy4" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/27101.html?spm=a2c4g.11174283.2.3.85hgy4</a><br>[2]: <a href="http://oudfgqwcq.bkt.clouddn.com/lyctea/1521771263712.jpg" target="_blank" rel="noopener">http://oudfgqwcq.bkt.clouddn.com/lyctea/1521771263712.jpg</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;[什么是 CDN–阿里云][1]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解减少 &lt;code&gt;HTTP&lt;/code&gt; 请求数量和减少请求资源大小的两个优化点&lt;/li&gt;
&lt;li&gt;掌握压缩与合并的原理&lt;/li&gt;
&lt;li&gt;掌握通过在线网站和 &lt;code&gt;fis3&lt;/code
      
    
    </summary>
    
      <category term="前端性能优化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://luoyec.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="文件压缩" scheme="https://luoyec.cn/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 迭代器与生成器</title>
    <link href="https://luoyec.cn/2018/03/21/cjitl6x3f00200f6p3shul4zn/"/>
    <id>https://luoyec.cn/2018/03/21/cjitl6x3f00200f6p3shul4zn/</id>
    <published>2018-03-21T08:58:44.000Z</published>
    <updated>2018-03-21T08:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-迭代器与生成器"><a href="#JavaScript-迭代器与生成器" class="headerlink" title="JavaScript 迭代器与生成器"></a>JavaScript 迭代器与生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>迭代器是一种检查容器内元素并遍历元素的数据类型。</strong></p><blockquote><p>迭代器（<code>iterator</code>）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p></blockquote><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>生成器( <code>generator</code> )是能返回一个迭代器的函数。</strong> 生成器函数由放在 function 关键字之 后的一个星号( * )来表示，并能使用新的 yield 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 在循环内遇到yield就会停止，指定再次调用next方法，将会在上次停止的位置继续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// 之后的所有调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>关于生成器的几点注意事项：</p><ul><li><p>使用函数表达式来创建一个生成器，只要在 <code>function</code> 关键字与圆括号之间使用一个星号( * )</p></li><li><p>由于生成器就是函数，因此也可以被添加到对象中，下列两种方法是等价的。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span>*(<span class="params">items</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    *createIterator(items) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>不能将箭头函数创建为生成器</li></ul><h2 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h2><p>与迭代器紧密相关的是，可迭代对象( <code>iterable</code> )是包含 <code>Symbol.iterator</code> 属性的对象。这 个 <code>Symbol.iterator</code> 知名符号定义了为指定对象返回迭代器的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;&#125;, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h2><p>你可以使用 Symbol.iterator 来访问对象上的默认迭代器，就像这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>检查一个对象是否能够进行迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-迭代器与生成器&quot;&gt;&lt;a href=&quot;#JavaScript-迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 迭代器与生成器&quot;&gt;&lt;/a&gt;JavaScript 迭代器与生成器&lt;/h1&gt;&lt;h2 id=&quot;迭
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="迭代器" scheme="https://luoyec.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
      <category term="生成器" scheme="https://luoyec.cn/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 递归上</title>
    <link href="https://luoyec.cn/2018/03/08/cjitl6x3i00260f6p6l7jj31j/"/>
    <id>https://luoyec.cn/2018/03/08/cjitl6x3i00260f6p6l7jj31j/</id>
    <published>2018-03-08T01:01:16.000Z</published>
    <updated>2018-03-08T01:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://juejin.im/post/59c1d91d6fb9a00a53275f79" target="_blank" rel="noopener">翻译连载 | 第 9 章：递归（上）－《JavaScript轻量级函数式编程》 |《你不知道的JS》姊妹篇</a></p><h1 id="JavaScript-递归上"><a href="#JavaScript-递归上" class="headerlink" title="JavaScript 递归上"></a>JavaScript 递归上</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓递归，是当一个函数调用自身，并且该调用做了同样的事情，这个循环持续到基本条件满足时，调用循环返回。</p><blockquote><p>⚠️  <code>警告： 如果你不能确保基本条件是递归的 终结者，递归将会一直执行下去，并且会把你的项目损坏或锁死；恰当的基本条件十分重要！</code></p></blockquote><h2 id="直接递归"><a href="#直接递归" class="headerlink" title="直接递归"></a>直接递归</h2><blockquote><p>当一个函数调用自身时，很明显，这叫作直接递归</p></blockquote><h3 id="简单的函数递归"><a href="#简单的函数递归" class="headerlink" title="简单的函数递归"></a>简单的函数递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> foo(x / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><h3 id="求质数"><a href="#求质数" class="headerlink" title="求质数"></a>求质数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 判断一个数是否是质数：</span></span><br><span class="line"><span class="comment"> * 从2到 num 的平方根之间的每个整数，看是否存在某一整数可以整除 num (% 求余结果为 0)。</span></span><br><span class="line"><span class="comment"> * 如果存在这样的整数，那么 num 不是质数。反之，是质数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125;  num  被判断是否是质数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; divisor </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num, divisor = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出口，非质数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span> || (num &gt; <span class="number">2</span> &amp;&amp; num % divisor == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口，递归的条件</span></span><br><span class="line">    <span class="keyword">if</span> (divisor &lt;= <span class="built_in">Math</span>.sqrt(num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> isPrime(num, divisor + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出口，质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPrime(<span class="number">40</span>));</span><br></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fib</span><span class="params">( <span class="number">0</span> )</span></span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">( <span class="number">1</span> )</span></span>: <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">( n )</span></span>:</span><br><span class="line">    fib( n - <span class="number">2</span> ) + fib( n - <span class="number">1</span> )</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出口，当n小于等于1时，结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足，出口条件 ，持续递归</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">2</span>) + fib(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相互递归"><a href="#相互递归" class="headerlink" title="相互递归"></a>相互递归</h2><blockquote><p>如果在一个递归循环中，出现两个及以上的函数相互调用，则称之为相互递归。</p></blockquote><h3 id="求奇数偶数"><a href="#求奇数偶数" class="headerlink" title="求奇数偶数"></a>求奇数偶数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isEven(<span class="built_in">Math</span>.abs(v) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isOdd(<span class="built_in">Math</span>.abs(v) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">31</span>));</span><br></pre></td></tr></table></figure><h3 id="简单迭代改为递归"><a href="#简单迭代改为递归" class="headerlink" title="简单迭代改为递归"></a>简单迭代改为递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环求和</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; total 求和</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; nums 参数数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">total, ...nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        total = total + nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求和</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; total 求和</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; nums 参数数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_sum</span>(<span class="params">num1, ...nums</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 每次取到传入的第一个参数，参数列表数量每次少一个</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">return</span> num1 + _sum(...nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_sum(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="找出入参最大偶数值"><a href="#找出入参最大偶数值" class="headerlink" title="找出入参最大偶数值"></a>找出入参最大偶数值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出入参最大偶数值</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; nums </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxEven</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; num) &#123;</span><br><span class="line">            num = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num !== -<span class="literal">Infinity</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 递归法，找出入参最大偶数值</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; num1 </span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; restNums </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_maxEven</span>(<span class="params">num1, ...restNums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxRest = restNums.length &gt; <span class="number">0</span> ? _maxEven(...restNums) : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> (num1 % <span class="number">2</span> != <span class="number">0</span> || num1 &lt; maxRest) ? maxRest : num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_maxEven(<span class="number">9878</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">98</span>, <span class="number">65</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/59c1d91d6fb9a00a53275f79&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻译连载 | 第 9 章：递归（上）－《JavaScript轻量级函数式编程》
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://luoyec.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luoyec.cn/tags/JavaScript/"/>
    
      <category term="递归" scheme="https://luoyec.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins安装及基础配置</title>
    <link href="https://luoyec.cn/2018/03/07/cjitl6x41003b0f6pgwe16o78/"/>
    <id>https://luoyec.cn/2018/03/07/cjitl6x41003b0f6pgwe16o78/</id>
    <published>2018-03-07T01:55:41.000Z</published>
    <updated>2018-03-07T01:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p><a href="http://linux.it.net.cn/CentOS/course/2016/0502/21250.html" target="_blank" rel="noopener">CentOS 上安装 Jenkins</a><br><a href="https://pkg.jenkins.io/redhat/" target="_blank" rel="noopener">RedHat Linux RPM packages for Jenkins</a><br><a href="https://segmentfault.com/a/1190000004639923" target="_blank" rel="noopener">Jenkins+Node.js持续集成</a><br><a href="https://medium.com/risingstack-blog/getting-started-with-jenkins-and-node-f859934d0249" target="_blank" rel="noopener">Getting started with Jenkins and Node</a><br><a href="https://segmentfault.com/a/1190000002729796" target="_blank" rel="noopener">CentOS 7 安装 Gitlab</a><br><a href="http://www.cnblogs.com/dzblog/p/6930147.html" target="_blank" rel="noopener">Jenkins、Git ssh原理以及与https的区别</a><br><a href="https://segmentfault.com/a/1190000010154974" target="_blank" rel="noopener">Jenkins打包node项目步骤</a><br><a href="https://wiki.jenkins.io/display/JENKINS/NodeJS+Plugin" target="_blank" rel="noopener">NodeJS Plugin官方文档</a><br><a href="http://www.cnblogs.com/zipon/p/6206063.html" target="_blank" rel="noopener">jenkins publish over ssh使用</a></p><h1 id="Jenkins安装及基础配置"><a href="#Jenkins安装及基础配置" class="headerlink" title="Jenkins安装及基础配置"></a>Jenkins安装及基础配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Java-环境安装"><a href="#Java-环境安装" class="headerlink" title="Java 环境安装"></a>Java 环境安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure><h3 id="Jenkins-安装"><a href="#Jenkins-安装" class="headerlink" title="Jenkins 安装"></a>Jenkins 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo</span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key</span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><h4 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h4><p><code>jenkins</code> 安装目录，<code>WAR</code> 包会放在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jenkins</span><br></pre></td></tr></table></figure><p><code>jenkins</code> 配置文件，端口、<code>JENKINS_HOME</code> 等都可以在这里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><p>默认的 <code>JENKINS_HOME</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/jenkins/</span><br></pre></td></tr></table></figure><p><code>Jenkins</code> 日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/jenkins/jenkins.log</span><br></pre></td></tr></table></figure></p><h4 id="启动Jenkins"><a href="#启动Jenkins" class="headerlink" title="启动Jenkins"></a>启动Jenkins</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br><span class="line"></span><br><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure><h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518146884703.jpg" alt=""></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><img src="http://oudfgqwcq.bkt.clouddn.com/lyctea/1518161368952.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://linux.it.net.cn/CentOS/course/2016/0502/21250.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 上安装 Jenkins&lt;/a&gt;&lt;br
      
    
    </summary>
    
      <category term="前端工程化" scheme="https://luoyec.cn/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Jenkins" scheme="https://luoyec.cn/tags/Jenkins/"/>
    
      <category term="ECS" scheme="https://luoyec.cn/tags/ECS/"/>
    
  </entry>
  
</feed>

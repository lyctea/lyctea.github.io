[{"title":"把一个 Node.js web 应用程序给 Docker 化","date":"2019-01-09T09:09:48.235Z","path":"2019/01/09/cjqoyqt11006qhl6pgpn2h9jj/","text":"原文：把一个 Node.js web 应用程序给 Docker 化 把一个 Node.js web 应用程序给 Docker 化本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 非 产品发布人员。此教程同样假定你有一个可以正常工作的 Docker 安装，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。 在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。 Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。 创建 Node.js 应用首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 package.json 文件，描述你应用程序以及需要的依赖： 12345678910111213&#123; \"name\": \"docker_web_app\", \"version\": \"1.0.0\", \"description\": \"Node.js on Docker\", \"author\": \"First Last &lt;first.last@example.com&gt;\", \"main\": \"server.js\", \"scripts\": &#123; \"start\": \"node server.js\" &#125;, \"dependencies\": &#123; \"express\": \"^4.16.1\" &#125;&#125; 配合着你的 package.json 请运行 npm install。如果你使用的 npm 是版本 5 或者之后的版本，这会自动生成一个 package-lock.json 文件，它将一起被拷贝进入你的 Docker 镜像中。 然后，创建一个 server.js 文件，使用 Express.js 框架定义一个 Web 应用： 12345678910111213141516'use strict';const express = require('express');// Constantsconst PORT = 8080;const HOST = '0.0.0.0';// Appconst app = express();app.get('/', (req, res) =&gt; &#123; res.send('Hello world\\n');&#125;);app.listen(PORT, HOST);console.log(`Running on http://$&#123;HOST&#125;:$&#123;PORT&#125;`); 在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。 创建一个名称为 Dockerfile 的文件创建一个空文件，命名为 Dockerfile： 1touch Dockerfile 用你最喜欢的文本编辑器打开这个 Dockerfile。 我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），Node 的版本号为 8。你可以从 Docker 站点 获取相关镜像： 1FROM node:8 下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录： 12# Create app directoryWORKDIR /usr/src/app 此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 npm 安装你的应用程序的所有依赖。请注意，如果你的 npm 的版本是 4 或者更早的版本，package-lock.json 文件将不会自动生成。 12345678# Install app dependencies# A wildcard is used to ensure both package.json AND package-lock.json are copied# where available (npm@5+)COPY package*.json ./RUN npm install# If you are building your code for production# RUN npm install --only=production 请注意，我们只是拷贝了 package.json 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 见此。 在 Docker 镜像中使用 COPY 命令绑定你的应用程序： 12# Bundle app sourceCOPY . . 你的应用程序绑定的端口为 8080，所以你可以使用 EXPOSE 命令使它与 docker 的镜像做映射： 1EXPOSE 8080 最后但同样重要的事是，使用定义运行时的 CMD 定义命令来运行应用程序。这里我们使用最简单的 npm start 命令，它将运行 node server.js 启动你的服务器： 1CMD [ \"npm\", \"start\" ] 你的 Dockerfile 现在看上去是这个样子： 12345678910111213141516171819FROM node:8# Create app directoryWORKDIR /usr/src/app# Install app dependencies# A wildcard is used to ensure both package.json AND package-lock.json are copied# where available (npm@5+)COPY package*.json ./RUN npm install# If you are building your code for production# RUN npm install --only=production# Bundle app sourceCOPY . .EXPOSE 8080CMD [ \"npm\", \"start\" ] .dockerignore 文件在 Dockerfile 的同一个文件夹中创建一个 .dockerignore 文件，带有以下内容： 12node_modulesnpm-debug.log 这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。 构建你的镜像进入到 Dockerfile 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 -t 让你标记你的镜像，以至于让你以后很容易地用 docker images 找到它。 1$ docker build -t &lt;your username&gt;/node-web-app . Docker 现在将给出你的镜像列表： 123456$ docker images# ExampleREPOSITORY TAG ID CREATEDnode 8 1934b0b038d1 5 days ago&lt;your username&gt;/node-web-app latest d64d3505b0d2 1 minute ago 运行镜像使用 -d 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 -p 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像： 1$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app 把你应用程序的输出打印出来： 12345678# Get container ID$ docker ps# Print app output$ docker logs &lt;container id&gt;# ExampleRunning on http://localhost:8080 如果你需要进入容器中，请运行 exec 命令： 12# Enter the container$ docker exec -it &lt;container id&gt; /bin/bash 测试为测试你的应用程序，给出与 Docker 映射过的端口号： 12345$ docker ps# ExampleID IMAGE COMMAND ... PORTSecce33b30ebf &lt;your username&gt;/node-web-app:latest npm start ... 49160-&gt;8080 在上面的例子中，在容器中 Docker 把端口号 8080 映射到你机器上的 49160 。 现在你可以使用 curl（如果需要的话请通过 sudo apt-get install curl 安装）调用你的程序了： 1234567891011$ curl -i localhost:49160HTTP/1.1 200 OKX-Powered-By: ExpressContent-Type: text/html; charset=utf-8Content-Length: 12ETag: W/\"c-M6tWOb/Y57lesdjQuHeB1P/qTV0\"Date: Mon, 13 Nov 2017 20:53:59 GMTConnection: keep-aliveHello world 我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。 你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容： 官方 Node.js 的 Docker 镜像 Node.js 基于 Docker 使用的最佳经验 官方 Docker 文档 在 StackOverFlow 上有关 Docker 标记内容 Docker Subreddit","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"node","slug":"node","permalink":"https://luoyec.cn/tags/node/"},{"name":"docker","slug":"docker","permalink":"https://luoyec.cn/tags/docker/"}]},{"title":"使用 StoryBook 搭建 UI 组件库","date":"2018-10-26T08:49:20.998Z","path":"2018/10/26/cjqoyqt0p005whl6pnkgl0rpi/","text":"storybook文档Storybook 3.2 引入 Vue.js 支持一个完整的Vue例子 使用 StoryBook 搭建 UI 组件库StoryBook 为UI组件开发提供开发环境，你可有实现不同状态下的UI可视化，并且可以实现交互。 实现 Vue UI 组件库初始化项目vue init webpack my-vue-project. // 通过 vue cli 初始化项目 cd my-vue-project npm i -g @storybook/cli // 全局安装 storybook getstorybook // 生成 npm run storybook //运行 Writing Stories我们在 src/component 文件夹下添加简单的按钮组件： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;button class=\"button-styles\" @click=\"onClick\"&gt; &lt;slot&gt;Fallback Content&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'my-button', methods: &#123; onClick () &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .button-styles &#123; border: 1px solid #eee; border-radiuas: 3px; background-color: #FFFFFF; cursor: pointer; font-size: 15pt; padding: 3px 10px; margin: 10px; &#125;&lt;/style&gt; 然后在 src/stories 目录下，可以利用 Storybook 提供的接口注册 Story: 12345678910111213141516171819/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */import &#123; storiesOf &#125; from '@storybook/vue';import &#123; action &#125; from '@storybook/addon-actions';import &#123; linkTo &#125; from '@storybook/addon-links';import MyButton from '../component/MyButton.vue';storiesOf('Button', module) .add('with text', () =&gt; (&#123; components: &#123; MyButton &#125;, template: '&lt;my-button @click=\"action\"&gt;Hello Button&lt;/my-button&gt;', methods: &#123; action: action('clicked') &#125;, &#125;)) .add('with some emoji', () =&gt; (&#123; components: &#123; MyButton &#125;, template: '&lt;my-button @click=\"action\"&gt;😀 😎 👍 💯&lt;/my-button&gt;', methods: &#123; action: action('clicked') &#125;, &#125;)); 效果图 总结StoryBook 可以在原有的项目上进行构建，是独立的，并不影响原有项目； 更多的是作为单独的UI组件库使用，实现UI可视化，交互，日志输出，文档输出等功能。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://luoyec.cn/categories/工程化/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"storybook","slug":"storybook","permalink":"https://luoyec.cn/tags/storybook/"},{"name":"UI组件库","slug":"UI组件库","permalink":"https://luoyec.cn/tags/UI组件库/"}]},{"title":"深入了解合并操作(转)","date":"2018-10-23T06:57:42.774Z","path":"2018/10/23/cjqoyqt1b0079hl6pthyu4bro/","text":"原文 要点： 合并的发生了什么 rebase 合并 rebase 合并的缺点（修改了历史） 深入了解合并操作(转)在你进入 rebase 这个主题前，我们有必要来再次探讨一下更多关于合并操作的细节。当 Git 执行一个合并时，它实际上会查找三个提交： (1)共同的原始提交如果你在项目中查看两个分支的历史，它们总是会出自于一次共同的提交，那么在当时的时间点上，这两个分支还是拥有相同的内容。之后它们就开始有了差别。 (2) + (3) 两个分支的最终点合并操作的目的就是把两个分支的最新状态结合起来。因此他们各自的最新版本是有特殊含义的。 结合这三个提交后得到的结果就是我们整合的目标。 快进或合并提交一种最简单的情况是，在其中的一个分支上没有任何一个新的改动提交发生。那么在它之前的最后一次提交就仍然还是那个共同的原始提交。 在这种情况下，执行整合操作就非常简单了。 Git 仅仅需要添加所有那些在另外一个分支上的新提交就可以了。在 Git 中，这种最简单的整合操作我们称之为 “快进（fast-forward）”合并。之后两个分支就拥有了完全相同的历史。 但是在大多数情况下，两个分支都会有自己不同的发展轨迹。 为了完成整合，Git 会需要创建一个新的提交来含括它们之间的差异，这就是整合提交（merge commit）。 手工提交与合并提交通常情况下，提交都是由手工精心创建的。这样也就能更好地保证一次提交只涉及一个关联改动，并且能更好地注释这个提交。 一个合并提交就不同了，它不是由开发人员手动创建的，而是由 Git 自动生成的。它也不涉及一个关联改动，其目的只是连接两个分支，就像节点一样。如果之后想要了解某个合并操作，你只需要查看这两个分支的历史记录和它们相应的提交树（version tree）。 Rebase 整合有些人并不喜欢使用这种自动合并提交。相反，他们希望项目拥有一个单一的历史发展轨迹。比如一条直线。在历史纪录上没有迹象表明在某些时间它被分成过多个分支。 现在就让我们一步一步地了解一下 rebase 操作吧！仍然来使用前面的例子：我们想合并分支 B 到 分支 A 中，但是这次使用 rebase 操作。 使用下面这个非常的简单的命令： 1$ git rebase branch-B 首先，Git 会 “撤销” 所有在分支 A 上的那些在与分支 B 的共同提交之后发生的提交。当然，Git 不会真的放弃这些提交，其实你可以把这些撤销的提交想像成 “被暂时地存储” 到另外的一个地方去了。 接下来它会整合那些在分支 B（这个我们想要整合的分支）上的还未整合的提交到分支 A 中。在这个时间点，这两个分支看起来会是一模一样的。 最后，那些在分支 A 的新的提交（也就是第一步中自动撤销掉的那些提交）会被重新应用到这个分支上，但是在不同的位置上，在那些从分支 B 被整合过来的提交之后，它们就被 re-based 了。整个项目开发轨迹看起来就像发生在一条直线上。相对于一个合并提交，rebase 包括了所有的组合变化，最原始的提交结构会被保留下来。 Rebase 存在的陷阱当然，使用 rebase 操作不会是永远一帆风顺的。很有可能会搬起石头砸自己的脚，因此你不能忽视一个重要的事实：rebase 会改写历史记录。 你有可能已经注意到了，在被 rebase 操作之后的版本中，提交 “C3*” 存在一个新添加的星号。这是因为，尽管这个提交的内容和 “C3” 完全一样，但是它实际上是一个不同的提交。这样做的原因是，它现在有一个新的源提交 C4（在最初创建 C3 时的源提交是 C1）。 一个提交仅仅包括很少的属性，比如作者，日期，变动和谁是它的父提交。如果改变其中任何一个信息，就必须创建一个全新的提交。当然，新的提交也会拥有一个新的 hash ID 。 如果还仅仅只是操作那些尚未发布的提交，重写历史记录本身也没有什么很大的问题。但是如果你重写了已经发布到公共服务器上的提交历史，这样做就非常危险了。其他的开发人员可能这时已经在最原始的提交 C3 上开始工作，并使它成为了一些新提交中不可或缺的部分，而现在你却把 C3 的改动设置到了另一个时间点（就是那个新的 C3*）。除此之外，通过rebase 操作，这个原始的 C3 还被删除掉了，这将是非常可怕的…… 因此你应该只使用 rebase 来清理你的本地工作，千万不要尝试着对那些已经被发布的提交进行这个操作。","categories":[{"name":"Vuegit","slug":"Vuegit","permalink":"https://luoyec.cn/categories/Vuegit/"}],"tags":[{"name":"git","slug":"git","permalink":"https://luoyec.cn/tags/git/"},{"name":"rebase","slug":"rebase","permalink":"https://luoyec.cn/tags/rebase/"},{"name":"merge","slug":"merge","permalink":"https://luoyec.cn/tags/merge/"}]},{"title":"XMLHttpRequest","date":"2018-10-17T08:06:20.966Z","path":"2018/10/17/cjqoyqszo0047hl6pulzc7ihf/","text":"参考资料： 阮一峰 XMLHttpRequest Level 2 使用指南 你真的会使用XMLHttpRequest吗？ XMLHttpRequestXMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间；","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://luoyec.cn/tags/XMLHttpRequest/"}]},{"title":"Vue源码解析-响应式原理（计算属性、监听属性、组件更新）","date":"2018-08-24T08:20:55.943Z","path":"2018/08/24/cjqoyqszl0041hl6pnesvsg9h/","text":"Vue源码解析-响应式原理（计算属性、监听属性、组件更新）计算属性&amp;&amp;监听属性 了解计算属性实现原理 了解监听属性实现原理和几种配置 了解各自的适用场景 计算属性实现原理 类型：{ [key: string]: Function | { get: Function, set: Function } } 在 computed 中可以使用函数也可以使用对象，如果使用对象必须有 getter 属性。在 computed 中定义的键值不能喝 data、props 中的重复，否则报错。 何时开始计算？在组件定义的之前完成 computed 的创建，此时不会开始计算，而是在 render 中触发了 getter 时触发计算。 📌 如果计算属性的值没有改变，不会触发 dep.notify 通知数据更新，不会触发重新渲染。 监听属性实现原理new watcher 中收集依赖，不同的选项，收集依赖的方式不一样。 类型：{ [key: string]: string | Function | Object | Array }一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 选项：immediate 在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调： 1234vm.$watch('a', callback, &#123; immediate: true&#125;)// 立即以 `a` 的当前值触发回调 选项：deep 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 递归对象，收集每一个属性的依赖，实现数据监听。 12345vm.$watch('someObject', callback, &#123; deep: true&#125;)vm.someObject.nestedValue = 123// callback is fired 选项： sync sync：true 数据改变时，同步执行回调，会优先执行该 watch 适用场景计算属性适合在模板渲染中，适合简单的逻辑，某个值是依赖了其他响应式对象甚者是计算属性而来的； 监听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。 组件更新渲染 watcher： 在数据更新的时候出发更新更是，触发 render， 生成 VNode ，update 更新到 DOM。 组件更新的过程核心就是新旧 vnode diff，对新旧节点相同以及不同的情况分别做不同的处理。新旧节点不同的更新流程是创建新节点-&gt;更新父占位符节点-&gt;删除旧节点；而新旧节点相同的更新流程是去获取它们的 children，根据不同情况做不同的更新逻辑。最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 updateChildren 逻辑 原理图","categories":[{"name":"Vue源码解析","slug":"Vue源码解析","permalink":"https://luoyec.cn/categories/Vue源码解析/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"响应式","slug":"响应式","permalink":"https://luoyec.cn/tags/响应式/"}]},{"title":"Vue源码解析-响应式原理","date":"2018-08-24T03:55:14.296Z","path":"2018/08/24/cjqoyqszj003xhl6p2o9cg0ho/","text":"Vue源码解析-响应式原理原理图： 数据变化到 DOM 变化，前端开发工作 数据渲染到界面 处理用户交互 响应式对象Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，Object.defineProperty 在对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 其中最关键的是实现了 getter，当访问属性的时候触发，依赖收集 setter，当修改属性的时候触发，通知更新 ⚠️ 对象以及对象嵌套的对象都会被添加为响应式对象。 initStateinitState 方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。 proxy代理的作用是把 props 和 data 上的属性代理到 vm 实例上，这也就是为什么比如我们定义了如下 props，却可以通过 vm 实例访问到它。 observeobserve 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例。 ObserverObserver 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。 在它的构造函数中会执行 this.walk(value)， 123456walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; 这里的 defineReactive 方法是给对象动态添加 getter、setter， 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。 依赖收集响应式对象 getter 相关的逻辑就是做依赖收集，const dep = new Dep() 实例化一个 Dep 的实例，在 get 函数中通过 dep.depend 做依赖收集。 DepDep 是 depend 的缩写，是整个 getter 依赖收集的核心，在 getter 方法中，通过 const dep = new Dep() 实例化一个 Dep 的实例，然后通过 dep.depend 做依赖收集。 Dep 有一个静态属性 target，这是当前唯一的全局 Watcher，因为同一时间只有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 数组。 Watcher12345678910111213/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. * * watcher 观察一个数据，当数据的值发生改变时执行回调方法，watcher也被用于 $watch() * api 和 directives */ // 构造函数this.deps = [] // 表示 Watcher 实例持有的 Dep 实例数组this.newDeps = [] // 表示 Watcher 实例持有的 Dep 实例数组this.depIds = new Set()this.newDepIds = new Set() 清空依赖Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除，每次执行 depend， render 不会订阅 v-if 为 false 的数据。 总结 依赖收集就是订阅数据变化的 watcher 的收集 依赖收集的目的是为了当这些响应式数据发送变化，触发它们的 setter 的时候，能知道应该通知哪里订阅者去做相应的逻辑处理 派发更新setter 的逻辑有 2 个关键的点 一个是 childOb = !shallow &amp;&amp; observe(newVal)，如果 shallow 为 false 的情况，会对新设置的值变成一个响应式对象； 另一个是 dep.notify()，通知所有的订阅者 dep.notify()该方法是 Dep 实例的一个方法。12345678910class Dep &#123; // ... notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 逻辑非常简单，遍历所有的 subs，也就是 Watcher 的实例数组，然后调用每一个 watcher 的 update 方法。 📌 每一个 Vue 的实例都有 Watcher 在 update 方法中，引入了一个队列，update 不会每次数据发生改变时都会触发 watcher 回调，而是将这些 watcher 先添加到一个队列中，然后再 nextTick 后再执行。 😜 nextTick 可以理解为一个事件循环周期 异常在数据更新的同时又触发了数据更新，比如在 一个 computed 中执行了 data 数据的修改，而 data 又依赖于 computed，这是 Vue 有机制限定最大更新数为 100，超过则报异常。 nextTickJS 运行机制（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 总结比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行 Vue.js 提供了 2 种调用 nextTick 的方式 一种是全局 API Vue.nextTick， 一种是实例上的方法 vm.$nextTick 检测变化的注意事项 了解哪些数据变化不能被检测到 了解如何解决数据变化检测的问题以及其中的原理 当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的，比如：123456789var vm = new Vue(&#123; data:&#123; a:1， aArray: [] &#125;&#125;)// vm.b 是非响应的vm.b = 2aArray[1] = 1 // 直接修改数组也是非响应的 Vue.set 参数： {Object | Array} target {string | number} key {any} value 返回值：设置的值。 用法： 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = &#39;hi‘) ⚠️ 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 数组的情况操作数组时使用以下方法是可以检测到数组变化的。123456789const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] Vue 重写了 这些方法，如果有新值插入到数组中，就将这些新值变成响应式对象，并且再次调用 ob.dep.notify() 手动触发依赖通知（触发依赖收集）。 Vue.deleteVue.delete( target, key ) 类似于 Vue.set 方法, 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制。","categories":[{"name":"Vue源码解析","slug":"Vue源码解析","permalink":"https://luoyec.cn/categories/Vue源码解析/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"响应式","slug":"响应式","permalink":"https://luoyec.cn/tags/响应式/"},{"name":"观察者","slug":"观察者","permalink":"https://luoyec.cn/tags/观察者/"}]},{"title":"Vue源码解析-组件化","date":"2018-08-22T10:39:34.503Z","path":"2018/08/22/cjqoyqt4f00ishl6ph0gax8kb/","text":"Vue 源码解析-组件化Vue 其中一个核心思想是组件化，把页面拆分成多个组件，组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 createComponent12345var app = new Vue(&#123; el: '#app', // 这里的 h 是 createElement 方法 render: h =&gt; h(App)&#125;); createComponent最终会调用 _createElement 方法， 通过判断传入的参数是否是组件，而选择使用 createComponent 方法创建一个 VNode。 源码： src/core/vdom/create-component.js 该方法针对组件渲染有三个关键步骤： 构造子类构造函数mergeOptions 方法将 Vue 构造函数的 options 和用户传入的 options 合并到同一层，到 vm.$options 上 Vue.extend 的作用就是将一个纯对象转换成一个继承于 Vue 的构造器 Sub 并返回。并且对 Sub 这个对象做了一些扩展，如扩展 options、全局 API 等；对配置中的 props、 computed 进行初始化工作；最后对 Sub 的构造函数缓存，避免多次 extend 同一个子组件的时候重复执行。 安装组件的钩子函数 1234567891011121314// install component management hooks onto the placeholder node/ instalinstallComponentHooks(data);function installComponentHooks(data: VNodeData) &#123; const hooks = data.hook || (data.hook = &#123;&#125;); for (let i = 0; i &lt; hooksToMerge.length; i++) &#123; const key = hooksToMerge[i]; const existing = hooks[key]; const toMerge = componentVNodeHooks[key]; if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123; hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge; &#125; &#125;&#125; 将 componentVNodeHooks 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关的钩子函数。 实例化 VNode 123456789101112const name = Ctor.options.name || tag;const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory);return vnode; 最后通过 new VNode 实例化一个 VNode 并返回，与普通元素节点不同的是，组件的参数中是没有 children 的，在之后的 patch 过程中有关键性作用。 patch上一节中 createComponent 创建的组件的 VNode，之后会执行 vm._update, 执行 vm.__patch__ （包含diff算法）把 VNode 转换成真正的 DOM 节点。 patch 的过程会调用 createElm 创建元素节点 123if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return;&#125; 组件的初始化时不传 el 的，因为自己接管了 vm$mount. 在完成组件的整个 patch 过程后，最后执行 insert(parentElm, vnode.elm, refElm) 完成组件的 DOM 插入，如果组件 patch 过程中又创建了子组件，那么 DOM 的插入顺序是先子后父。 配置合并new Vue 通常有两种情况，一种是外部代码中主动调用 new Vue(opitons) 去实例化一个 Vue 对象，另一种是在组件过程中内部通过调用 new Vue(opitons) 实例化子组件。 无论哪种场景，都会首先执行 merge options 的逻辑。 外部调用场景 合并前 12345678910Vue.mixin(&#123; created() &#123; console.log('parent created'); &#125;&#125;);let app = new Vue(&#123; el: '#app', render: h =&gt; h(childComp)&#125;); 合并后 1234567891011121314151617vm.$options = &#123; components: &#123;&#125;, created: [ function created() &#123; console.log('parent created'); &#125; ], directives: &#123;&#125;, filters: &#123;&#125;, _base: function Vue(options) &#123; // ... &#125;, el: '#app', render: function(h) &#123; //... &#125;&#125;; 组件场景组件的构造函数是通过 Vue.extend 继承自 Vue。其中最关键的逻辑是，将 Vue.options 和组件定义的对象合并到 Sub.options 中。 子组件初始化过程通过 initInternalComponent 方式要比外部初始化 Vue 通过 mergeOptions 的过程要快，合并完的结果保留在 vm.$options 中。 options 就是 new vue 大括号里的内容使用 mergeOptions 合并配置，在 Vue options 扩展配置，之后执行new Vue() 生命周期每个 Vue 实例（new Vue、子组件内部调用的 new Vue）被创建都需要经过一系列初始化过程。其中需要设置数据监听、编译模板、挂载实例到 DOM、在数据更新时更新 DOM。在这个过程中会调用相关的钩子方法。 callHook最终执行生命周期是通过调用 callHook 方法，根据传入的字符串 hook，去拿到 vm.$options[hook] 对应的回调函数数组，然后遍历执行，执行的时候把 vm 作为函数执行的上下文。 在之前的配置合并中，这些钩子函数都被合并到了 vm.$options 中并且是一个数组。 调用时机beforeCreate &amp; created 123456789101112Vue.prototype._init = function(options?: Object) &#123; // ... initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, 'beforeCreate'); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, 'created'); // ...&#125;; beforeCreate 和 created 的钩子调用是在 initState 的前后，initState 的作用是初始化 props、data、methods、watch、computed 等属性，之后我们会详细分析。那么显然 beforeCreate 的钩子函数中就不能获取到 props、data 中定义的值，也不能调用 methods 中定义的函数。 这两个方法执行完后，并没有渲染 DOM，此时是不能访问 DOM。 一把来说后端的接口请求，放在这里两个钩子函数中都可以，如果需要访问 props、data 等数据，就需要在 created 中执行了。 vue-router 、 vuex 都混合了 beforeCreatd 钩子函数。 beforeMount &amp; mounted这一对方法是以 DOM 挂载前后为分界线。 在执行 vm._render 方法前，执行了 beforeMount， 当在执行完 vm.update 方法后，把 VNode patch 到真是 DOM 后，执行了 mouted 钩子。 mounted 钩子函数的执行顺序也是先子后父。 beforeUpdate &amp; updatedbeforeUpdate 的执行时机是在渲染 Watcher 的 before 函数中，组件已经 mounted 之后，才会去调用这个钩子函数。 update 的执行时机是在 flushSchedulerQueue 函数调用的时候。 组件 mount 的过程中，会实例化一个渲染的 Watcher 去监听 vm 上的数据变化重新渲染。 beforeDestroy &amp; destroyedbeforeDestroy 和 destroyed 钩子函数的执行时机在组件销毁的阶段 beforeDestroy 钩子函数的执行时机是在 $destroy 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 parent 的 $children 中删掉自身，删除 watcher，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 destroy 钩子函数。 在 $destroy 的执行过程中，它又会执行 vm.__patch__(vm._vnode, null) 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。 activated &amp; deactivatedactivated 和 deactivated 钩子函数是专门为 keep-alive 组件定制的钩子。 总结在 created 中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在destroyed 钩子函数中做定时器销毁 组件注册在 Vue.js 中，除了它内置的组件如 keep-alive、component、transition、transition-group 等，其它用户自定义组件在使用前必须注册。 全局注册可以在任意地方使用，扩展在Vue options 123Vue.component('my-component', &#123; // 选项&#125;); 局部注册在当前组件内，扩展在 Sub options 1234567import HelloWorld from './components/HelloWorld';export default &#123; components: &#123; HelloWorld &#125;&#125;; 总结局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。 异步组件开发中，为了减少首屏代码体积，往往把一些非首屏的组件设计成异步组件，按需加载。本质是两次渲染，先渲染成注释节点，在组件加载成功了，在通过 foreceRender 重新渲染。 普通函数异步组件 123456Vue.component('async-example', function(resolve, reject) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve);&#125;); component 的第二个参数传入的是函数， 普通组件传入的是对象。 ⚠️ 在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。 Promise 异步组件 12345Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component')); 判断是否是 Promise 的方法：typeof res.then === &#39;function&#39; 高级异步组件由于异步加载组件需要动态加载 JS，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。 12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;);","categories":[{"name":"Vue源码解析","slug":"Vue源码解析","permalink":"https://luoyec.cn/categories/Vue源码解析/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"https://luoyec.cn/tags/组件化/"},{"name":"patch","slug":"patch","permalink":"https://luoyec.cn/tags/patch/"},{"name":"异步组件","slug":"异步组件","permalink":"https://luoyec.cn/tags/异步组件/"}]},{"title":"Vue源码解析-数据驱动","date":"2018-08-21T08:06:57.691Z","path":"2018/08/21/cjqoyqszm0044hl6p1jxgjh4g/","text":"资源列表：慕课网：Vue.js 源码全方位深入解析Vue.js 技术揭秘知乎：染陌同学 VirtualDOM与diff(Vue实现) Vue源码解析-数据驱动Introduction现代前端框架抛弃里如使用 JQuery 等前端库直接修改 DOM，而是由数据驱动视图。本章节主要研究 Vue 中模板和数据如果渲染成最红的 DOM。 12345678910&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) new Vue 发生了什么new 关键字在 JavaScript 中实例化一个对象，而 Vue 本质是一个 Function 模拟的类，在其上扩展静态方法和原型方法。 源码，在src/core/instance/index.js 12345678function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 最后 new Vue() 调用的是 this._init 方法。 源码：src/core/instance/init.js。 Vue 初始化主要做了几件事 合并配置 初始化生命周期 初始化事件中心 初始化渲染 初始化 data、props、computed、watcher 等 最后判断是否有 el 属性，如果有则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM 1234// 68 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; el、templateVue 文档 el template 12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;hello-world&apos;, &#123; template: &quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot; &#125;) var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; Vue 实例挂载的实现$mount 方法的实现是和平台、构建方式相关，不同平台如 weex 有不同的 $mount 实现，底层使用的 API 也不尽相同，这里研究 compiler 的实现。 源码： src/platform/web/entry-runtime-with-compiler.js 对 el 做了限制，不能挂载到 body、html 根节点上 如果没有render 方法，则会把 el 或者 template 字符串转成 render 方法，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法 $mount 方法实际上会去调用 mountComponent 方法， 源码：src/core/instance/lifecycle.js 先调用 vm._render 方法生成虚拟 Node 再实例化一个渲染 Watcher，在它的回调函数中调用了 updateComponent 最后调用 vm._update 更新 DOM 最后的判断，vm._isMounted 为 true， 表示已经挂载，同时执行 mounted 钩子函数。 ⚠️ 这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。 render它用来把实例渲染成一个虚拟 Node， 源码： src/core/instance/render.js Vue 文档中的 render 方法，第一个参数 createElement，用来创建 Vnode，模板中的写法： 123&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 等同于 render 函数的写法 1234567render: function (createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app' &#125;, &#125;, this.message)&#125; 📌 Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM Virtual DOM为什么要使用虚拟 DOM ？在文档中，一个真实的 DOM 元素是很庞大的，直接修改该元素成本很高，使用 虚拟 DOM，只需要维护一个真实 DOM 映射的对象，这要比维护真实 DOM 成本小得多。 Virtual DOM 是用 VNode 这么一个 Class 去描述 定义在 src/core/vdom/vnode.js VNode 是对真实 DOM 的一种抽象描述，核心无非就是几个关键属性，标签名、数据、子节点、键值等。 映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。 createElementVue.js 利用 createElement 方法创建 VNode， 它定义在 src/core/vdom/create-elemenet.js 中： 每个 VNode 都有 children，每个 children 也是一个 VNode，这样就形成了 VNode tree。 最后通过 vm._update， 将 VNode 渲染成真实的 DOM 并渲染出来。 update该方法被调用的时机有两次，一次是首次渲染，一次是在数据更新的时候。 源码： src/core/instance/lifecycle.js 核心是调用了 vm.__patch__，该方法根据平台的不同有区别。 在该方法中实现了 diff 算法，具体参考： Vue.js 技术揭秘 diff算法diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历，所以时间复杂度只有 O(n)，是一种高效的算法。 判断为同一个 VNode的依据 12345678910111213/*判断两个VNode节点是否是同一个节点，需要满足以下条件key相同tag（当前节点的标签名）相同isComment（是否为注释节点）相同是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义当标签是&lt;input&gt;的时候，type必须相同*//*判断当标签是&lt;input&gt;的时候，type是否相同某些浏览器不支持动态修改&lt;input&gt;类型，所以他们被视为不同类型*/ 如何进行对比？ 1.如果新旧 VNode 都是静态的，同时它们的 key 相同（代表同一节点），并且新的 VNode 是 clone 或者是标记了once（标记 v-once 属性，只渲染一次），那么只需要替换 elm 以及 componentInstance 即可。 2.新老节点均有 children 子节点，则对子节点进行diff 操作，调用 updateChildren，这个updateChildren 也是 diff 的核心。 3.如果老节点没有子节点而新节点存在子节点，先清空老节点 DOM 的文本内容，然后为当前 DOM 节点加入子节点。 4.当新节点没有子节点而老节点有子节点的时候，则移除该 DOM 节点的所有子节点。 5.当新老节点都无子节点的时候，只是文本的替换。 其他对比细节参考博客文章。 DOM操作我们只是将虚拟 DOM 映射成了真实的 DOM。那如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ 需要在 create 以及 update 钩子被调用时更新 DOM 的 attr 属性即可 总结模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。","categories":[{"name":"Vue源码解析","slug":"Vue源码解析","permalink":"https://luoyec.cn/categories/Vue源码解析/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"数据驱动","slug":"数据驱动","permalink":"https://luoyec.cn/tags/数据驱动/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"https://luoyec.cn/tags/虚拟DOM/"},{"name":"diff算法","slug":"diff算法","permalink":"https://luoyec.cn/tags/diff算法/"}]},{"title":"Object.defineProperty()","date":"2018-08-17T03:11:06.085Z","path":"2018/08/17/cjqoyqsz7003bhl6pbuqrwm7r/","text":"参考：Object.defineProperty() Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 1234567891011121314151617181920212223242526272829303132333435363738var o = &#123;&#125;; // 创建一个新对象// 在对象中添加一个属性与数据描述符的示例Object.defineProperty(o, \"a\", &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;);// 对象o拥有了属性a，值为37// 在对象中添加一个属性与存取描述符的示例var bValue;Object.defineProperty(o, \"b\", &#123; get : function()&#123; return bValue; &#125;, set : function(newValue)&#123; bValue = newValue; &#125;, enumerable : true, configurable : true&#125;);o.b = 38;// 对象o拥有了属性b，值为38// o.b的值现在总是与bValue相同，除非重新定义o.b// 数据描述符和存取描述符不能混合使用Object.defineProperty(o, \"conflict\", &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125; &#125;);// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors ⚠️ 数据描述符和存取描述符不能混用 Writable 属性当 writable 属性设置为 false 时，该属性被称为“不可写”。它不能被重新分配。 ⚠️普通模式不会抛出异常，严格模式抛出异常“read-only” Enumerable 特性 enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。 Configurable 特性configurable 特性表示对象的属性是否可以被删除，以及除writable 特性外的其他特性是否可以被修改。 一般的 Setters 和 Getters12345678910111213141516171819202122var pattern = &#123; get: function () &#123; return 'I alway return this string,whatever you have assigned'; &#125;, set: function () &#123; this.myname = 'this is my name string'; &#125;&#125;;function TestDefineSetAndGet() &#123; Object.defineProperty(this, 'myproperty', pattern);&#125;var instance = new TestDefineSetAndGet();instance.myproperty = 'test';// 'I alway return this string,whatever you have assigned'console.log(instance.myproperty);// 'this is my name string'console.log(instance.myname);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"}]},{"title":"HTML5 语义化最佳实践","date":"2018-06-26T10:08:24.092Z","path":"2018/06/26/cjqoyqsxw000rhl6pwkmrzw3l/","text":"参考：Are you Writing Accessible HTML?HTML5 语义化 w3cplus HTML5 语义化最佳实践最佳实践 使用 a 标签代替点击行为的 span 标签 使用 button 标签作为按钮 在表单元素中使用 label 所有的 img 标签都应有有 alt 属性描述图标本身 修饰作用的 img 如 loading.gif 应有用空的 alt=&quot;&quot; 属性 焦点管理 - 使用 tabindex 控制 tab 键切换焦点的顺序 - 将 tabindex 置为 -1 可以避免 tab 键获取焦点 新元素markmark 元素对其内容赋予任何重要性，仅仅是突出显示。用于替代 em 或 strong time meter元素可用于测量的标记，提供测量的最大值和最小值进行测量值的缩放。 progress figure 与 figcaptionfigure 元素标记文档中的一个图像figcaption 元素被用来为 figure 元素定义标题。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://luoyec.cn/categories/HTML5/"}],"tags":[{"name":"语义化","slug":"语义化","permalink":"https://luoyec.cn/tags/语义化/"},{"name":"图解","slug":"图解","permalink":"https://luoyec.cn/tags/图解/"}]},{"title":"Nginx 部署静态页面","date":"2018-06-11T09:14:01.244Z","path":"2018/06/11/cjqoyqsz30030hl6ppgpe42er/","text":"Nginx 部署静态页面在前后端分离的项目中，前端经过编译生成的文件中，往往只包含一个 index.html 入口文件。可以利用 Nginx 进行简单配置就可以实现在部署到服务器端。 🐸 如果是 nodejs 的项目可以利用 pm2 进行部署，如果是 egg 的项目可以利用 egg 的工具 egg-scripts 进行部署 Nginx 的全局配置通过 yum 安装 Nginx 的配置文件在 /etc/nginx/nginx.conf 下。 其中 include /etc/nginx/default.d/*.conf; 引入在目录下的所有配置文件，原则上每个配置文件对应一个静态页面文件。 ⚠️ include 的坑：include 的位置应该在第一个 server 块后面⚠️ 权限问题导致的 403： 修改 conf 配置 user 字段为 root（默认是 nginx ） 完整的 nginx.conf 配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user root;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. #include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; include /etc/nginx/default.d/*.conf;# Settings for a TLS enabled server.## server &#123;# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate \"/etc/pki/nginx/server.crt\";# ssl_certificate_key \"/etc/pki/nginx/private/server.key\";# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / &#123;# &#125;## error_page 404 /404.html;# location = /40x.html &#123;# &#125;## error_page 500 502 503 504 /50x.html;# location = /50x.html &#123;# &#125;# &#125;&#125; default.conf 的配置在 /etc/nginx/default.d 目录下配置，新建文件，一个简单的文件模板如下： 12345678server &#123; listen 9001; server_name localhost; location / &#123; root /root/node-project/pm2test; #index index.html index.htm; &#125;&#125; ⚠️ 注意这里只包含 server 块 相关命令行检查配置文件是否配置正确 1sudo nginx -t -c /etc/nginx/nginx.conf 修改配置后，刷新配置 1nginx -s reload 杀死 nginx 进程，重启 12pkill -9 nginxsystemctl restart nginx 启动 nginx 1nginx 反向代理利用 nginx 反向代理可以解决前端开中的跨域问题，而不需要服务端配合。具体请参考：Nginx 反向代理","categories":[{"name":"工程化","slug":"工程化","permalink":"https://luoyec.cn/categories/工程化/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://luoyec.cn/tags/nginx/"},{"name":"部署","slug":"部署","permalink":"https://luoyec.cn/tags/部署/"}]},{"title":"Vue.js 快速入门与专业应用","date":"2018-05-14T02:03:57.255Z","path":"2018/05/14/cjqoyqt4d00iohl6pkz32picv/","text":"摘抄自： 《 Vue.js 前端开发- 快速入门与专业应用》 Vue.js 快速入门与专业应用Vue.js 简介Vue.js 的组件化理念和 ReactJS 异曲同工——“一切都是组件”，可以将任意封装好的代码注册成标签，例如:Vue.component(&#39;example&#39;, Example)，可以在模板中以 &lt;example&gt;&lt;/ example&gt; 的形式调用。 Vue.js 的使用都是通过构造函数 Vue({option}) 创建一个 Vue 的实例: var vm = new Vue({})。一个 Vue 实例相当于一个 MVVM 模式中的 ViewModel。 在实例化的时候，我们可以传入一个选项对象，包含数据、模板、挂载元素、方法、生 命周期钩子等选项。 基础特性模板 el :类型为字符串，DOM 元素或函数。其作用是为实例提供挂载元素。 template :类型为字符串。默认会将 template 值替换挂载元素(即 el 值对应的元素)， 并合并挂载元素和模板根节点的属性(如果属性具有唯一性，类似 id，则以模板根节点为准)。 123456789101112&lt;div id=\"app\"&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;script id=\"tpl\" type=\"x-template\"&gt; &lt;div class='tpl'&gt; &lt;p&gt;This is a tpl from script tag&lt;/p&gt; &lt;/div&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el : '#app', template : '#tpl' &#125;);&lt;/script&gt; Vue 实例中需要有一个根元素，模板的定义只能有一个根元素，建议模板定义如下： 1234567&lt;script id=\"tpl\" type=\"x-template\"&gt; &#123;' '&#125; &lt;div class=\"wrapper\"&gt; &lt;div class=\"tpl\"&gt;...&lt;/div&gt; &lt;div class=\"tpl\"&gt; ...&lt;/div&gt; &lt;/div&gt;&lt;/script&gt; Vue 实例通过 data 属性定义数据，这些数据可以在实例对应的模板中进行绑定并使用。需要注意的是传入 data 是一个对象，那么 Vue 实例会代理起所有 data 对象中的所有属性，而不会对传入的对象进行深拷贝。 可以通过 Vue 实例 vm 中的 $data 来获取声明数据，需要注意的是，只有初始化传入的对象才是响应式的，在声明完实例后再增加的属性，将不会是响应式的 Vue 推荐在初始化的时候将所有的变量都设定好，如果没有值，额可以用 undefined 或null 占位。 另外，组件的实例可以通过 props 获取数据，同 data ，也需要在初始化时预设好。通过 methods 对象来定义方法，并使用 v-on 指令来监听 DOM 事件 Vue 实例也支持自定义事件，可以在初始化时传入 event 对象，通过实例的 $emit 方法进行触发。这套机制常在组件间相互通信的情况中，例如子组件冒泡触发父组件事件方法，或者父组件广播某个事件，子组件对其进行监听等。（⚠️ Vue 2.x 中已经废弃 events 属性，不再支持事件广播，推荐直接使用 Vue 实例的全局方法 $on()/$emit()， 或者使用插件 vuex 来处理） 生命周期 Vue 实例在创建时有一系列初始化步骤，例如建立数据观察，编译模板，创建数据绑定等，这些过程中，可以通过生命周期钩子函数 beforeCreate() : 在实例开始初始化时同步调用，此时数据观测、事件都尚未初始化 created()：在实例创建之后调用，此时已经完成数据绑定、事件方法，但尚未开始 DOM 编译，即未挂在到 document beforeMount(): mounted(): 在编译结束时调用，此时指令已经生效，数据变化已经能触发 DOM 更新，但不保证 $el 已插入文档 beforeDestroy(): 在开始销毁实例时调用，此时实例仍然有效 destroyed(): 在实例被销毁之后调用，此时所有的绑定和实例指令都已经解绑，子实例也被销毁。 beforeUpdate(): 在实例挂载之后，再次更新实例（例如更新 data）时会调用该方法，此时尚未更新 DOM 结构 updated(): 在实例挂载之后，再次更新实例并在实例更新完 DOM 之后被调用 activated():2.0 新增的生命周期钩子，需要配合动态组件 keep-live 属性使用。在动态组件初始化渲染的过程中调用该方法。 deactivated() :2.0 新增的生命周期钩子，需要配合动态组件 keep-live 属性使用。在动 态组件移出的过程中调用该方法。 数据绑定，Vue 的核心是一个响应式的数据绑定系统，简历绑定后， DOM 将和数据保持同步，这样就无需手动维护 DOM，使代码能够更加简洁易懂、提升效率。 指令，可以理解为当表达式的值发生改变时，会有些特殊行为作用到绑定的 DOM 上，指定通常直接书写在模板的 HTML 元素中，而为了有别于普通的属性， Vue 是带有前缀的 v- 属性 表单控件，Vue 中提供 v-model 的指令对表单元素进行双向绑定，在修改表单元素值的同时，实例 vm 中对应是属性值也会同时更新，反之亦然。 12345678&lt;input type=\"text\" v-model=\"message\" /&gt;&lt;span&gt;Your input is : &#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;label&gt;&lt;input type=\"radio\" value=\"male\" v-model=\"gender \"&gt; 男 &lt;/lable&gt;&lt;label&gt;&lt;input type=\"radio\" value=\"female\" v-model=\"gender \"&gt; 女 &lt;/lable&gt;&lt;p&gt;&#123;&#123; gender &#125;&#125;&lt;/p&gt;// gender 值即为选中的 radio 元素的 value 值。 ⚠️ 声明周期流程图中包含了模板的渲染顺序 Class 与 Style 绑定class 属性，我们绑定的数据可以是对象和数组，绑定修改的是元素的 class 属性，内联样式绑定，style 属性绑定数据的内联样式。 12345&lt;div v-bind:style=\"alertStyle\"&gt;&lt;/div&gt; data : &#123; alertStyle : &#123; color : 'red', fontSize : '20px' &#125;&#125; 数组语法，允许将多个样式绑定到同一个元素上 1&lt;div v-bind:style=\"[ styleObjectA, styleObjectB]\" .&gt;&lt;/div&gt; 自动添加前缀，在使用 transform 这类属性时，v-bind:style 会根据需要自动添加厂商前缀 条件渲染，Vue.js 提供 v-if，v-show，v-else，v-for 这几个指令来说明模板和数据间的逻辑关系，这基本就构成了模板引擎的主要部分。 template 标签用法，Vue.js 提供了 template 标签，我们可以将指令作用到这个标 签上，但最后的渲染结果里不会有它。 事件绑定与监听通过 v-on 可以绑定实例选项属性 methods 中的方法作为事件的处理器，v-on：后参数接受所有的原生事件名称。 同一元素上也可以通过 v-on 绑定多个相同事件函数，执行顺序为顺序执行&lt;div v-on:click=&quot;sayFrom(&#39;first&#39;)&quot; v-on:click =&quot;sayFrom(&#39;second)&quot;&gt; 修饰符Vue 为指令 v-on 提供了多个修饰符，方便我们处理一些 DOM 事件的细节，并且修饰符可以串联使用 .stop: event.stopPropagation() .prevent: event.preventDefault() .capture: 使用 capture 模式添加事件监听器 .self: 只当事件是从监听元素本身触发时才触发回调 指令指令是 Vue 中一个重要的特性，重要提供一种机制将数据的变化映射为 DOM 行为。在 Vue 中通过数据驱动，一般情况不会直接修改 DOM，通过大量内置的指令进行 DOM 操作，也可以开发自定义指令。 v-bind: 主要用于动态绑定 DOM 元素属性，即属性实际的值是由 vm 实例中 data 属性提供的 v-model: 用于表单控件 v-if / v-else/ v-show: 展示对应模板内容 v-for: 模板渲染 v-on: 事件绑定 v-text: 作用是更新元素的 textContent，闪现问题？⚠️ v-HTML：作用是更新元素的 innerHTML v-el：为 DOM 元素注册一个索引，使得可以直接访问 DOM 元素 v-ref： 类似于 v-el，只不过这是作用域子组件上，实例可以通过 $refs 访问子组件 v-pre：跳过编译这个元素和子元素，现实原始双花括号 v-cloak：官方推荐可以和 css 规则 [v-cloak]{ display :none } 一起使用，可以隐藏未编译的 Mustache 标签直到实例准备完毕。&lt;div v-cloak&gt;&lt;/div&gt; v-once: 用于标明元素或组件只渲染一次 过滤器过滤器本质是一个函数，接受管道符前面的值作为初始值，同时也能接受额外的参数，返回值为经过处理后的输出值。多个过滤器可以串联。 1&#123;&#123; message | filterA 'arg1' 'arg2' &#125;&#125; &#123;&#123; message | filterA | filterB&#125;&#125; 双向过滤器，在写回 data 绑定属性中的过滤器，成为双向过滤器。 12345678910111213&lt;input type=\"text\" v-model=\"price | cents\" &gt;// 该过滤器的作用是处理价钱的转化，一般数据库中保存的单位都为分，避免浮点运算 Vue.filter('cents', &#123; read : function(value) &#123; return (value / 100).toFixed(2); &#125;, write : function(value) &#123; return value * 100; &#125;&#125;);var vm = new Vue(&#123; el : '#app', data: &#123; price : 150 &#125;&#125;); 过渡过渡系统是 Vue 为 DOM 动画效果提供的一个特性，它能在元素从 DOM 中插入或移除时触发 CSS 过渡（transition）和动画（animation），也就是说在 DOM 元素发生变化时为其添加特定的 class 类名，从而产生过渡效果。除了 CSS 过渡外，Vue.js 的过渡系统也 支持 javascript 的过渡，通过暴露过渡系统的钩子函数，我们可以在 DOM 变化的特定时机对 其进行属性的操作，产生动画效果。 组件组件注册 var MyComponent = Vue.extend({ ... });，这样我们获得了一个组件构造器，但现在无法直接使用这个组件，需要将组件注册到应用中。Vue 提供了两种注册方法，分别是全局注册和局部注册。 全局注册，需要在根实例初始化之前注册，这样才能使组件在任意实例中被使用。 1Vue.component('my-component', MyComponent); 对于组件的命名，W3C 规范是字母小写且包含一个短横杠“-”。 局部注册，限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。 12345678910111213141516var Child = Vue.extend(&#123; template: '&lt;p&gt;This is a child component&lt;/p&gt;'&#125;);var Parent = Vue.extend(&#123; template: '&lt;div&gt; \\ &lt;p&gt;This is a parent component&lt;/p&gt; &lt;my-child&gt;&lt;/my-child&gt; \\ &lt;/div&gt;', components: &#123; 'my-child': Child &#125;&#125;);&lt;div&gt; &lt;p&gt;This is a parent component&lt;/p&gt; &lt;p&gt;This is a child component&lt;/p&gt;&lt;/div&gt;; 组件接受的选项大部分与 Vue 实例一样，区别 data 属性，通过函数返回 也就是说子组件的模板和模块中是 无法直接调用父组件的数据，所以通过 props 将父组件的数据传递给子组件，子组件在接受数 据时需要显式声明 props， 123456Vue.component('my-child', &#123; props : ['parent'], template: '&lt;p&gt;&#123;&#123; parent &#125;&#125; is from parent'&#125;)&lt;my-child parent=\"This data\"&gt;&lt;/my-child&gt; //-&gt; &lt;p&gt;This data is fromparent &lt;/p&gt; 组件间通信Vue.js 在组件间通信这一部分既提供了直接访问组件实例 的方法，也提供了自定义事件机制，通过广播、派发、监听等形式进行跨组件的函数调用。 $parent: 父组件实例。 $children: 包含所有子组件实例。 $root: 组件所在的根实例。 自定义事件触发机制 $emit: 在实例本身上触发 $dispatch: 派发事件，事件沿着父链冒泡，并且在第一次触发回调后自动停止，除非触发函数明确返回 true，才会继续向上冒泡 $broadcast:广播事件，事件向下传递给所有后代 自组件索引 this.childre 子组件定义指定 v-ref 父组件获取子组件 this.$refs.first Vue.js 常用插件Vue-routervue-router的基本作用就是讲每个路径映射到对应的组件，并通过修改路由进行组件间的切换。 Vue-resource所以这里就和大家介绍下 Vue.js 的插件 Vue- resouce，它同样对异步请求进行了封装，方便我们同服务端进行数据的交互。 Vue-devtools:它可以在 chrome 的开发者模式下直接查看当前页面的 Vue 实例的组件结构和内部属性，方便我们直接观测。 状态管理 VueXVuex 是状态管理模式的一种实现库，主要以插件的形式和 Vue.js 进行配合使用，能够 使我们在 Vue.js 中管理复杂的组件事件流。","categories":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://luoyec.cn/tags/vue/"},{"name":"框架","slug":"框架","permalink":"https://luoyec.cn/tags/框架/"}]},{"title":"JavaScript 数组去重","date":"2018-05-06T11:50:18.040Z","path":"2018/05/06/cjqoyqsyf001nhl6p7guqdgjo/","text":"JavaScript 数组去重方法一 双循环，外循环遍历整个数组，内层循环进行比较，如果有相同的值则跳过，不同则 push 进结果数组 123456789101112131415161718Array.prototype.distinct = function() &#123; var arr = this, result = [], len = arr.length for (var i = 0; i &lt; len; i++) &#123; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[i] == arr[j]) &#123; j = ++i // 如果后面的元素等于当前外层循环遍历的元素，则跳过该元素 &#125; &#125; result.push(arr[i]) //i有两种请求，一直是正常遍历的，一种是经过跳跃的值 &#125; return result&#125;var arra = [1, 2, 3, 4, 4, 1, 1, 2, 1, 1, 1]console.log(arra.distinct()) //返回[3,4,2,1] 方法二利用 splice 方法直接在原数组上将相同的元素删除 1234567891011121314151617Array.prototype.distinct = function() &#123; var arr = this, len = arr.length for (var i = 0; i &lt; len; i++) &#123; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[i] == arr[j]) &#123; arr.splice(j, 1) len-- j-- &#125; &#125; &#125; return arr&#125;var arra = [1, 2, 3, 4, 4, 1, 1, 2, 1, 1, 1]console.log(arra.distinct()) //返回[3,4,2,1] 方法三利用对象的属性不能相同的特点进行去重，但存在 数值型 1 和字符型 1 是同一个的问题 123456789101112131415161718Array.prototype.distinct = function() &#123; var arr = this, i, obj = &#123;&#125;, result = [], len = arr.length for (i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; //如果能查找到，证明数组元素重复了,则不会放到结果数组中 obj[arr[i]] = 1 result.push(arr[i]) &#125; &#125; return result&#125;var a = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1]console.log(a.distinct()) //1,2,3,4,5,6,56 方法四利用ES6 Set 123let arr = [1, 2, 3, 3]let resultarr = [...new Set(arr)]console.log(resultarr) //[1,2,3] 方法五利用 indexOf 和 forEach 方法 1234567891011121314151617Array.prototype.distinct = function() &#123; var arr = this, result = [], len = arr.length arr.forEach(function(v, i, arr) &#123; //这里利用map，filter方法也可以实现 var bool = arr.indexOf(v, i + 1) //从传入参数的下一个索引值开始寻找是否存在重复 if (bool === -1) &#123; result.push(v) &#125; &#125;) return result&#125;var a = [1, 1, 1, 1, 23, 3, 3, 2, 3, 3, 1, 23, 1, 23, 2, 3, 2, 2, 3]var b = a.distinct()console.log(b.toString()) //1,23,2,3 方法六利用数组递归去重，先排序，然后从最后开始比较，遇到相同则删除。 1234567891011121314151617181920212223Array.prototype.distinct = function() &#123; var arr = this, len = arr.length arr.sort(function(a, b) &#123; //对数组进行排序才能方便比较 return a - b &#125;) function loop(index) &#123; if (index &gt;= 1) &#123; if (arr[index] === arr[index - 1]) &#123; arr.splice(index, 1) &#125; loop(index - 1) //递归loop函数进行去重 &#125; &#125; loop(len - 1) return arr&#125;var a = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 56, 45, 56]var b = a.distinct()console.log(b.toString()) //1,2,3,4,5,6,45,56","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyec.cn/tags/排序算法/"}]},{"title":"JavaScript排序算法","date":"2018-05-06T03:59:25.542Z","path":"2018/05/06/cjqoyqsyn0028hl6pxe0stjol/","text":"参考：《数据结构与算法 JavaScript 描述》visualgo 数据可视化 JavaScript 排序算法排序算法的核心思想是对一组数据按照一定的顺序重新排列。重新排序时用到一组嵌套的 for 循环，其中外循环会遍历数组的每一项，内循环则用于比较元素。 冒泡排序之所以叫冒泡排序，是因为排序时，数据会像起跑一样从数组的一端漂浮到另一端。算法在数组中移动，比较相邻的数据，当左侧大于右侧数据时将他们进行交换。 123456789101112131415161718192021222324252627/** * 1、第一轮排序之后就能将最大数放到最后，那么经过 n-1 轮，就能完成所有的排序，所以需要遍历的次数是 n-1 * 2、内层循环中，max - i 而不是 max？ 因为没经过一轮都会讲最大数放到后面，不再需要对这些已经排序的值进行再次遍历 * 3、为什么需要标志位，当一次遍历之后发现没有进行任何交换，说明次数数组已经完成排序，跳出循环，返回结果即可 */function bubbleSort(data) &#123; var max = data.length - 1 for (var i = 0; i &lt; max; i++) &#123; var done = true for (var j = 0; j &lt; max - i; j++) &#123; if (data[j] &gt; data[j + 1]) &#123; var temp = data[j] data[j] = data[j + 1] data[j + 1] = data[j] done = false &#125; &#125; if (done) break &#125; return data&#125;var testArr = [12, 34, 34, 5, 6, 7, 6579, 7569, 23.32, 234, 234]console.log(bubbleSort(testArr)) 选择排序选择排序从数组的开头开始，将第一个元素和其他每一个元素进行比较，检查所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便完成了排序。 123456789101112131415161718192021222324252627/** * 外层循环遍历 n-1 次 * 内层循环，没经过一次，找出最小值的坐标，循环结束后交互外循环坐标和最小坐标元素 * 内层循环是依次减少的 * */var example = [8, 94, 15, 88, 55, 76, 21, 39]function selectSort(arr) &#123; var len = arr.length var minIndex, temp for (var i = 0; i &lt; len - 1; i++) &#123; var minIndex = i for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; temp = arr[i] arr[i] = arr[minIndex] arr[minIndex] = temp &#125; return arr&#125;console.log(selectSort(example)) 插入排序插入排序有两个循环，外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及后面的那个元素进行比较。如果外循环中选中的元素比内循环中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。 123456789101112131415161718192021function insertSort(arr) &#123; var len = arr.length //数组长度为1时，不需要排序，直接返回 if (len &lt;= 1) return arr for (var i = 1; i &lt; len; i++) &#123; // tmp 是需要被插入的元素 var tmp = arr[i] var j = i // 遍历已经排序的元素 while (arr[j - 1] &gt; tmp) &#123; arr[j] = arr[j - 1] --j &#125; arr[j] = tmp &#125; return arr&#125;console.log(insertSort([1, 45, 43, 4, 56, 7, 20, 1])) 希尔排序希尔排序的工作原理是，通过定义一个间隔序列来小时排序过程中进行比较的元素之间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分实际应用常见，算法要用到间隔序列可以提前定义好。 1234567891011121314151617181920212223function shellSort(arr) &#123; var len = arr.length, temp, gap = 1 while (gap &lt; len / 3) &#123; // 动态定义间隔序列 1 4 13 gap = gap * 3 + 1 &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i] for (var j = i - gap; j &gt; 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j] &#125; arr[j + gap] = temp &#125; &#125; return arr&#125;var example = [8, 94, 15, 88, 55, 76, 21, 39]console.log(shellSort(example)) 外循环控制间隔序列的移动，也就是说，算法在第一次处理数据集时，会检查所有间隔为 4 的元素，下一次检查间隔为 1 的元素。在开始最后一次处理是时，大部分元素都将在正确的位置，算法就不必对很多元素进行交换，这也是希尔排序高效的地方。 快速排序快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是序列的。 首先要在列表中选择一个元素作为基准值 (pivot)。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 快速排序的算法和伪代码： 选择一个基准元素，将列表分隔成两个子序列 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和步骤 2 12345678910111213141516171819202122function qSort(arr) &#123; if (arr.length == 0) return [] var left = [] //小于基准存放数组 var right = [] // 大于基准存放数组 var pivot = arr[0] //基准值 for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return qSort(left).concat(pivot, qSort(right))&#125;var a = []for (var i = 0; i &lt; 10; ++i) &#123; a[i] = Math.floor(Math.random() * 100 + 1)&#125;console.log(a)console.log(qSort(a))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyec.cn/tags/排序算法/"}]},{"title":"AJAX 工作原理及概述","date":"2018-05-04T07:11:14.446Z","path":"2018/05/04/cjqoyqsx80005hl6p2kynu600/","text":"参考： 你真的会使用 XMLHttpRequest 吗？ AJAX 工作原理及概述AJAX 使用 XMLHttpRequest 对象与服务器通信，它可以使用 JSON、XML、HTML和文本等多种格式发送和接受。AJAX 最吸引人的是它的异步特性，也就是说可以在不重新刷新页面的情况下雨服务器通信，交换数据，更新页面。 最主要的两个特性： 在不重新加载页面的情况下发送请求给服务器 接受并使用从服务器发来的数据 工作原理Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。 发送 HTTP 请求创建 XMLHttpRequest 对象，需要注意兼容性问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function sendAjax() &#123; // 构造表单数据 var formData = new FormData() formData.append('username', 'johndoe') formData.append('id', 123456) // 创建 xhr 对象 var xhr = new XMLHttpRequest() xhr.timeout = 3000 xhr.responseType = 'text' //创建一个 post 请求， 第三个布尔值参数是同步还是异步, 默认是异步 xhr.open('POST', '/server', true) xhr.onload = function(e) &#123; if (this.status == 200 || this.status == 304) &#123; alert(this.responseText) &#125; &#125; xhr.ontimeout = function(e) &#123;&#125; xhr.onerror = function(e) &#123;&#125; xhr.upload.onprogress = function(e) &#123;&#125; xhr.send(formData)&#125;/** * 设置请求头 xhr.setRequestHeader('X-Text', 'one') * 获取响应头*/```## 指定响应类型`responseType` 是 `xhr level 2` 新增的属性，用来指定 `xhr.response` 的数据类型![][2]``` javascriptvar xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);//可以将`xhr.responseType`设置为`\"blob\"`也可以设置为`\" arrayBuffer\"`//xhr.responseType = 'arrayBuffer';xhr.responseType = 'blob';xhr.onload = function(e) &#123; if (this.status == 200) &#123; var blob = this.response; ... &#125;&#125;;xhr.send(); 如何获取 response 数据xhr 提供了 3 个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML xhr.response - 默认值：空字符串&quot;&quot; - 当请求完成时，此属性才有正确的值 - 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText - 默认值为空字符串&quot;&quot; - 只有当 responseType 为&quot;text&quot;、””时，xhr 对象上才有此属性，此时才能调用xhr.responseText，否则抛错 - 只有当请求成功时，才能拿到正确值。以下 2 种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML - 默认值为 null - 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr 对象上才有此属性，此时才能调用 xhr.responseXML，否则抛错 - 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下 3 种情况下值都为 null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪 ajax 请求的当前状态用 xhr.readyState 这个属性即可追踪到。这个属性是只读属性，总共有 5 种可能值，分别对应 xhr 不同的不同阶段。每次 xhr.readyState 的值发生变化时，都会触发 xhr.onreadystatechange 事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; &#125; 可以发送什么类型的数据xhr.send(data)的参数 data 可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 事件触发顺序","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://luoyec.cn/tags/ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://luoyec.cn/tags/XMLHttpRequest/"}]},{"title":"正则表达式练习题","date":"2018-05-01T06:31:39.761Z","path":"2018/05/01/cjqoyqt4j00j6hl6p8nx434ke/","text":"资源：HackerRank 正则练习Regexper 正则可视化面试中会遇到的正则题 正则表达式练习题匹配连续出现的四组以 . 连接的字符串题目：abc.dss.sds.wer 答案：/^(.{3}\\.){3}.{3}$/g 或者 ^(...\\.){3}...$ ^ 以什么作为开头 $ 以什么作为结尾 . 表示匹配任意字符 \\. 转义表示匹配 . 字符本身 匹配数字而非数字题目：xxXxxXxxxx 答案：/(\\d{2}\\D){2}\\d{4}/ \\d 表示匹配一个数字 \\D 表示匹配非数字字符 () 表示一个分组 {2} 表示重复匹配两次 匹配空白符题目： SSsSSsSS 答案：(\\S{2}\\s){2}\\S{2} \\S 表示非空白符（\\r\\n\\t\\f）都是空白符 \\s 表示空白符 匹配单词字符单词字符包括从 a-z A-Z 0-9 和 _ \\w 匹配单词字符 \\W 匹配非单词字符 边界匹配，以什么开始，以什么结束^\\d\\w{4}\\.$ 匹配以数字开头的一个字符，连续四个单词字符，以 . 结束的字符串 转换为驼峰命名var s1 = &quot;get-element-by-id&quot;; 给定这样一个连字符串，写一个function 转换为驼峰命名法形式的字符串 getElementById 12345678var s1 = 'get-element-by-id' // getElementByIdvar f = function(s) &#123; return s.replace(/-\\w+/g, function(x) &#123; console.log(x) return x.slice(1).toUpperCase() &#125;)&#125; 判断字符串是否包含数字12345var s1 = 'arhs 23jyfhahr 234 ag'var f = function(s = '') &#123; return /\\d/g.test(s)&#125; 判断电话号码12345var s1 = '13898762123'var f = function(s = '') &#123; return /^1[34578]\\d&#123;9&#125;$/g.test(s)&#125; 判断是否符合指定格式给定字符串 str，检查其是否符合如下格式XXX-XXX-XXXX，其中 X 为 Number 类型 12345var s1 = '234-234-2342'var f = function(s = '') &#123; return /^(\\d&#123;3&#125;-)&#123;2&#125;\\d&#123;4&#125;$/g.test(s)&#125; 判断是否符合 USD 格式给定字符串 str，检查其是否符合美元书写格式 以 $ 开始 整数部分，从个位起，满 3 个数字用 , 分隔 如果为小数，则小数部分长度为 2 正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3** 12345var s1 = '$1,023,032.03'var f = function(s = '') &#123; return /^\\$\\d&#123;1,3&#125;(,\\d&#123;3&#125;)*(\\.\\d&#123;2&#125;)?$/g.test(s)&#125; JS 实现千位分隔符1234function format(number) &#123; var regx = /\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g return (number + '').replace(regx, '$&amp;,') // $&amp;表示与regx相匹配的字符串&#125; 获取 url 中的参数 replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式,替换值可以是一个字符串或者一个每次匹配都要调用的函数。⚠️ 返回新的字符串，而原来的字符串不会被改变。如果第二个参数是个函数，那么函数的返回值将会替换字符串中匹配到的元素，如果第一个参数是个正则，且是全局匹配模式，那么该函数将会被多次调用，每次匹配到元素都会被执行。 replace() 参数： 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ')&#125;var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer)console.log(newString) // abc - 12345 - #$*% 1234567891011121314151617181920212223242526272829303132333435363738function getUrlParam(url, key) &#123; // 解析的结果以对象行使存放 var arr = &#123;&#125; /** * 字符串查找替换方法，可以传入字符串或者正则作为第一个参数 * * @param &#123;regexp&#125; 以等号连接的，前面可以有?开始，后面可以有&amp; 结束的 * @param &#123;any&#125; matchKey \b第一个圆括号匹配到的值，也就是参数等号左边的key * @param &#123;any&#125; matchValue 第而个圆括号匹配到的值，也就是参数等号右边的value * @returns 返回替换后的字符串，原有的字符串不会被改变 * */ url.replace(/\\??(\\w+)=(\\w+)&amp;?/g, function(match, matchKey, matchValue) &#123; if (!arr[matchKey]) &#123; arr[matchKey] = matchValue &#125; else &#123; // 如果参数存在重复，则连接两个参数的值，存放在一个数组中 var temp = arr[matchKey] arr[matchKey] = [].concat(temp, matchValue) &#125; &#125;) // 判断第二个参数key，绝对返回内容 if (!key) &#123; return arr &#125; else &#123; for (ele in arr) &#123; if ((ele = key)) &#123; return arr[ele] &#125; &#125; return '' &#125;&#125;var result = getUrlParam('www.baidu.com?name=234234&amp;age=age&amp;name=tt')console.log(result) 验证邮箱123456789101112// 'luoyecong@aliyun.com'// ? 最多一个// + 最少一个// * 零个或多个// 一个合法的邮箱地址有三部分组成，以 @ . 符号连接，每个部分需要符合 a-zA-z0-9_- 字符组成function isEmail(email = '') &#123; return /^([a-zA-Z\\d_-])+@([a-zA-Z\\d_-])+\\.([a-zA-Z\\d_-])+$/.test(email)&#125;console.log(isEmail('luo2\\3yec_-ong@ali23yun.com')) 验证合法身份证号123// 身份证号码可能为15位或18位，15位为全数字，18位中前17位为数字，最后一位为数字或者X;/(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/ 匹配汉字1var regx = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/ ⚠️ 这种匹配汉字的方法并不严谨，正确的方法是通过正则的底层提供的校验，但是需要 babel 的协助，还有汉字并不包括标点，具体请参看JavaScript 正则表达式匹配汉字 去除首尾的’/‘123// 以一个或者多个 / 开始或者以一个或者多个 / 结束的var str = '/asdf//'str = str.replace(/^\\/+|\\/+$/g, '') 判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式1var regx = /^\\d&#123;4&#125;\\-\\d&#123;1,2&#125;\\-\\d&#123;1,2&#125;$/ 判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）1var regx = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/ IPv4 地址正则1var regx = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ 十六进制颜色正则1var regx = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/ 车牌号正则1var regx = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/ 过滤 HTML 标签1234// 匹配一对&lt;&gt; 内不包括 &lt;&gt; 的var str = '&lt;p&gt;dasdsa&lt;/p&gt;nice &lt;br&gt; test&lt;/br&gt;'var regx = /&lt;[^&lt;&gt;]+&gt;/gstr = str.replace(regx, '') 密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符12// 连续使用前瞻，匹配多个符合要求的分组，在每个分组中，任意字符、字母、数字、特殊字符var regx = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/ URL 正则1var regx = /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/ 匹配标签内数据，包括标签12345// &lt;OPTION value=\"待处理\"&gt;待处理&lt;/OPTION&gt;// 写一个正则表达式,匹配 \"&lt;OPTION value=\"待处理\"&gt;\"var str = '&lt;OPTION value=\"待处理\"&gt;待处理&lt;/OPTION&gt;'var regx = /^&lt;.*?&gt;/var resiult = regx.exec(str)[0]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"正则","slug":"正则","permalink":"https://luoyec.cn/tags/正则/"}]},{"title":"JavaScript 类的继承","date":"2018-04-17T05:16:30.391Z","path":"2018/04/17/cjqoyqt4700i9hl6pmckahs7e/","text":"《JavaScript 设计模式》总结 JavaScript 类的继承 大体上，每个类由三部分组成，第一部分是构造函数内的，这是供实例化对象复制用的；第二部分是构造函数外的，直接通过点语法添加的，这是供类使用的，实例化对象是访问不到的；第三部分是类的原型中的，实例化对象可以通过其原型链间接地访问到，也是为供所有实例化对象所使用的。 类式继承123456789101112131415161718192021222324// 类式继承// 声明父类function SuperClass() &#123; this.superValue = true&#125;// 为父类添加共有方法SuperClass.prototype.getSuperVlaue = function() &#123; return this.superValue&#125;// 声明子类function SubClass() &#123; this.subValue = false&#125;// 继承父类SubClass.prototype = new SuperClass()//为子类添加共有方法SubClass.prototype.getSubValue = function() &#123; return this.subValue&#125; 新创建的对象复制了父类的构造函数内的属性与方法并且将原型 __proto__ 指向了父类的原型对象，这样就拥有了父类的原型对象上的属性和方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。 弊端 父类的共有属性要是引用类型，就会在子类中被所有实例共有，因此一个子类的实例更改子类型从父类构造函数中继承来的共有属性就会直接影响到其他子类 子类的实现的继承是靠其原型 prototype 对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因此在实例化父类的时候也无法对父类构造函数内的属性进行初始化 构造函数式继承（创建即继承）1234567891011121314151617181920212223// 声明父类function SuperClass(id) &#123; // 引用类型共有属性 this.books = [\"JavaScript\", \"html\", \"css\"] // 值类型共有属性 this.id = id&#125;// 父类声明原型方法SuperClass.prototype.showBooks = function() &#123; console.log(this.books)&#125;function SubClass(id) &#123; //继承父类 SuperClass.call(this, id)&#125;// 创建第一个子类的实例var instance1 = newSubClass(10)// 创建第二个子类的实例var instance2 = newSubClass(10) 分析SuperClass.call(this, id) 这是构造函数式继承的精华，由于 call 这个方法可以改变函数的作用域，因此在子类中，对 SuperClass 调用这个方法就是将子类的变量在父类中执行一遍，由于父类是给 this 绑定属性的，那么子类自然也就继承了父类的共有属性。 弊端这种继承方式没有涉及原型 prototype， 所以父类的原型方法自然不会被子类继承，而如果想要被子类继承就必须放在构造函数中，这样的创建方式的每个实例都会单独的拥有一份而不能共用，也就违背了代码复用的原则。 组合继承接上文，类式继承是通过子类原型的 prototype 对父类实例化来实现的，构造继承是通过在子类的构造函数作用环境中执行了一次父类的构造函数来实现的，组合继承整合这两点。 1234567891011121314151617181920function SuperClass(name) &#123; this.name = name //引用类型的共有属性 this.books = [\"JavaScript\", \"html\", \"css\"]&#125;// 父类原型共有方法SuperClass.prototype.getName = function() &#123; console.log(this.name)&#125;// 声明子类function SubClass(name, time) &#123; SuperClass.call(this, name) this.time = time&#125;// 类式继承 子类原型继承父类SubClass.prototype = new SuperClass()// 子类原型方法SubClass.prototype.getTime = function() &#123; console.log(this.name)&#125; 测试代码 弊端在使用构造函数继承是执行了一遍父类的构造函数，而在实现子类原型的类式继承又调用了一遍父类的构造函数，因此父类的构造函数调用了两遍。造成不必要的资源浪费。 原型式继承 借助原型 prototype 可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。 – 道格拉斯·克罗克福德 12345678910// 原型式继承function inheritObject(o) &#123; //声明一个过渡函数对象 function F () &#123; // 过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的一个实例，该实例的原型继承了父对象 reutrn new F() &#125;&#125; 寄生式继承12345678910111213141516//声明基对象var book = &#123; name : 'js book', alikeBook = ['css book', 'html book']&#125;function createBook(obj)&#123; // 通过原型继承方式创建对象 var o = new inheritObject(obj); o.getName = function () &#123; console.log(name); &#125; //返回扩展后的对象 return o;&#125; 寄生式继承其实就是对原型继承的二次封装，并且在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且添加新的属性和方法。 寄生组合式继承（目前最好的继承实现）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 解决2.4中组合继承问题： 在使用构造函数继承时执行了一遍父类的够赞方法，而在实例化子类的时候又执行了一遍父类的方法 * * 《JavaScript中原型式继承》：借助原型 prototype 已有的对象创建一个新的对象，同时不必创建新的自定义对象类型 *//** * 寄生组合继承 *//** * 上面的函数得到的对象F，拥有了对象o的全部属性（在原型链上），而修改F的属性，不会影响到o，相当于把o复制了一份。 * F 对象拥有父对象的所有方法（在原型链上） */function inheritObject(o) &#123; //生命一个过渡函数对象 function F() &#123;&#125; //过渡对象的原型式父对象 F.prototype = o //返回过渡对象的一个实例，该实例的原型继承了父对象 return new F()&#125;function inheritPrototype(subClass, superClass) &#123; // 复制一份父类的原型副本保存在变量中， 复制了父类原型的所有属性和方法 var p = inheritObject(SuperClass.prototype) //修正因为重写子类原型导致子类的 constructor 属性被修改 p.constructor = subClass //设置子类原型 subClass.prototype = p&#125;// 定义父类function SuperClass(name) &#123; this.name = name this.colors = [\"red\", \"black\"]&#125;//定义父类原型方法SuperClass.prototype.getName = function() &#123; console.log(this.name)&#125;// 定义子类function SubClass(name, time) &#123; //构造函数式继承 SuperClass.call(this, name) //子类新增属性 this.time = time&#125;//寄生式继承父类原型inheritPrototype(SubClass, SuperClass)//子类新增原型方法SubClass.prototype.getTime = function() &#123; console.log(this.name)&#125;// 创建两个测试方法var instance1 = new SubClass(\"js book\", 2014)var instance2 = new SubClass(\"css book\", 2013) 多继承123456789101112131415161718192021222324252627282930/** * JavaScript 实现多继承 */Object.prototype.mix = function() &#123; var i = 1, len = arguments.length, arg //遍历被继承的对象 for (; i &lt; len; i++) &#123; //缓存当前对象 arg = arguments[i] for (var property in arg) &#123; this[property] = arg[property] &#125; &#125;&#125;var book = &#123; name: \"JavaScript\", alike: [\"css\", \"js\"]&#125;var anotherBook = &#123; color: \"red\"&#125;var newBook = &#123;&#125;newBook.mix(newBook, anotherBook, book) 多态 ES6 class 实现继承class 声明创建一个基于原型继承的具有给定名称的新类。 你也可以使用类表达式定义类。但是不同于类表达式，类声明不允许再次声明已经存在的类，否则将会抛出一个类型错误。 123456789101112131415161718class SuperClass &#123; constructor(width, height) &#123; this.width = width this.height = height this.area = width * height &#125;&#125;class SubClass extends SuperClass &#123; constructor(length) &#123; super(length, length) this.title = \"hh\" &#125;&#125;var subclass = new SubClass(12)console.log(subclass.area)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"类","slug":"类","permalink":"https://luoyec.cn/tags/类/"},{"name":"继承","slug":"继承","permalink":"https://luoyec.cn/tags/继承/"}]},{"title":"JavaScript 类的封装","date":"2018-04-15T13:51:01.501Z","path":"2018/04/15/cjqoyqsyd001jhl6pyedxhrds/","text":"参考：js 如何创建类（封装）Class 的基本语法《JavaScript 设计模式》 JavaScript 类的封装在 JavaScript 中，类的实现是基于原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。 如果两个对象继承自同一个原型，往往意味着它们是由同一个构造函数创建并初始化的。 类的创建在 JavaScript 中创建一个类很容易，声明一个函数保存在一个变量中，在这个函数内部使用this 添加属性或者方法。 也可以通过在类的原型对象上添加属性和方法。 ⁉️ 通过 prototype 和 this 添加属性和方法有什么区别？通过 this 是在当前对手上添加的，每次对象被创建时这些方法和属性都会被重复创建；而通过 prototype 继承的方法不是对象自身的，所以当使用这些方法和属性时，会通过 prototype 一级一级想上查找（原型链），所有不会被重复创建（但是原型上的属性被修改是，所有继承该原型的对象都会被影响）。 ⁉️ 什么是 constructor ？这是一个属性，当创建一个函数或对象时都会为期创建一个原型对象 prototype， 在 prototype 对象中又会创建一个 constructor 属性，那么 constructor 属性指向的就是拥有整个原型对象的函数或者对象。 属性和方法的封装利用 JavaScript 的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建私有变量和私有方法。 思考 new 运算符原理，通过 new 实例化对象时，构造函数执行，this 执行新创建的对象。 类通过 prototype 创建的属性或者方法在类的实例对象是可以通过 this 访问的。 再进一步，利用闭包进行封装 闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另一个函数。我们将这个闭包作为创建对象的构造函数，在闭包内部返回一个完整的类。 1234567891011121314151617181920212223var Book1 = (function() &#123; var bookNum = 0 function checkBook(name) &#123;&#125; function _book(newID, newName, newPrice) &#123; var name, price function checkID(id) &#123;&#125; this.getName = function() &#123; name &#125; &#125; //直接构建原型 _book.prototype = &#123; isJSBook: true &#125; // 记得要返回该对象，否则会 “is not a constructor” return _book&#125;)()var book1 = new Book1() 创建对象的安全模式 当忘记写 new 运算符时，是对象的直接复制，对象内部的 this 指向的是全局对象window，使用 instanceof 运算符判断当前 this，在使用闭包的封装中，是不会有整个问题的，其属性和方法都被限定在函数内部的作用域中。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"类","slug":"类","permalink":"https://luoyec.cn/tags/类/"},{"name":"继承","slug":"继承","permalink":"https://luoyec.cn/tags/继承/"}]},{"title":"JavaScript 基本数据类型-对象","date":"2018-04-14T19:03:40.058Z","path":"2018/04/15/cjqoyqsy70016hl6pr2zdusp2/","text":"JavaScript 基本数据类型-对象对象是 JavaScript 的基本数据类型，对象可以看做是属性的无序集合。对象不仅仅是字符串到值的映射，除了保持自身的属性，JavaScript 对象还可从一个称谓原型的对象中继承属性。对象的方法通常是继承的属性。这种“原型式继承”是 JavaScript 的核心特征。 对象的常见方法： 创建 create 设置 set 查找 query 删除 delete 检测 test 枚举 enumerate 创建对象对象字面量创建对象最简单的方式就是使用对象字面量（直接量） 123456var empty = &#123;&#125;var point = &#123; x: 0, y: 0 &#125;var book = &#123; \"min title\": \"JavaScript\", //属性名字有空格、连接符（-），必须要用字符串表示 for: \"all audiences\" // for 是保留字，必须用引号&#125; 对象字面量是一个表达式，每次运算都会创建并初始化一个新的对象。这就意味着，如果在一个重复调用的函数的循环内使用了对象字面量，它将创建很多对象，并且每次创建的对象的属性值都有可能不同。 通过 new 创建对象new 运算符创建并初始化一个对象。new 后跟随一个函数调用，这个函数被称为构造函数（constructor），构造函数用以初始化一个新创建的对象。 JavaScript 的原始类型都包含内置构造函数， 1234var o = new Object()var a = new Arrya()var d = new Date()var r = new RegExp(\"js\") 原型每一个 JavaScript 对象（null 除外）都和另一个对象相关联。 所有通过对象字面量创建的对象，原型都指向 Object.prototype (obj.__proto__ === Object.prototype)，通过 new 关键字创建的对象，其原型就是构造函数的 prototype 属性的值。 Object.create()ES6 中新增的方法，它创建一个新对象，其中第一个采纳数是这个对象原型。 Object.create() 提供第二个参数，用以对对象的属性进行进一步描述。 创建一个空对象，（例如和 {}、new Object() 一样） ，需要传入 Object.prototype 1var o3 = Object.create(Object.prototype) 使用该方法，可以使得任意对象得以被继承，这是一个强大的特性。 属性的查询和设置查询可以通过 . 或者方括号 []（必须是一个计算结果为字符串的表达式） 运算符来获取属性的值。 属性访问错误查询一个不存在属性并不会报错，会返回 undefined，但是如果对象不存在，那么使用查询这个不存对象的属性就会报错，null 和 undefined 都没有属性值，查询时均会报错。 利用 &amp;&amp; 运算符的短路行为，可以解决这个问题。 1var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length 删除属性delete 运算符可以删除对象属性，但是只能删除自身属性，不能删除继承属性。（要删除继承属性，必须要定义这个属性的原型对象上删除它，但这回影响到所有继承这个原型的对象）。 delete 不能删除可配置属性为 false 的属性。 检测属性 in 运算符，如果对象自有属性或继承属性中包含这个属性则返回 truejavascript var o = {x: 1} &#39;x&#39; in o // true &#39;toString&#39; in o hasOwnProperty()， 用来检测给定的名字是否是对象自有的属性，继承属性将返回 falsejavascript o.hasOwnProperty(&#39;x&#39;) true o.hasOwnProperty(&#39;toString&#39;) false propertyIsEnumerable()，是 hasOwnProperty() 的增强版，检测自有属性并且该属性是可枚举的 - 通过代码增加的属性都是可枚举的，除非手动修改属性的可枚举性 使用 !== 判断 - 判断属性是否为 undefined，可用于自有属性和继承属性 - 当属性值位 undefined 时，则这种方法失效 序列化对象对象序列化是指将对象的状态转换成字符串，使用 JSON.stringify() 和 JSON.parse() 进行序列化和还原 JavaScript对 对象。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"对象","slug":"对象","permalink":"https://luoyec.cn/tags/对象/"},{"name":"Object","slug":"Object","permalink":"https://luoyec.cn/tags/Object/"}]},{"title":"JavaScript 原型及原型链","date":"2018-04-14T08:15:53.601Z","path":"2018/04/14/cjqoyqsy40011hl6pkovlgmiz/","text":"参考：MollyPages.orgjavascript 原型链继承JavaScript：constructor 属性 JavaScript 原型及原型链 原型的基本概念 所有的实例都继承自创建他们的构造函数的 prototype 对象 实例拥有一个特殊的实现 __proto__指针，它指向创建者的 prototype 对象 无论是否存在 __proto__，所有的函数都存在 prototype 对象，它拥有一个 constructor 属性指向函数自身，这个属性是只读的。 constructor 属性始终指向创建当前对象的构造函数 12345var M = new Function() &#123;this.name = 'name'&#125;;var m = new M;M.constructor === Function // truem.constructor === M //true 所有对象的原型最终都会指向 Object 对象的原型 123456function Foo()&#123;&#125;;var foo=new Foo();console.log(foo.__proto__); //指向Foo构造函数的原型console.log(foo.__proto__.__proto__); //指向Object构造函数的原型console.log(foo.__proto__.__proto__.__proto__); //null instanceof 的原理instanceof 检测一个对象 A 是不是另一个对象 B 的实例的原理是：查看对象B的prototype 指向的对象是否在对象 A 的 [[prototype]] 链上。如果在，则返回 true ,如果不在则返回 false。不过有一个特殊的情况，当对象 B 的 prototype 为 null 将会报错(类似于空指针异常)。 new 运算符的原理1234var M = function() &#123; this.name = \"M\"&#125;var m = new M() 创建一个对象 m，它继承自 M.prototype 构造函数 M 会被执行，执行的时候，可以传递参数。同时上下文 this，执行新创建的对象 m 如果构造函数 m 返回了一个对象，那么 new 的结果将会是这个对象，而不是对象 m","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"https://luoyec.cn/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"https://luoyec.cn/tags/原型链/"}]},{"title":"前端跨域通信原理及示例","date":"2018-04-14T04:45:50.875Z","path":"2018/04/14/cjqoyqt0u0069hl6pkdlqczsw/","text":"参考资源：前端跨域通信的几种方式 前端跨域通信原理及示例同源策略及限制同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 所谓同源是指：域名，协议，端口 相同。 cookie,localstorage，dom 没办法相互获取 ，ajax 请求也不能 前后端的通信方式 Ajax - 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新 - 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 - 同源下使用的通信方式 WebSocket - 不限制同源策略 - 基于 TCP 的一种新的网络协议 - 实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 CORS - 支持跨域通信也支持同源通信 - CORS 机制让 web 服务器能跨站访问控制 - 简单请求 - 浏览器直接发送 CORS 跨域请求，并在 header 信息中增加一个 Origin 字段，表明这是一个跨域的请求。 - 非简单请求 - 在正式通信前进行一次 Http 查询请求，又称预检请求 跨域通信 JSONP HASH postMessage WebSocket CORS JSONP跨域原理 利用 &lt;script src=””&gt;&lt;/script&gt; 中的 src 的地址可以跨域，动态的构造 script 标签，以实现跨域数据访问。 前端通过 script 标签以发送请求， 1&lt;scirpt src=&quot;http://www.abc.com/?data=name&amp;callback=callback_fn&quot; charset=&quot;utf-8&quot;&gt;&lt;/scirpt&gt; 服务端返回的也是 script 标签，callback 就是方法名 1234function callback_fn(data) &#123; console.log(\"callback_fn\") console.log(data)&#125; 完整的 jsonp 封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * [function 获取一个随机的5位字符串] * @param &#123;[type]&#125; prefix [description] * @return &#123;[type]&#125; [description] */util.getName = function(prefix) &#123; return ( prefix + Math.random() .toString(36) .replace(/[^a-z]+/g, \"\") .substr(0, 5) )&#125;/** * [function 判断是否为函数] * @param &#123;[type]&#125; source [description] * @return &#123;[type]&#125; [description] */util.isFunction = function(source) &#123; return \"[object Function]\" === Object.prototype.toString.call(source)&#125;/** * [function jsonp] * @param &#123;[type]&#125; url [请求地址] * @param &#123;[type]&#125; onsucess [成功的回调] * @param &#123;[type]&#125; onerror [错误处理方法] * @param &#123;[type]&#125; charset [字符集] * @return &#123;[type]&#125; [description] */util.jsonp = function(url, onsuccess, onerror, charset) &#123; var callbackName = util.getName(\"tt_player\") window[callbackName] = function() &#123; if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123; onsuccess(arguments[0]) &#125; &#125; var script = util.createScript(url + \"&amp;callback=\" + callbackName, charset) script.onload = script.onreadystatechange = function() &#123; if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script) &#125; // 删除函数或变量 window[callbackName] = null &#125; &#125; script.onerror = function() &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror() &#125; &#125; document.getElementsByTagName(\"head\")[0].appendChild(script)&#125; Hashurl 的 # 后面的内容就叫 Hash。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。 补充：url 的 ? 后面的内容叫 Search。Search 的改变，会导致页面刷新，因此不能做跨域通信。 使用举例： 场景：我的页面 A 通过 iframe 或 frame 嵌入了跨域的页面 B。 现在，我这个 A 页面想给 B 页面发消息，怎么操作呢？ （1）首先，在我的 A 页面中： 123//伪代码var B = document.getElementsByTagName(\"iframe\")B.src = B.src + \"#\" + \"jsonString\" //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B （2）然后，在 B 页面中： 12345// B中的伪代码window.onhashchange = function() &#123; //通过onhashchange方法监听，url中的 hash 是否发生变化 var data = window.location.hash&#125; postMessage()方法H5 中新增的 postMessage() 方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。 场景：窗口 A (http:A.com) 向跨域的窗口 B (http:B.com)发送信息。步骤如下。 （1）在 A 窗口中操作如下：向 B 窗口发送数据： 12// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息Bwindow.postMessage(\"data\", \"http://B.com\") //这里强调的是B窗口里的window对象 WebSocketWebSocket 的用法如下： 123456789101112131415161718var ws = new WebSocket(\"wss://echo.websocket.org\") //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。//把请求发出去ws.onopen = function(evt) &#123; console.log(\"Connection open ...\") ws.send(\"Hello WebSockets!\")&#125;//对方发消息过来时，我接收ws.onmessage = function(evt) &#123; console.log(\"Received Message: \", evt.data) ws.close()&#125;//关闭连接ws.onclose = function(evt) &#123; console.log(\"Connection closed.\")&#125; （2）在 B 窗口中操作如下： 1234567891011// 在窗口B中监听 message 事件Awindow.addEventListener( \"message\", function(event) &#123; //这里强调的是A窗口里的window对象 console.log(event.origin) //获取 ：url。这里指：http://A.com console.log(event.source) //获取：A window对象 console.log(event.data) //获取传过来的数据 &#125;, false) CORSCORS 可以理解成是既可以同步、也可以异步*的 Ajax。 fetch 是一个比较新的 API，用来实现 CORS 通信。用法如下： 12345678910// url（必选），options（可选）fetch(\"/some/url/\", &#123; method: \"get\"&#125;) .then(function(response) &#123; //类似于 ES6中的promise &#125;) .catch(function(err) &#123; // 出错了，等价于 then 的第二个参数，但这样更好用更直观 &#125;) CORS 为什么能实现跨域通信？浏览器会拦截 Ajax，如果Ajax 是跨域的，会在 Http头部增加 origin CORS 和 JSONP 比较CORS 和 JSONP 都是为了使 web 浏览器能够跨源请求，使用目的相同，但是比 JSONP 更强大。JSONP 只支持GET 请求，而 CORS 支持所有类型的 HTTP 请求，不过JSONP 的优势在于支持老式浏览器以及可以向不支持 CORS 的网站跨源请求。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"http","slug":"http","permalink":"https://luoyec.cn/tags/http/"},{"name":"跨域","slug":"跨域","permalink":"https://luoyec.cn/tags/跨域/"}]},{"title":"XMLHttpRequest请求","date":"2018-04-13T15:38:53.944Z","path":"2018/04/13/cjqoyqszs004dhl6pwwdhpr5t/","text":"XMLHttpRequest 请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * [json 实现ajax的json] * @param &#123;[type]&#125; options [description] * @return &#123;[type]&#125; [description] */util.json = function(options) &#123; var opt = &#123; url: \"\", type: \"get\", data: &#123;&#125;, success: function() &#123;&#125;, error: function() &#123;&#125; &#125; util.extend(opt, options) if (opt.url) &#123; var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\") var data = opt.data, url = opt.url, type = opt.type.toUpperCase(), dataArr = [] for (var k in data) &#123; // 将ke-value的数据转成数组存放 dataArr.push(k + \"=\" + data[k]) &#125; if (type === \"GET\") &#123; url = url + \"?\" + dataArr.join(\"&amp;\") // 删除以问号结尾的问号 xhr.open(type, url.replace(/\\?$/g, \"\"), true) xhr.send() &#125; if (type === \"POST\") &#123; xhr.open(type, url, true) // \b设置请求头部 xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\") xhr.send(dataArr.join(\"&amp;\")) &#125; xhr.onload = function() &#123; // 304 客户端可从缓存中获取数据，还可以增加 206 视频等媒体资源加载时用 if (xhr.status === 200 || xhr.status === 304) &#123; var res if (opt.success &amp;&amp; opt.success instanceof Function) &#123; res = xhr.responseText if (typeof res === \"string\") &#123; res = JSON.parse(res) opt.success.call(xhr, res) &#125; &#125; &#125; else &#123; if (opt.error &amp;&amp; opt.error instanceof Function) &#123; opt.error.call(xhr, res) &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"http","slug":"http","permalink":"https://luoyec.cn/tags/http/"}]},{"title":"React 服务端渲染理论","date":"2018-04-05T07:09:31.232Z","path":"2018/04/05/cjqoyqszc003mhl6p0l0yvwro/","text":"资源列表：Git仓库: koa2-react-isomorphic-boilerplateWebpack工程化解决方案easywebpackEgg + React + React Router ＋ Redux 服务端渲染实践Egg + React 服务端渲染开发指南服务端渲染与 Universal React AppReact服务器端渲染实践小结 React 服务端渲染理论相关的知识点： 了解服务端渲染解决的问题 了解服务端渲染的基本原理 使用现有框架实现服务端渲染 进阶，dva+egg框架实现服务端渲染 进行性能测试 客户端渲染、服务端渲染、同构的区别 客户端渲染：页面在 JavaScript，CSS 等资源文件加载完毕后开始渲染，路由为客户端路由，也就是我们经常谈到的 SPA（Single Page Application）。 服务端渲染：页面由服务端直接返回给浏览器，路由为服务端路由，URL 的变更会刷新页面，原理与 ASP，PHP 等传统后端框架类似。 同构：英文表述为 Isomorphic 或 Universal，即编写的 JavaScript 代码可同时运行在浏览器及 Node.js 两套环境中，用服务端渲染来提升首屏的加载速度，首屏之后的路由由客户端控制，即在用户到达首屏后，整个应用仍是一个 SPA。 总的架构 服务端预先获取编译好的客户端代码及其他资源。 服务端接收到用户的 HTTP 请求后，触发服务端的路由分发，将当前请求送至服务端渲染模块处理。 服务端渲染模块根据当前请求的 URL 初始化 memory history 及 redux store。 根据路由获取渲染当前页面所需要的异步请求（thunk）并获取数据。 调用 renderToString 方法渲染 HTML 内容并将初始化完毕的 redux store 塞入 HTML 中，供客户端渲染时使用。 客户端收到服务端返回的已渲染完毕的 HTML 内容并开始同步加载客户端 JavaScript，CSS，图片等其他资源。 之后的流程与客户端渲染完全相同，客户端初始化 redux store，路由找到当前页面的组件，触发组件的生命周期函数，再次获取数据。唯一不同的是 redux store 的初始状态将由服务端在 HTML 中塞入的数据提供，以保证客户端渲染时可以得到与服务端渲染相同的结果。受益于 Virtual DOM 的 diff 算法，这里并不会触发一次冗余的客户端渲染。 为什么要采用服务端渲染？ 利于 SEO 加速首屏渲染速度 享受 React 组件式开发的优势：高复用、低耦合 前后端维护一套代码（代码同构）","categories":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/tags/React/"},{"name":"rss","slug":"rss","permalink":"https://luoyec.cn/tags/rss/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"https://luoyec.cn/tags/服务端渲染/"}]},{"title":"JavaScript 正则表达式","date":"2018-03-31T03:02:24.965Z","path":"2018/03/31/cjqoyqsy90018hl6pmb18rjzv/","text":"参考资源：慕课网 JavaScript 正则表达式正则表达式的可视化开源工具 JavaScript 正则表达式REGEXP 对象JavaScript 通过内置对象 RegExp 支持正则表达式，有两种方法实例化 RegExp 对象 字面量 构造函数 字面量 1var reg = /\\bis\\b/g 构造函数 1var reg = new RegExp(\"\\\\bis\\\\b\", \"g\") 修饰符 g：global 全文搜索，不添加则搜索到第一个匹配停止i：ignore case 忽略大小写，默认大小写敏感m：multiple lines 多行搜索 元字符正则表达式由两种基本字符类型组成 原义文本字符如字母 a，表示的就是小写英文字母 a 元字符元字符是在正则表达式中有特殊含义的非字母字符* + ? $ ^ . | \\ ( ) { } [ ] 字符类 一般情况下正则表达式一个字符对应字符串一个字符 表达式 ab\\t 的含义就是 有时候需要匹配某一类字符 我们可以使用元字符 [] 来构建一个简单的类 所谓类是指符合某些特性的对象，一个泛指，而不是特质某个字符 表达式 [abc] 把字符 a 或 b 或 c 归为一类，表达式可以匹配这类的字符 字符类取反 使用元字符 ^ 创建 反向类/负向类 反向类的意思是不属于某类的内容 表达式 [^abc] 表示不是字符 a 或 b 或 c 的内容 范围类 我们可以使用 [a-z] 来连接两个字符，表示从 a 到 z 的任意字符 这是个闭区间，也就是包含 a 和 z 本身 在 [] 组成的类内部是可以连写的 [a-zA-Z] 预定义类正则表达式提供预定义类来匹配常见的字符类 边界常用边界匹配字符 量词希望匹配一个连续出现 20 次数字的字符串 贪婪模式正则尽可能的匹配，例如匹配 3-6 个数字，\\d{3,6}，在一串数字中，例如 12345678 ，匹配的结果为 123456 非贪婪模式让正则尽可能少的匹配，也就是说一旦匹配成功不再继续尝试就是非贪婪模式，直接在量词后加上 ？ 即可，例如 12\"123253253455\".match(/\\d&#123;3,6&#125;?/g)// [\"123\", \"253\", \"253\", \"455\"] 分组使用 ( ) 可以达到分组的功能，使量词作用域分组，例如 (lyctea){3} 或用 | 表示或，例如 lyctea|luoyecong luoye(c|cong) 反向引用例如将用 - 连接的日期，转成 / 表示的日期格式 12\"2017-03-30\".replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g, \"$2/$3/$1\")// \"03/30/2017\" 忽略分组不希望捕获某些分组，只需要在分组内加上 ? : 就可以 (?:Byron).(ok) 前瞻 正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“前” 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言；后顾/后瞻方向相反 JavaScript 不支持后顾 符合和不符合特定断言成为 肯定/正向 匹配和 否定/负向 匹配 语法（规则+断言） 例子： 123456789// 匹配前面是单词或数字，后面是数字\"x3*33vV\".replace(/\\w(?=\\d)/g, '_')；// \"_3*_3vV\"// 匹配前面是单词或数字，后面不是数字\"x3*33vV\".replace(/\\w(?!\\d)/g, '_')；\"x_*3___\" JS 对象属性 test 和 exec 方法RegExp.prototype.test() test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。 lastIndex：当前匹配结果的最后一个字符的下一个字符（使用 test() 会分段匹配，可能会执行多次，当全文匹配完毕时，会从头匹配） RegExp.prototype.exec()exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 如果你只是为了判断是否匹配（true或 false），可以使用 RegExp.test() 方法，或者 String.search() 方法。 字符串方法中的正则String.prototype.search()search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。 String.prototype.match()当一个字符串与一个正则表达式匹配时， match() 方法检索匹配项。 String.prototype.replace()replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。 ⚠️ 注意：原字符串不会改变。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"https://luoyec.cn/tags/RegExp/"},{"name":"正则","slug":"正则","permalink":"https://luoyec.cn/tags/正则/"}]},{"title":"浏览器存储、HTTP缓存、SSR","date":"2018-03-24T14:32:19.000Z","path":"2018/03/24/cjqoyqt180075hl6p37n9rbfd/","text":"参考资源：HTTP 缓存 MDN服务端渲染与 Universal React App 浏览器存储Cookie HTTP 请求是无状态的，一次连接关闭，使用 Cookie去维持客户端状态，维护用户的登录信息。服务端可以判断这个请求是来自哪个客户端。 总结两点功能： 用于浏览器端和服务器端的交互 客户端自身数据的存储 Cookie 存储的限制： 作为浏览器存储，大小 4kb 左右（存储数据能力被localstorage 替代） 需要设置过期时间 expire httponly：当前这个 Cookie 只能用户 http 传输，而不能用 js 进行读写 Cookie中在相关域名下面 – CND 的流量损耗 - 在同一个域名下的所有请求，都会携带请求 CDN 的域名和主站的域名要分开 LocalStorage HTML5 设计专门用来浏览器存储的 大小为 5MB 左右 尽在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 SessionStorage 会话级别的浏览器存储 大小为 5MB 左右 尽在客户端使用，不和服务端进行通信 接口封装较好 对于表单信息的维护 IndexDBIndexDB 是一种低级 API，用于客户端存储大量结构化数据。该 API 使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于储存较少的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexDB 提供了解决方案。 为应用创建离线版本。 Service Workers 产生的意义 Service workers本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 Service workers是一个脚本。浏览器独立与当前网页，将其在后台运行，为实现一些不依 赖页面或者用户交互的特性打开了一扇大门，在未来这些特性将包括推送消息，背景后台同步，geofencing（地理围栏定位），但他将退出的第一个首要特性，就是拦截和处理网络请求的能力，包括变成方式来管理被缓存的响应。 使用拦截网络请求的能力，可以实现离线应用。 PWAPWA（Progressive Web APPs） 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写就能看出来，这事一个渐进式的 WebApp ，是通过一系列新的 Web 特性。配合优秀的 UI 交互设计，逐步的增强 Web APP 的用户体验。 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现 “未连接到互联网”的页面。 快速：针对网页渲染及网路数据访问有较好的优化。 融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。 ⚠️ lighthouse：chorm 扩展插件，检查网站性能，SEO 等 HTTP 缓存 重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。 Server Side Rendering","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://luoyec.cn/categories/前端性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://luoyec.cn/tags/性能优化/"},{"name":"离线存储","slug":"离线存储","permalink":"https://luoyec.cn/tags/离线存储/"}]},{"title":"懒加载与预加载，重绘与回流","date":"2018-03-23T16:40:34.000Z","path":"2018/03/24/cjqoyqt10006nhl6p5rx72x5l/","text":"懒加载与预加载懒加载 图片进入可视区域之后请求图片资源 - 进入可视区域之后修改 src 属性 UI 与电商等图片资源很多，页面很长的业务场景使用 减少无效资源的加载 并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用 实现方式：需要去监听 scroll 事件，在 scrool 滚动事件的回调中 预加载 图片等静态资源在使用之前的提前请求 资源使用时能从缓存中加载，提升用户体验 页面展示的依赖关系维护 实现方式： 使用 XMLHttpRequest 对象 使用 Image 对象 使用 preload.js 库 重绘与回流 理解浏览器重绘与回流的机制 对于一些经典的案例进行分析 重绘与回流的案例实战 css 性能会让 JavaScript 变慢？在加载 css 的时候，js 的执行被阻塞，在 js 中执行的时候，页面的渲染也是被阻塞的。 频繁触发重绘与回流，会导致 UI 频繁渲染，最终导致 js 执行效率。 回流 当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏改变而需要重新构建，这就成为回流（reflow） 当页面布局和几何属性改变时就需要回流 重绘当 render tree 的一些元素需要更新属性，二者属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color 。则成为重绘。 综上，回流一定会触发重绘，重绘不一定会触发回流。 触发页面重新布局的属性 盒子模型相关属性会触 定位属性及浮动也会触发 改变节点内部文字结构 将频发重绘回流的 DOM 元素单独作为一个独立图层，那么这个 DOM 元素的重绘和回流的影响只会在这个图层中。 Chrome 创建图层的条件： 3D 或透视变换 CSS 属性（perspective transform） 使用加速视频解码的 video 节点 拥有 3D （WebGL） 上下文或加速的 2D 上下文的 canvas 节点 混合插件（如 Flash） 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素 拥有加速 CSS 过滤器的元素 元素有一个包含复合层的后代节点 元素由一个 z-index 较低且包含一个复合层的兄弟元素 优化策略 避免使用触发重绘、回流的 CSS 属性 将重绘、 回流的影响返回限制在单独的图层之内","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://luoyec.cn/categories/前端性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://luoyec.cn/tags/性能优化/"},{"name":"懒加载，预加载","slug":"懒加载，预加载","permalink":"https://luoyec.cn/tags/懒加载，预加载/"}]},{"title":"资源合并与压缩","date":"2018-03-23T05:31:52.000Z","path":"2018/03/23/cjqoyqt1o0089hl6ps0nwyky2/","text":"参考资料：[什么是 CDN–阿里云][1] 理解减少 HTTP 请求数量和减少请求资源大小的两个优化点 掌握压缩与合并的原理 掌握通过在线网站和 fis3 两种实现压缩的与合并的方法 HTTP 请求过程及潜在的性能优化点❓ 浏览器的一个请求从发送到返回都经历了什么？ ❓ DNS 是否可用通过魂村减少 DNS 查询时间 ❓ 网络请求的过程走最近的网络环境？ ❓ 相同的静态资源是否可用缓存 ❓ 是否减少请求 HTTP 请求大小？ ❓ 减少 HTTP 请求 ❓ 服务端渲染 Google 首页案例学习 HTML 压缩 CSS 压缩 JS 的压缩和混淆 文件合并 开启 gzip HTML 压缩HTML 代码压缩就是压缩这些在文本文件中有意义，但是在 HTML 中不显示的字符，包括空格、制表符、换行符等，还有一些其他有意义的字符，如 HTML 注释也可以压缩。 压缩的方法： 使用在线网站进行压缩 nodejs 提供了 html-minifier 工具 后端模板引擎渲染压缩 CSS 压缩 无效代码删除 css 语义合并 压缩的方法： 使用在线网站进行压缩 nodejs 提供了 html-minifier 工具 使用 clean-css JS 的压缩和混淆 无效字符的删除 剔除注释 代码语义的缩减和优化 代码保护 压缩的方法： 使用在线网站进行压缩 nodejs 提供了 html-minifier 工具 使用 uglifyjs2 文件合并![][2] 文件合并的弊端： 首屏渲染问题 缓存失效问题 - 增加 MD5 戳，用来标识文件是否更改 - 采用文件合并会存在大面积缓存失效 文件合并的策略： 公共库合并 不同页面的合并 - 单页应用被路由到的时候才去请求 JS 见机行事，随机应变 合并的方法： 使用在线网站进行合并 使用 nodejs 实现文件合并 [1]: https://help.aliyun.com/document_detail/27101.html?spm=a2c4g.11174283.2.3.85hgy4[2]: http://oudfgqwcq.bkt.clouddn.com/lyctea/1521771263712.jpg","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://luoyec.cn/categories/前端性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://luoyec.cn/tags/性能优化/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://luoyec.cn/tags/文件压缩/"}]},{"title":"JavaScript 迭代器与生成器","date":"2018-03-21T08:58:44.000Z","path":"2018/03/21/cjqoyqsyc001ghl6pphswoazs/","text":"JavaScript 迭代器与生成器迭代器迭代器是一种检查容器内元素并遍历元素的数据类型。 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。 生成器生成器( generator )是能返回一个迭代器的函数。 生成器函数由放在 function 关键字之 后的一个星号( * )来表示，并能使用新的 yield 关键字。 123456789101112131415161718192021/* 在循环内遇到yield就会停止，指定再次调用next方法，将会在上次停止的位置继续执行*/function* createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125;&#125;let iterator = createIterator([1, 2, 3])console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())// 之后的所有调用console.log(iterator.next())// \"&#123; value: 1, done: false &#125;\"// \"&#123; value: 2, done: false &#125;\"// \"&#123; value: 3, done: false &#125;\"// \"&#123; value: undefined, done: true &#125;\"// \"&#123; value: undefined, done: true &#125;\" 关于生成器的几点注意事项： 使用函数表达式来创建一个生成器，只要在 function 关键字与圆括号之间使用一个星号( * ) 由于生成器就是函数，因此也可以被添加到对象中，下列两种方法是等价的。 1234567891011121314151617var o = &#123; createIterator: function*(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125; &#125;&#125;var o = &#123; *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i] &#125; &#125;&#125;let iterator = o.createIterator([1, 2, 3]) 不能将箭头函数创建为生成器 可迭代对象与 for-of 循环与迭代器紧密相关的是，可迭代对象( iterable )是包含 Symbol.iterator 属性的对象。这 个 Symbol.iterator 知名符号定义了为指定对象返回迭代器的函数。 12345let values = [1, 2, 3, &#123;&#125;, null, undefined]for (const value of values) &#123; console.log(value)&#125; 访问默认迭代器你可以使用 Symbol.iterator 来访问对象上的默认迭代器，就像这样: 12345678910let values = [1, 2, 3]let iterator = values[Symbol.iterator]()console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())console.log(iterator.next())// \"&#123; value: 1, done: false &#125;\"// \"&#123; value: 2, done: false &#125;\"// \"&#123; value: 3, done: false &#125;\"// \"&#123; value: undefined, done: true &#125;\" 检查一个对象是否能够进行迭代 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === \"function\"&#125;console.log(isIterable([1, 2, 3]))console.log(isIterable(\"Hello\"))console.log(isIterable(new Map()))console.log(isIterable(new Set()))console.log(isIterable(new WeakMap())) // falseconsole.log(isIterable(new WeakSet())) // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"迭代器","slug":"迭代器","permalink":"https://luoyec.cn/tags/迭代器/"},{"name":"生成器","slug":"生成器","permalink":"https://luoyec.cn/tags/生成器/"}]},{"title":"JavaScript 递归上","date":"2018-03-08T01:01:16.000Z","path":"2018/03/08/cjqoyqsyg001phl6pico6iovv/","text":"参考资料：翻译连载 | 第 9 章：递归（上）－《JavaScript轻量级函数式编程》 |《你不知道的JS》姊妹篇 JavaScript 递归上定义所谓递归，是当一个函数调用自身，并且该调用做了同样的事情，这个循环持续到基本条件满足时，调用循环返回。 ⚠️ 警告： 如果你不能确保基本条件是递归的 终结者，递归将会一直执行下去，并且会把你的项目损坏或锁死；恰当的基本条件十分重要！ 直接递归 当一个函数调用自身时，很明显，这叫作直接递归 简单的函数递归123456function foo(x) &#123; if (x &lt; 5) return x; return foo(x / 2);&#125;console.log(foo(16)); 求质数1234567891011121314151617181920212223242526/** * * 判断一个数是否是质数： * 从2到 num 的平方根之间的每个整数，看是否存在某一整数可以整除 num (% 求余结果为 0)。 * 如果存在这样的整数，那么 num 不是质数。反之，是质数。 * * @param &#123;number&#125; num 被判断是否是质数 * @param &#123;number&#125; divisor */function isPrime(num, divisor = 2) &#123; // 出口，非质数 if (num &lt; 2 || (num &gt; 2 &amp;&amp; num % divisor == 0)) &#123; return false; &#125; // 入口，递归的条件 if (divisor &lt;= Math.sqrt(num)) &#123; return isPrime(num, divisor + 1); &#125; // 出口，质数 return true;&#125;console.log(isPrime(40)); 斐波那契数1234fib( 0 ): 0fib( 1 ): 1fib( n ): fib( n - 2 ) + fib( n - 1 ) 1234567function fib(n) &#123; // 出口，当n小于等于1时，结束递归 if (n &lt;= 1) return n; // 不满足，出口条件 ，持续递归 return fib(n - 2) + fib(n - 1);&#125; 相互递归 如果在一个递归循环中，出现两个及以上的函数相互调用，则称之为相互递归。 求奇数偶数1234567891011function isOdd(v) &#123; if (v === 0) return false; return isEven(Math.abs(v) - 1);&#125;function isEven(v) &#123; if (v === 0) return true; return isOdd(Math.abs(v) - 1);&#125;console.log(isEven(31)); 简单迭代改为递归12345678910111213141516171819202122232425262728/** * 循环求和 * @param &#123;number&#125; total 求和 * @param &#123;array&#125; nums 参数数组 */function sum(total, ...nums) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; total = total + nums[i] &#125; return total;&#125;/** * 递归求和 * @param &#123;number&#125; total 求和 * @param &#123;array&#125; nums 参数数组 */function _sum(num1, ...nums) &#123; // 每次取到传入的第一个参数，参数列表数量每次少一个 if (nums.length == 0) return num1; return num1 + _sum(...nums);&#125;console.log(_sum(0, 1, 2, 3, 4, 10)) 找出入参最大偶数值12345678910111213141516171819202122232425262728293031/** * 找出入参最大偶数值 * @param &#123;*&#125; nums */function maxEven(...nums) &#123; var num = -Infinity; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] % 2 == 0 &amp;&amp; nums[i] &gt; num) &#123; num = nums[i] &#125; &#125; if (num !== -Infinity) &#123; return num; &#125;&#125;/** * * 递归法，找出入参最大偶数值 * @param &#123;any&#125; num1 * @param &#123;any&#125; restNums * @returns */function _maxEven(num1, ...restNums) &#123; var maxRest = restNums.length &gt; 0 ? _maxEven(...restNums) : undefined; return (num1 % 2 != 0 || num1 &lt; maxRest) ? maxRest : num1;&#125;console.log(_maxEven(9878, 45, 65, 98, 65))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"递归","slug":"递归","permalink":"https://luoyec.cn/tags/递归/"}]},{"title":"Jenkins安装及基础配置","date":"2018-03-07T01:55:41.000Z","path":"2018/03/07/cjqoyqsyt002khl6p3zp78neo/","text":"参考资料： CentOS 上安装 JenkinsRedHat Linux RPM packages for JenkinsJenkins+Node.js持续集成Getting started with Jenkins and NodeCentOS 7 安装 GitlabJenkins、Git ssh原理以及与https的区别Jenkins打包node项目步骤NodeJS Plugin官方文档jenkins publish over ssh使用 Jenkins安装及基础配置安装Java 环境安装1yum install java Jenkins 安装123sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.keyyum install jenkins 相关目录jenkins 安装目录，WAR 包会放在这里 1/usr/lib/jenkins jenkins 配置文件，端口、JENKINS_HOME 等都可以在这里配置 1/etc/sysconfig/jenkins 默认的 JENKINS_HOME 1/var/lib/jenkins/ Jenkins 日志文件1/var/log/jenkins/jenkins.log 启动Jenkins123sudo service jenkins startsystemctl start jenkins 邮件通知 定时任务","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://luoyec.cn/tags/Jenkins/"},{"name":"ECS","slug":"ECS","permalink":"https://luoyec.cn/tags/ECS/"}]},{"title":"NPM 数组模块学习与使用","date":"2018-03-05T02:36:36.000Z","path":"2018/03/05/cjqoyqsz1002whl6pzu955swr/","text":"参考链接：awesome-micro-npm-packages NPM 数组模块学习与使用 类型 仓库地址 描述 数组 is-sorted 一个检查数组是否排序的小型模块 数组 array-first 获取数组的第一个元素,可以传递一个长度参数，返回从头部开始指定长度的元素的数组 数组 array-last 获取数组的最后一个元素,可以传递一个长度参数，返回从尾部开始指定长度的元素的数组 数组 arr-flatten 递归扁平化数组。特性：如果元素是数组，递归数组，如果不是数组，则加入到新数组中，最后返回 数组 dedupe 数组去重: 特性：支持字符型、数值型简单数组；数组对象，可传入判断方法执行判断 key 数组 array-range 产生指定范围的密集数组，可用于函数式编程 数组 arr-diff 返回第一个数组的唯一值，比较时使用严格相等。特性：如果第二个参数不是数组，则无效返回原数组。实现：遍历数组，相同元素舍弃，存在多个数组，则循环多次 数组 filled-array 使用指定的元素，生成数组，可以传递一个函数返回特定的元素 数组 map-array 遍历对象数组的元素 key value 加入到数组中 数组 in-array 如果值存在于数组中，返回 true; 比 indexOf 速度更快，前不用担心 null 的问题 数组 unordered-array-remove 有效的移除数组元素，而不进行分割；算法实现元素最后一位出栈，对于元素进行交换，如果是最后的元素，直接返回 数组 mirrarray 通过数组的 value 快速创建 key-value 的对象， 键值重名 数组 group-array 将对象数组分组到列表中 实现细节+号运算符隐式转换12+\"12\"12 数组赋值12345// 从数组尾部，截取 n 长度，赋值给新数组 var res = new Array(n); while (n--) &#123; res[n] = arr[--len]; &#125; 简单递归12345678910// 如果元素是数组，递归数组，如果不是数组，则加入到新数组中，最后返回function flat(arr, res) &#123; var i = 0, cur; var len = arr.length; for (; i &lt; len; i++) &#123; cur = arr[i]; Array.isArray(cur) ? flat(cur, res) : res.push(cur); &#125; return res;&#125; 传递可选参数（函数）1234567// 判断参数是否是函数var isFn = typeof item === 'function';// 判断数组对象是否有 fill 方法, ie不兼容if (!isFn &amp;&amp; typeof ret.fill === 'function') &#123; return ret.fill(item);&#125; 判断key是否属于 [‘string’, ‘number’, ‘boolean’, ‘undefined’] 或 null 中的一种1234567/** * 判断key是否属于 ['string', 'number', 'boolean', 'undefined'] 或 null 中的一种 */const isValidKey = element =&gt; &#123; const isNull = element === null; return ['string', 'number', 'boolean', 'undefined'].includes(typeof element) || isNull;&#125; 检查同一个 key 中不能有多个 value实现思路，用对象存储已经保存的 key 12345678910111213141516const nonOverlappingKey = element =&gt; &#123; /** * Ensure we don't have distinct elements that coerce to the same key, leading to unexpected results. * For example, input of [true, 'true'] would return a keymirror of &#123;true: 'true'&#125; despite containing two distinct elements * if we didn't make this check. */ const isNull = element === null; const typeSeenBefore = keysSeen['' + element]; const thisType = isNull ? 'null' : typeof element; if (typeSeenBefore) &#123; return typeSeenBefore === thisType; &#125; else &#123; keysSeen['' + element] = thisType; return true; &#125;&#125;","categories":[{"name":"模块","slug":"模块","permalink":"https://luoyec.cn/categories/模块/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://luoyec.cn/tags/npm/"},{"name":"数组","slug":"数组","permalink":"https://luoyec.cn/tags/数组/"}]},{"title":"Object.assign() 与 扩展操作符（...）","date":"2018-02-27T02:49:38.000Z","path":"2018/02/27/cjqoyqsz60037hl6ps9mpjpy8/","text":"参考资料： MDN：Object.assign() MDN: 扩展操作符（...） 《React学习之道》扩展操作符 (可免费下载) Object.assign() 与 扩展操作符（…） React 提倡不可变的数据结构。因此你不应该改变一个对象(或者直接改变状态)。更好的做法是基于现在拥有的资源来创建一个新的对象。这样就没有任何对象被改变了。这样做的好处是数据结构将保持不变，因为你总是返回一个新对象，而之前的对象保持不变。 简单说就是，不要直接修改对象属性，而是直接创建新的对象。实现创建一个新的对象有两种方法，即：Object.assign() 与 扩展操作符（…） Object.assign() Object.assign() 函数来到达这样的目的。它把接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对 象中。只要把目标对象设置成一个空对象，我们就得到了一个新的对象。这种做法是拥抱 不变性的，因为没有任何源对象被改变。 React 中的使用：123 this.setState(&#123; result: Object.assign(&#123;&#125;, this.state.result, &#123; hits: updatedHits &#125;)&#125;); 其他使用方法复制一个对象 123var obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 深拷贝问题: 针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。 123456789101112131415let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj2 = Object.assign(&#123;&#125;, obj1);// 当修改 obj2.b.c 发现 obj1、obj2 的属性都被修改了，因为他们保存的是对象的同一个引用obj2.b.c = 3;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;// 正确实现深拷贝的方式obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 合并对象 1234567var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 合并具有相同属性的对象 123456var o1 = &#123; a: 1, b: 1, c: 1 &#125;;var o2 = &#123; b: 2, c: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 扩展操作符（…） 由三个点组成: ... 。当使用它时，数组 或对象中的每一个值都会被拷贝到一个新的数组或对象。 React 中使用 123 this.setState(&#123; result: &#123; ...this.state.result, hits: updatedHits &#125;&#125;);","categories":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/categories/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://luoyec.cn/tags/React/"},{"name":"纯函数","slug":"纯函数","permalink":"https://luoyec.cn/tags/纯函数/"}]},{"title":"Jenkins NodeJS Plugin 插件安装使用","date":"2018-02-10T03:33:37.000Z","path":"2018/02/10/cjqoyqsyq002fhl6pvzjuddr8/","text":"Jenkins NodeJS Plugin 插件安装使用NodeJS Plugin 插件官方 WIKI： NodeJS Plugin 主要特性： 提供 NodeJS 的自动安装，可以创建并使用不同版本的 NodeJS 允许在每个项目安装全局的 npm 包 安装完成后可以执行 NodeJS 脚本 可以使用定制的 NPM 用户配置文件 支持 DSL pipeline Jenkins 中设置Jenkins: 系统管理 ---&gt; 全局工具配置 ---&gt; NodeJS 新增安装，选择 Install from nodejs.org 选择安装版本，建议安装稳定支持版，这里选择v8.9.4 ⚠️ 配置的时候注意，安装方式选择后，如果要更改方式，请删除安装后再重新选择！ 一个完整的配置： 在项目中选择 NodeJS","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://luoyec.cn/tags/Jenkins/"},{"name":"ECS","slug":"ECS","permalink":"https://luoyec.cn/tags/ECS/"}]},{"title":"Jenkins publish over ssh 插件使用","date":"2018-02-10T03:06:25.000Z","path":"2018/02/10/cjqoyqsyv002ohl6pbps4w9xs/","text":"参考链接：jenkins publish over ssh 使用Jenkins 常用插件之 Publish Over SSH Jenkins publish over ssh 插件使用系统：CentOS Linux release 7.4.1708 (Core)服务器：阿里云ECS 远程服务器上生成密钥1#ssh-keygen 一直默认，如果对安全不是特别苛刻，可以不设置 parsepass， 在 /root/.ssh目录下生成 id_rsa.pub id_rsa 公钥和私钥。 复制公钥文件 id_rsa.pub 改名为 authorized_keys,只有这个公钥里用户（这里是root）可以连接。 将密钥复制到 Jenkins检查 Publish Over SSH 插件是否已经安装。 该插件主要是通过 SSH 连接其他 Linux 机器，远程传输文件及执行 Shell 命令。 特性：1、SCP—通过 SSH 发送文件2、在远程服务器执行 shell 命令3、Passwords/passphrases 在配置文件及 UI 界面是加密显示的4、SSH 可在项目编译前或编译后执行，与是否编译成功无关 Jenkins: 系统管理 ---&gt; 系统设置 ---&gt; Publish over SSH 在项目中选择 SSH 服务","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://luoyec.cn/tags/Jenkins/"},{"name":"ECS","slug":"ECS","permalink":"https://luoyec.cn/tags/ECS/"}]},{"title":"React 事件处理","date":"2018-01-27T17:23:29.000Z","path":"2018/01/28/cjqoyqsz9003fhl6pjciywhyu/","text":"参考： 事件处理（React 文档） 从 React 绑定 this，看 JS 语言发展和框架设计 React 事件处理事件包含了许多细节，在实际开发中容易忽略，造成不是我们期望的结果，本文包含了这部分的细节，解决开发中遇到的 React 事件的问题。 对比传统 HTMLReact 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同: React 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串( DOM 元素的写法) 传统的 HTML： 1&lt;button onclick=\"activateLasers()\"&gt;Activate Lasers&lt;/button&gt; React 中稍稍有点不同： 1&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;/button&gt; 阻止事件默认行为不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault 传统 HTML 中可以这样写 123&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\"&gt; Click me&lt;/a&gt; 在 React 中应该这样写 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(\"The link was clicked.\"); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 这里的参数 e 是合成事件，React 根据 W3C spec 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。 在 ES6 中的事件处理1234567891011121314151617181920212223class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isToggleOn: true &#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? \"ON\" : \"OFF\"&#125; &lt;/button&gt; ); &#125;&#125; 你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。 这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。 绑定 thisReact.createClass 自动绑定React.createClass 创建的组件，可以自动绑定 this。也就是说，this 这个关键字会自动绑定在组件实例上面。 123// This magically works with React.createClass// because `this` is bound for you.onChange = &#123;this.handleChange&#125; 当然很遗憾，对于组件的创建，官方已经推荐使用 class 声明组件或使用 functional 无状态组件 渲染时绑定1onChange = &#123;this.handleChange.bind(this)&#125; 有一个潜在的性能问题： 当组件每次重新渲染时，都会有一个新的函数被创建。但在正常开发场景中，可以忽略。 箭头函数绑定1onChange = &#123;e =&gt; this.handleChange(e)&#125; 同样存在潜在的性能问题 Constructor 内绑定1234constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this);&#125; 重复而累赘 Class 属性中使用 = 和箭头函数1234handleChange = () =&gt; &#123; // call this function from render // and this.whatever in here works fine.&#125;; 这种方式的优点： 使用箭头函数，有效绑定了 this； 没有第二种方法和第三种方法的潜在性能问题； 避免了方法四的组件实例重复问题； 我们可以直接从 ES5 createClass 重构得来。 这个方法依赖于 ES next 的新特性， 请参考：tc39.github.io &gt; http://babeljs.io/blog/2015/06/07/react-on-es6-plus/ &gt; http://babeljs.io/blog/2015/10/31/setting-up-babel-6/ 好消息是在 create-react-app 等工具中已经默认开启。 向事件处理程序传递参数123&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 上述两种方式是等价的，分别通过 arrow functions 和 Function.prototype.bind 来为特定事件类型添加事件处理程序。 上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面，例如: 123456789101112131415161718192021222324252627class Popper extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: \"Hello world!\" &#125;; &#125; preventPop(name, e) &#123; //事件对象e要放在最后 e.preventDefault(); alert(name); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &#123;/* Pass params via bind() method. */&#125; &lt;a href=\"https://reactjs.org\" onClick=&#123;this.preventPop.bind(this, this.state.name)&#125; &gt; Click &lt;/a&gt; &lt;/div&gt; ); &#125;&#125; 其他问题事件自动执行了？例如： 123&lt;a href=\"#\" onClick=&#123;this.onLoadQR(text)&#125;&gt; &lt;Icon type=\"qrcode\" /&gt;下载&lt;/a&gt; 这种写法是直接执行了函数，所以每一次渲染都会执行 而正确的行为是，我们应该在这里进行事件绑定，因为 React 不会进行自动绑定，具体方法看前文 “绑定 this” 不写 this 为什么找不到方法？例如： 1&lt;Switch defaultChecked onChange=&#123;onChangeSwitch(text)&#125; /&gt; 省略了 this, 此时方法虽然写在了 class 内，但是缺无法获取到，此时如果将方法写到 class 外，作为一个全局变量，但这个方法内部的 this 指向缺为 undefined。","categories":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/categories/React/"}],"tags":[{"name":"事件","slug":"事件","permalink":"https://luoyec.cn/tags/事件/"},{"name":"react","slug":"react","permalink":"https://luoyec.cn/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyec.cn/tags/ES6/"}]},{"title":"高性能 Webpack3 配置","date":"2018-01-09T16:17:00.000Z","path":"2018/01/10/cjqoyqt4l00jahl6p4etxxpzz/","text":"参考：High-performance webpack config for front-end deliverywebpack3 指南 高性能 Webpack 配置Scope Hoisting （作用域提升）官方文档：ModuleConcatenationPlugin 过去 webpack 打包时的一个取舍是将 bundle 中各个模块单独打包成闭包。这些打包函数使你的 JavaScript 在浏览器中处理的更慢。相比之下，一些工具像 Closure Compiler 和 RollupJS 可以提升(hoist)或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。 在生产环境中配置： 1234567const webpack = require('webpack');module.exports = &#123; plugins: [ new webpack.optimize.ModuleConcatenationPlugin(), ],&#125;; 下面放一张用户使用之后包体的对比，大概减少了50%，对于模块数量很多的项目来说提升较大。 Minification and Uglification （压缩和丑化）代码压缩和“丑化”是生产环境中必不可少的，然而偶尔的会遗忘，所以在部署到生产环境之前，首先要做的就是检查代码是否经过压缩和“丑化” 错误的方式直接运行 webpack 命令进行打包，查看包体积 正确的方式只需要在 webpack 命令后面加上 -p 参数！ 通过对比可以发现，减少了整整 60% 的体积！没有压缩前，充斥着空格、换行、注释！ 📌 -p 参数不会设置 node 环境变量为生产环境 production，当你需要在生产环境中执行时，可使用该命令行：NODE_ENV=production PLATFORM=web webpack -p 📌 为了快速打包，可以将参数添加到 package.json 中： 123\"scripts\": &#123; \"build\": \"webpack -p\"&#125;, 高级压缩方式使用 UglifyjsWebpackPlugin 插件安装 1npm i -D uglifyjs-webpack-plugin 用法 123456789webpack.config.jsconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyJsPlugin() ]&#125; 默认的配置已经很好的满足大部分的项目需求，但如何你想更进一步压缩，减少一部分不必要的代码，可以使用 Webpack 版本 &gt; 3.0： 123plugins:[ new webpack.optimize.UglifyJsPlugin(&#123;/* options here */&#125;),], Dynamic Imports for Lazy-loaded Modules （动态引入和懒加载）生产环境下的使用使用动态引入的项目，编译时： 可以看到之前整个的 bundle.js 文件被拆分了多个，在 index.html 中只引入了 index.bundle.js 作为入口，按需加载其他被拆分的js文件 安装配置安装 Babel： 1yarn add babel-loader babel-core babel-preset-env 配置 webpack.config.js，允许 Babel 处理你的 js 文件 123456789module: &#123; rules: [ &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/, &#125;, ],&#125;, 完成以上设置后，可以安装处理动态引入的插件了 1yarn add babel-plugin-syntax-dynamic-import 创建或修改 .babelrc 在项目的根目录 1234&#123; \"presets\": [\"env\"], \"plugins\": [\"syntax-dynamic-import\", \"transform-react-jsx\"]&#125; 改造代码将需要被改造成懒加载的模块做简单的代替： 1import Home from './components/Home'; with1const Home = import('./components/Home'); 最终我们的 index.js 入口文件被改造成了这样，这种 import 的方式只是一种语法糖，在一些框架中如 vue 已经得到支持 123456import React from 'react';import Async from 'react-code-splitting';const Nav = () =&gt; (&lt;Async load=&#123;import('./components/Nav')&#125; /&gt;);const Home = () =&gt; (&lt;Async load=&#123;import('./views/home')&#125; /&gt;);const Countdown = () =&gt; (&lt;Async load=&#123;import('./views/countdown')&#125; /&gt;); webpack.config.js配置文件的出口和出口 123456789entry: &#123; index: './index.js',&#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js', publicPath: '/',&#125;, Deterministic Hashes for Caching（对缓存使用确定的Hash值）webpack 在默认的情况下不会自动添加 hash，例如 app.8087f8d9fed812132141.js，这意味着，数据保存在缓存个中，当用户刷新时不会得到更新。 在 webpack 快速添加 hashes： 123output: &#123; filename: '[name].[hash].js',&#125;, ⚠️ 注意这里有一个陷阱，每一次的构建，不管文件有没有更改都会重新声场新的 hash 值，例如在使用 webpack -p 时，即使用户已经已经下载相关文件，那么讲不得不刷新！ ⚠️ 使用哈希值构建，将会降低编译的速度，请在生产环境中使用！ Deterministic Hashes 配置 📌这里我们需要解决的一个问题是，当内容改变到时候用户才会刷新缓存，如果没有改变，则不会去刷新缓存。 插件安装： 1yarn add chunk-manifest-webpack-plugin webpack-chunk-hash chunk-manifest-webpack-plugin: 允许导出一个json文件，将id映射到其中，webpack 会读取该json，以确定需要刷新缓存的模块webpack-chunk-hash: 使用自定义的（md5）代替标准的webpack 生成的 hash 修改 webpack.config.js ，用于生产环境 : 12345678910111213141516171819202122232425262728293031323334353637const webpack = require('webpack');const ChunkManifestPlugin = require('chunk-manifest-webpack-plugin');const WebpackChunkHash = require('webpack-chunk-hash');const HtmlWebpackPlugin = require('html-webpack-plugin');/* Shared Dev &amp; Production */const config = &#123; /* … our webpack config up until now */ plugins: [ // /* other plugins here */ // // /* Uncomment to enable automatic HTML generation */ // new HtmlWebpackPlugin(&#123; // inlineManifestWebpackName: 'webpackManifest', // template: require('html-webpack-template'), // &#125;), ],&#125;;/* Production 指定了生产环境中使用 */if (process.env.NODE_ENV === 'production') &#123; config.output.filename = '[name].[chunkhash].js'; config.plugins = [ ...config.plugins, // ES6 array destructuring, available in Node 5+ new webpack.HashedModuleIdsPlugin(), new WebpackChunkHash(), new ChunkManifestPlugin(&#123; filename: 'chunk-manifest.json', manifestVariable: 'webpackManifest', inlineManifest: true, &#125;), ];&#125;module.exports = config; 🌚 Tip对于上面的例子，当你使用 yarn add html-webpack-plugin html-webpack-template 模板时，会自动的添加注释，如果没有使用 webpack 的 HTML 模板，则需要手动的引入，引入方式为： 1234567&lt;head&gt; &lt;script&gt; //&lt;![CDATA[ window.webpackManifest = &#123; /* contents of chunk-manifest.json */ &#125;; //]]&gt; &lt;/script&gt;&lt;/head&gt; 同样的 manifest.js 也需要引入，当你设置好了这两个文件，那么一切准备就绪。 CommonsChunkPlugin for Vendor Caching CommonsChunkPlugin ： CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。 一行代码的简单配置： 123456module.exports = &#123; entry: &#123; app: './app.js', vendor: ['react', 'react-dom', 'react-router'], &#125;,&#125;; 然后运行 webpack -p 但是这种配置有个问题，这里的 &#39;react&#39;, &#39;react-dom&#39;, &#39;react-router&#39;， 会同时打包到 index.bundle.js 和 vendor.bundle.js 中 要解决上述问题，我们需要使用 CommonsChunkPlugin 插件，将文件分离出来，在 webpack.config.js 中的配置 1234567const webpack = require('webpack');plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', &#125;),], ⚠️ 需要注意的是，插件中的name 要是 入口的名字匹配 配置完成之后，重新打包，发现包体被拆分了！ Offline Plugin for webpack（PWA）使用offline-plugin搭配webpack轻松实现PWA 此插件用于实现PWA，新技术，是否需要使用和探索，这里记录配置的方法，这并不复杂 安装： 1yarn add offline-plugin 添加到r= webpack config: 1234567891011121314const OfflinePlugin = require('offline-plugin');module.exports = &#123; entry: &#123; // Adding to vendor recommended, but optional vendor: ['offline-plugin/runtime', /* … */], &#125;, plugins: [ new OfflinePlugin(&#123; AppCache: false, ServiceWorker: &#123; events: true &#125;, &#125;), ],&#125;; 然后，在 app 中的入口文件，在开始渲染之前使用： 12345678910111213/* index.js */if (process.env.NODE_ENV === 'production') &#123; const runtime = require('offline-plugin/runtime'); runtime.install(&#123; onUpdateReady() &#123; runtime.applyUpdate(); &#125;, onUpdated() &#123; window.location.reload(); &#125;, &#125;);&#125; webpack Bundle Analyzer（包分析工具） 1yarn add --dev webpack-bundle-analyzer 添加到开发环境 12345678910const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;config = &#123; /* shared webpack config */ &#125;;if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; process.env.NODE_ENV !== &apos;test&apos;) &#123; config.plugins = [ ...config.plugins, new BundleAnalyzerPlugin(), ];&#125; 运行并监听 8888 端口 1node_module/.bin/webpack --profile --json &gt; stats.json Multi-entry Automatic CommonsChunk Plugin（多页面应用程序）应用场景不多，只记录下来。 webpack.config.js 1234567const config = &#123; entry: &#123; pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; &#125;&#125;; 这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图。 为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 We can update CommonsChunk to just figure things out automatically: 12345678910/* Dev &amp; Production */new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;commons&apos;, minChunks: 2,&#125;),/* Production */new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, minChunks: Infinity,&#125;),","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"webpack3","slug":"webpack3","permalink":"https://luoyec.cn/tags/webpack3/"}]},{"title":"JavaScript脚本化文档下","date":"2018-01-07T14:31:53.000Z","path":"2018/01/07/cjqoyqsys002ihl6p82mqo2fc/","text":"JavaScript脚本化文档下属性HTML 元素由一个标签和一组称为属性（attribute）的键值对组成。例如 a 标签的 href 属性，img 标签 src 属性 HTML 属性作为 Element 的属性表示 HTML 文档元素的 HTML Element 对象定义了读\\写属性，它们映射了元素的 HTML 属性。 HTMLElement 定义了通用的 HTTP 属性（如 id、标题 lang 和 dir）等属性，以及事件处理程序属性（如 onclick）。并且特定的类型元素定义了特定的属性。例如： 12345678var image = documment.getElementById(\"myiamge\")var imgurl = images.src //src属性是图片的URLimage.id === \"myimage\" //判定是否是要查找的图片id/* 类似的，也可以设定表单提交的URL */var f = document.forms[0]f.action = \"http://XXX\" 表示 HTML 属性的值通常是字符串，如 input 输出文本的值。 需要注意的是，这个属性是通过 API 来获取和设置的，并不能删除该属性。设想一下，没有有输入值的输出框。 非标准的HTML属性 Element 类型定义了 getAttribute()和setAttribute() 方法来查询和设置非标准的 HTML 属性。 12345 var image = document.images[0] var witth = parseInt(image.getAttribute('WIDTH'))image.和setAttribute('class', 'thumbnail') 通常情况下getAttribute() 返回字符串，并不会返回数值、布尔值、对象。对于 HTML 元素来说，属性名字不会区分大小写 1234test1111.getAttribute('class')\"xxx\"test1111.getAttribute('CLASS')\"xxx\" Element 类型 定了其他两个相关方法，hasAttribute() 和 remove Attribute() ，用来检查命名属性是否存在和完全删除。 元素的内容inerHTML 与 outerHTML ⚠️ inerHTML 在元素上设置该属性，用新字符串内容替换元素当前内容 outerHTML 查询 outerHTML 时，返回的字符串包含被查询元素的开头和结尾标签 在设置 outerHTML 时，元素本身将会被新内容替换 作为纯文本在文档中插入纯文本，标准的方法是用 Node 的 textContent 属性来实现。 ⚠️ IE的兼容性 &gt;= IE9，在 IE 中，可以用 innerText 属性替代 12345var para = document.getElementByTagName(\"p\")[0var text = para.textContentpara.textContent = \"Hello World!\" 作为Text节点的元素内容 ❓ 作用不是很明确，详见犀牛书p381 创建、插入和删除节点12345678910// 从指定的URL，异步加载和执行脚本function loadsync(url) &#123; var head = document.getElementByTagName(\"head\")[0] var s = document.createElement(\"script\") s.src = url head.appendChild(s)&#125; 创建节节点 createElement() 创建新的 Element 节点可以使用 Document 对象的 createElement() 方法。 给方法传递元素的标签名：对 HTML 文档来说该名字不区分大小写，对 XML 文档来说则需要区分大小写。 创建 Text 节点 var newnode = document.createTextNode(&quot;text node content&quot;) 插入节点一旦有了一个新节点，可以用 appendChild() 或 insertBefore()。 appendChild() 是在需要插入的 Element 节点删调用 insertBefore() 类似于前者，它需要接受两个参数，第一个参数就是待插入的节点，第二个参数是已经存在的节点 12345678910// 将child节点插入到parent中，使其成为第n个子节点function insertAt(parent, child, n) &#123; if( n &lt; 0 || n &gt; parent.childNodes.length) throw new Error(\"invalid index\") else if( n == parent.childNodes.length) parent.appendChild(child) else parent.insertBefore(child, paretn.childNodes[n])&#125; 删除和替换节点removeChild() 方法是从文档中删除一个节点 1n.parentNode.removeChild(n) replaceChild() 方法删除一个子节点并用一个新节点取而代之。 1n.parentNode.replaceChild(document.createTextNode(\"[ REDACTED ]\"), n) 生成目录表 文档和元素的几何形状和滚动1234567891011121314151617// 查询窗口滚动条的位置function getScrollOffsets(w)&#123; // 使用指定窗口，如果不带参数则使用当前窗口 w = w || window // 除了IE8 及更早的版本，其他浏览器都能用 if (w.pageXOffset != null) return &#123;x: w.pageXOffset, y: w.pageYOffset&#125; // 对标准模式下的IE var d = w.document if (document.compatMode == \"css1Compat\") return &#123;x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop&#125; // 对怪异模式下的浏览器 return &#123;x: d.body.scrollleft, y: d.body.scrollTop&#125;&#125; 12// 获得在视口坐标中的位置，返回left、right、top、bottom属性的对象var box = e.getBoundingClientRect() 判断元素在某点getBoundingClientRect() 方法能确定元素在视口中的位置 elementFromPoint() 方法判定视口指定位置有什么元素 滚动1234567// 获得文档和视口的高度，offsetHeight会在下面解释var documentHeight = document.documentElement.offsetHeightvar viewportHeight = window.innerHeight// 然后滚动让最后一页在视口中可见window.scrollTo(0, documentheight - viewprotHeight)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"脚本文档化","slug":"脚本文档化","permalink":"https://luoyec.cn/tags/脚本文档化/"}]},{"title":"CentOS7 服务器安装 Node.js","date":"2018-01-06T06:51:49.000Z","path":"2018/01/06/cjqoyqsxi0009hl6pgak5246r/","text":"参考：部署 Node.js 项目（CentOS）阿里云文档淘宝 NPM 镜像Node.js 官方下载地址，可以通过wget下载 CentOS7 服务器安装 Node.jswget 命令下载 Node.js 安装包 1wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.gz 解压文件 1tar xvf node-v8.9.4-linux-x64.tar.gz 创建软链接，使 node 和 npm 命令全局有效⚠️ 注意一定要使用绝对路径 12345678ln -s /root/node-v8.9.4-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v8.9.4-linux-x64/bin/npm /usr/local/bin/npmln -s /root/node-v8.9.4-linux-x64/bin/npx /usr/local/bin/npx// ⚠️ 删除错误创建的软连接#rm /usr/local/bin/node 查看node、npm版本 12node -vnpm -v 添加环境变量 123456export NODE_PATH=/root/node-v8.9.4-linux-x64/binexport PATH=$&#123;PATH&#125;:$&#123;NODE_PATH&#125;// ⚠️ 这里不输出到 ~/.profile ， 属于临时文件，配置不能持久echo \"PATH=\\$&#123;PATH&#125;:$&#123;NODE_PATH&#125;\" &gt; /etc/profile 安装 cnpm： 1npm install -g cnpm --registry=https://registry.npm.taobao.org","categories":[{"name":"node","slug":"node","permalink":"https://luoyec.cn/categories/node/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://luoyec.cn/tags/CentOS/"},{"name":"服务器","slug":"服务器","permalink":"https://luoyec.cn/tags/服务器/"},{"name":"Node.js","slug":"Node-js","permalink":"https://luoyec.cn/tags/Node-js/"}]},{"title":"CentOS7 服务器安装 MySQL","date":"2018-01-06T04:24:04.000Z","path":"2018/01/06/cjqoyqsxd0006hl6pluc5vjtx/","text":"扩展阅读：How to Install MySQL on CentOS 7云服务器 ECS &gt; 用户指南 &gt; 安全组 &gt; 添加安全组规则MySQL安全配置向导mysql_secure_installation详解centos7 mysql数据库安装和配置 CentOS7 服务器安装 MySQL 😯 本文档是基于非 root 用户的，需要 sudo 前缀以提升权限，如果是 root 用户，则可忽略该前缀。使用阿里云ECS，需要配置安全组规则，详见文档具体章节。 开始之前检查你的主机状态： 1234[root]# hostname // 短主机名iZwz97v8o1cbogw4uplc4dZ[root]# hostname -f // 同时带有主机名和域名的名称iZwz97v8o1cbogw4uplc4dZ 更新系统的 yum 1sudo yum update 安装 wget ，用以完成 MySQL 安装 1yum install wget Yum (全称为：Yellow dog Updater, Modified) 由Duke University团队，修改Yellow Dog Linux的Yellow Dog Updater开发而成，是一个基于RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。被Yellow Dog Linux本身，以及Fedora、Red Hat Enterprise Linux采用。 GNU Wget是一个在网络上进行下载的简单而强大的自由软件，其本身也是GNU计划的一部分。它的名字是“World Wide Web”和“Get”的结合，同时也隐含了软件的主要功能。目前它支持通过HTTP、HTTPS，以及FTP这三个最常见的TCP/IP协议协议下载。 安装 MySQL下载和安装仓库，并且使用yum更新它 12345wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmsudo rpm -ivh mysql-community-release-el7-5.noarch.rpmyum update 安装 MySQL 服务，遇到校验时，如果没有错误或匹配错误请选择 y 123sudo yum install mysql-server // 安装服务sudo systemctl start mysqld // 启动服务 MySQL 默认绑定 localhost (127.0.0.1)，了解使用 ssh 连接到数据库的信息。 MySQL remote access guide ⚠️ MySQL 不建议不设限制地通过公共IP连接，你可以修改配置文件 /etc/my.cnf以更改监听地址，如果决定将MySQL绑定到公共IP，则应该实现只允许特定IP地址的连接的防火墙规则。 安全配置向导(Harden MySQL Server)运行 mysql_secure_installation 设置默认的 MySQL 安全问题 1sudo mysql_secure_installation ⚠️ 第一次配置时，没有给 root 用户设置密码，直接回车可以设置初始密码。 具体的设置规则： 为 root 用户设置密码 删除匿名账号 取消 root 用户远程登录 删除 test 库和对 test 库的访问权限 刷新授权表使修改生效 可以参考：MySQL安全配置向导mysql_secure_installation详解 使用MySQLRoot 用户登录 root 登录 MySQL 1mysql -u root -p 生成 MySQL 命令提示列表 \\h 创建一个新的 MySQL 用户 和 仓库12345678// testdb 为数据库名create database testdb; // testuser 用户名；password：密码create user 'testuser'@'localhost' identified by 'password'; // 赋予testuser用户所有权限grant all on testdb.* to 'testuser' identified by 'password'; 以上命令可以缩短为： 123create database testdb;grant all on testdb.* to 'testuser' identified by 'password'; 完成后退出 MySQL： 1exit 创建一个简单表使用之前创建的 testuser 用户登录： 1mysql -u testuser -p 创建简单的表123use testdb;create table customers (customer_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, first_name TEXT, last_name TEXT);enter code here 重设 ROOT 密码root 用户登录 1mysql -u root -p 切换到mysql ，重置密码，并且刷新 1234567use mysql;update user SET PASSWORD=PASSWORD(\"password\") WHERE USER='root';flush privileges;exit 重启 MySQL： 1234sudo systemctl start mysqld// 或者service mysqld start 远程连接远程连接设置把在所有数据库的所有表的所有权限赋值给位于所有 IP 地址的 root 用户。 1mysql&gt; grant all privileges on *.* to root@'%'identified by 'password'; 如果是新用户而不是root，则要先新建用户 1mysql&gt;create user 'username'@'%' identified by 'password'; 此时就可以进行远程连接了。 ⚠️ 阿里云添加安全组规则云服务器 ECS &gt; 用户指南 &gt; 安全组 &gt; 添加安全组规则 常用端口选择 MySQL 3306 授权对象为 0.0.0.0/0 Navicat 连接","categories":[{"name":"mysql","slug":"mysql","permalink":"https://luoyec.cn/categories/mysql/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://luoyec.cn/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://luoyec.cn/tags/MySQL/"},{"name":"服务器","slug":"服务器","permalink":"https://luoyec.cn/tags/服务器/"}]},{"title":"YEOMAN实践一","date":"2018-01-02T01:16:45.000Z","path":"2018/01/02/cjqoyqszq004ahl6pzv1op8a9/","text":"拓展阅读： YEOMAN 官方文档用 node.js 开发一个可交互的命令行应用yeoman-generator 入门教程 YEOMAN实践如何使用社区的 generator在这里查找社区 generator name 代指选择的 generator 安装： 1npm install -g generator-name 使用： 1yo generator-name 配置提示，一般情况选择 overwrite： ⚠️ 当发现安装的项目路径不是当前文件夹，是 home 目录或者其他，检查 父目录中的 .yo-rc.json ，并删除它 创建自己的 generator参照这篇文档 yeoman-generator 入门教程 ⚠️ 需要注意几个点： 项目文件名和 generator 名称要一致 目录层次可以有两种，但需要在 package.json files 字段中加以区分 需要执行 yo link 建立软连接","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://luoyec.cn/categories/前端工程化/"}],"tags":[{"name":"yeoman","slug":"yeoman","permalink":"https://luoyec.cn/tags/yeoman/"},{"name":"脚手架","slug":"脚手架","permalink":"https://luoyec.cn/tags/脚手架/"}]},{"title":"JavaScript事件处理下","date":"2017-12-26T14:35:21.000Z","path":"2017/12/26/cjqoyqsyj001whl6pw2lgw1e0/","text":"JavaScript注册事件处理下注册事件处理程序有两种基本方式，第一种是给目标对象或文档元素设置属性。第二种更为通用，是将事件处理程序传递给对象或元素的一个方法。 可以在 JavaScript 代码中设置事件处理程序的对象属性，或对于文档流元素，可以在 HTML 中直接设置相应属性。对于通过方法调用的处理程序注册，有个标准方法 addEventListenter()， IE8 及以前版本的之外都支持，在 IE9 之前有个另一个方法 attachEvent() 设置 JavaScript 对象属性为事件处理程序注册事件处理程序最简单的方式就是通过设置事件目标的属性为所需事件处理程序函数。区分大小写，并且都是小写，如 onclick、onchange、onload、onmouseover 等 12345//设置window 对象的 unload 属性为一个函数//当文档加载完毕时调用它window.onload = function () &#123; //...&#125; 一般情况下，所有广泛实现的 Web API 定义的事件都允许通过设置事件处理程序属性来注册事件处理程序。 缺点是每个事件目标对于每种事件类型将最多只有一个处理程序，如果想要编写能再任意文档中使用的脚本库代码，更好的方式是使用一种不修改或者覆盖任何已有注册事件程序的技术，例如 addEventListenner() 设置 HTML 标签属性为事件处理程序1&lt;button onclick=\"alert('THANK YOU!')\"&gt;&lt;/button&gt; 这里有几个特点： 属性值是 JavaScript 代码字符串 这段代码是处理程序函数的主题，而非完整的函数声明 不应该使用大括号包裹和 function 关键字作为前缀 多条语句用 ; 隔开 addEventListener()注意前面提到的兼容性问题。 Window对象、Document 对象和所有文档元素都可以使用 addEventListener() 语法1target.addEventListener(type, listener[, options]); 12345678910111213// 改变t2的函数function modifyText() &#123; var t2 = document.getElementById(\"t2\"); if (t2.firstChild.nodeValue == \"three\") &#123; t2.firstChild.nodeValue = \"two\"; &#125; else &#123; t2.firstChild.nodeValue = \"three\"; &#125;&#125;// 为table添加事件监听器var el = document.getElementById(\"outside\");el.addEventListener(\"click\", modifyText, false); removeEventListener()删除使用 EventTarget.addEventListener() 方法添加的事件 123456var div = document.getElementById('div');var listener = function (event) &#123; /* do something here */&#125;;div.addEventListener('click', listener, false);div.removeEventListener('click', listener, false); attach……Event()这是早期IE浏览器（IE8及早期版本）的一个专有的替代性标准，替代 EventTarget.addEventListener() 方法 ⚠️ 非标准 该特性是非标准的，请尽量不要在生产环境中使用它！\bHEXO中不能出现此方法，\b会报错导致页面无法显示 因为IE 模型不支持事件捕获，所以只有两个参数：事件类型和处理函数 带on前缀，要给该方法传递 ‘onclick’ 允许相同事件注册多次，也会被调用多次 事件处理程序的调用本节也会说明事件的传播机制，即单个事件如何能在原始目标和文档容器上触发多个处理程序的调用。 事件处理程序的参数通常调用事件处理程序时会把事件对象作为它们的一个参数，提高有关事件的详细信息。 一个 IE8 以前版本中，获取事件对象 123function handler(event)&#123; event = event || window.event;&#125; 事件处理程序的运行环境1e.onclick = function()&#123;/* 处理程序代码 */&#125; 在事件处理程序中，this 关键字指的是事件目标 当使用 addEventListener() 注册时，也是一样 但对于 attachEvent()， this 却是 全局对象 Window，兼容的方法在书中有举例 事件处理程序返回值通常情况下，返回 false 就是告诉浏览器不要执行这个事件相关的默认操作 window.onbeforeunload() : 当浏览器将要跳转到新页面时触发，如果返回一个字符串，那么将会出现在询问用户是否离开当前页面的标准对话框中（有兼容性问题，并不是所有浏览器都可以自定义提示信息，更多是浏览器标准提示）。 1234567891011window.onbeforeunload = function (e) &#123; e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) &#123; e.returnValue = '关闭提示'; &#125; // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示';&#125;; 调用顺序 通过设置对象属性或 HTML 属性注册的处理程序一直优先调用 使用 addEventListener() 注册的处理程序按照它们的注册顺序调用 使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所有代码不应该依赖于调用顺序 事件传播当事件目标是 Window 对象或其他一些单独对象（比如 XMLHttpRequest ）时，浏览器简单通过调用对象上适当的处理程序响应事件。 但当事件目标是文档或文档元素时，情况较为复杂。 大部分的事件都会“冒泡”到 DOM 树根，层层向上传递，事件冒泡为在大量单独文档元素上注册处理程序提供了代替方案，即在共同的祖先元素上注册一个处理程序来处理所有事件。 📍 事件传播的三个阶段： 第一阶段发生在目标处理程序调用之前，称为 “捕获”阶段，回顾上文 addEventListener() 的第三个参数，注意兼容性问题 第二阶段是目标对象本身的事件处理程序的调用 第三阶段是事件冒泡 事件捕获提供了在事件没有送达目标之前查看他们的机会。能用于程序调试、事件取消技术过滤掉事件从而使目标事件程序绝不会被调用、处理鼠标拖放 事件取消在支持 addEventListener() 的浏览器中，可以通过调用事件对象的 preventDefaultDefault() 方法取消事件的默认操作， IE9 之前，可以通过设置事件对象的 returnValue 属性为 false 达到相同效果。 在支持 addEventListener() 的浏览器中，stopPropagation() 方法阻止事件的继续传播，IE9 之前， 使用 cancelBubble() 具体的事件类别至此，已经学习了 JavaScript 事件处理的基本原理，针对于具体的事件，请查阅犀牛书相关章节 文档加载事件 鼠标事件 鼠标滚轮事件 拖放事件 文本事件 键盘事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"https://luoyec.cn/tags/事件/"}]},{"title":"JavaScript脚本化文档上","date":"2017-12-26T14:28:16.000Z","path":"2017/12/26/cjqoyqsyo002bhl6pbhbj9n5k/","text":"《 JavaScript 权威指南 第十五章》 本文介绍了文档的概念，以及如何获取问题，Node 节点的属性，如何通过Node属性快速定位的相关节点。 JavaScript脚本化文档每个 Window 对象由一个 document 属性引用了 Document 对象，它是一个巨大的 API 中的核心对象，就做文档模型，它代表和操作文档的内容。本章涉及到的知识点： 如何在文档中查询或选取单独的元素 如何将文档作为节点树遍历，如何找到任何文档元素的祖先、兄弟和后台元素 如何查询和设置文档元素的属性 如何查询、设置和修改文档的内容 如何通过创建、插入和删除节点来修改文档结构 如何与HTML表单一起工作 文档特性，referrershuxing、write()方法、和查询当前文档中选取的文档文本 DOM 概述DOM：文档对象模型 一个简单的 HTML 文档的 DOM 树状图： 文档中的每一个节点，表示一个 Node 对象，每个 Node 对象由四大属性，详细请查阅相关章节： Document CharaterData Element Attr 选取文档元素 用指定的 ID 属性 用指定的 name 属性 用指定的标签名字 用指定的 CSS 类 匹配指定的 CSS 选择器 通过 ID 选取元素1var section1 = document.getElementById('section1'); id 属性是 HTML 元素唯一的，这是最简单和常用的选取元素的方法。 通过 id 查找多个元素： 通过名字选取元素 name 属性不是必须唯一，但是只有少数 HTML 元素中有效，包括表单、表单元素、&lt;ifarme&gt;、&lt;img&gt;元素 1var radiobuttons = document.getElementByName('favorite_color'); 有些元素自动设置 name 属性到 Window 对象中，所有可以仅仅通过名字获取，但是最好显示的通过 getElementByName() 获取： 12// 针对 &lt;form name='shipping_address'&gt; 元素,获得Element对象var form = docuemnt.shipping_address; 通过标签名选取元素1var spans = document.getElementByTagName('span'); 只能返回数组对象，并且排列顺序是文档中的顺序。HTML 标签是不区分大小写的。 传递通配符参数 * 将获取代表文档中所有元素的 NodeList 对象。 通过 CSS 类选取元素12//查找其class属性值中包含“awrning”的所有元素var warning = document.getElementByClassName('warning') 参数可以是一个字符串，也可以是多个由空格隔开的标识符组成，只有当元素的 class 属性值包含所有指定的标识符时才会匹配，但是与标识符的顺序是无关的。 现代Web浏览器中以&lt;!DOCTYPE&gt;声明的严格程度来选择“怪异模式”或者“标准模式”方式显示HTML文档。怪异模式是为了向后兼容性而存在的。 通过 CSS 选择器选取元素选择器用来描述文档中的若干或多组元素，元素可以用ID、标签名或类来描述 css选择器 querySelectorAll() :返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的节点)。返回的对象是 NodeList 。需要注意的是，一些伪元素无法匹配，如 :first-line :first-letter 1var matches = document.querySelectorAll(\"div.note, div.alert\"); 📌 获取某个元素下包含的所有子元素，查看其属性： 123456789let form = document.getElementById('sub-form')let arr = Array.prototype.slice.call(form)/* [input#sb_form_q.b_searchbox, input#sb_form_go.b_searchboxSubmit, input#sa_qs, input]0:input#sb_form_q.b_searchbox1:input#sb_form_go.b_searchboxSubmit2:input#sa_qs3:input */ 文档结构和遍历有时需要查找文档中与之结构上相关的部分（父亲、兄弟、子女）。 文档从概念上可以看做是一棵节点对象树。 作为节点树的文档Document对象、它的 Element 对象和文档中表示文本的 Text 对象都是 Node 对象（见上图），Node 定义了几个重要属性： parentNode 节点的父节点 childNodes 只读的子节点数组对象 firstChild、lastChild 该节点的第一个和最后一个子节点 nextSlibling、previpursSlibling 📌 节点的兄弟节点中的前一个和下一个 具有相同父节点的两个节点为兄弟节点 节点的顺序反映了它们在文档中出现的顺序 nodeType 该节点的类型 nodeValue Text 节点或 Comment 节点的文本内容 nodeName 元素的标签名，以大写形式表示 快速获取元素的实践：1234//第一个子节点下面的第二个子节点document.childNodes[0].childNodes[1];//第一个子节点下面的第一个子节点的前一个兄弟节点document.firstChild.firstChild.nextSibling 作为元素树的文档etc… 似乎在开发中用不到","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"脚本文档化","slug":"脚本文档化","permalink":"https://luoyec.cn/tags/脚本文档化/"}]},{"title":"JavaScript事件处理上","date":"2017-12-24T14:54:12.000Z","path":"2017/12/24/cjqoyqt4800ibhl6pk8t0u20e/","text":"JavaScript事件处理上客户端 JavaScript 程序采用了异步事件驱动编程模型，在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web 浏览器就会产生事件。 如果 JavaScript 关注特定类型的时间，那么它可以注册当这类时间发生时要调用的一个或多个函数。 术语了解相关的术语，有助于继续深入学习事件和事件处理。 事件类型（event type） 是一个用来说明发生什么事件的字符串，有时也被事件名字（event name） 事件目标（event targe） 是发生的事件或与之相关的对象，当将事件是，必须同时指明类型和目标。 Window、Document、Element是最常见的事件目标 事件处理程序（event handler） 事件处理程序（event handler）或事件监听程序（event listener） 是处理响应事件的函数。 当对象在注册的事件程序被调用时，我们有时会说浏览器“触发”和“派发”了事件 事件对象（event object） 事件对象（event object）是与特定事件并且包含有关该事件详细信息的对象。 事件对象作为参数传递给事件处理程序 所有的事件对象都有用来指定事件类型的 type 属性和指定事件目标的 targe 属性。 事件传播（event propagation） 事件传播（event propagation）是浏览器决定哪个对象触发其事件处理程序的过程。 当文档元素发生某个类型的事件时，他们会在文档树上向上传播或“冒泡”（bubble） 事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播，这样能停止冒泡并将无法再容器元素上触发的处理程序。 事件捕获（event capturing） 是事件传播的另一种形式，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前拦截（或“捕获”）它 IE8 版本之前不支持事件捕获 事件的默认操作 例如在超链接的点击事件，浏览器的默认操作是按照超链接重新加载页面 事件处理程序可以通过返回一个适当的值、调用事件对象的某个方法设置事件对象的某个属性来阻止默认操作的发生。 事件类型随着 Web 平台发展到包含更强大的API，事件集合随之越来越大，这些新事件主要有三个来源： 3级 DOM 事件规范 HTML5 规范衍生规范的大量新API定义的事件 基于触摸和支持 JavaScript 的移动设备的出现 事件大致可以分成几类，了解这些分类有助于理解和组织事件列表： 依赖于设备的输入事件 鼠标和键盘， mousedown、mousemove、mouseup、keydown、keyup 独立与设备的输入事件 这些事件没有直接相关的特定输入设备，如 click 事件，可以通过鼠标点击发生也可以通过键盘或者其他设备触发 用户界面事件 用户界面事件，通常出现定义 Web 程序用户界面的 HTML 表单元素上。 包括文本输入域获取键盘焦点的 focus 事件、用户改变表单元格的 change 事件、表单提交 submit 事件 状态变化事件 不是由于用户活动而是由于网络或浏览器活动出发、用来标识某种声明周期或相关状态的变化 例如，window 的 onload 事件，loadstart、progress、loadend等 I/O 过程的异步通知 特定的 API 事件 HTML5 及相关规范定义的大量 Web API 都有自己的事件类型 如拖放 API，dragstart、dragenter，&lt;video /&gt; 等 传统事件类型 表单事件 表单事件是所有事件类型中最稳定且得到最良好支持的那部分 表单提交和重置，会触发 submit 和 reset 事件 类按钮元素（如单选、复选）交互时，click 事件 用户通过文字、选择选项或选择复选框改变表单元素状态时，通常会触发 change 事件 对于文本输入域，只有当焦点移动到其他元素才会触发 change 事件 改变表单元素焦点时会触发，focus 和 blur 事件 通过事件处理程序能取消 submit 和 reset 事件的默认操作 Window 事件 Window 事件是指事件的发生于浏览器窗口本身而非窗口中显示的任何特定文档内容相关 load 事件，是当文档和其他所有的外部资源（比如图片）完全加载并显示给用户时才会触发 unload事件，是当用户离开文档转向其他文档是触发它 resize、scroll事件，当用户调整浏览器窗口大小、滚动时会被触发，但其事件对象时非常普通的 Event 对象，没有指定调整大小或发生滚动的详细信息属性 鼠标事件 当用户在文档上移动单击鼠标都会产生鼠标事件，这些事件在鼠标指针所对应的最深嵌套元素上触发， 但他们会冒泡直到文档的最顶层 事件对象中包含了，鼠标的位置和按键状态 对于 click 事件， detail 属性制定了其是单击、双击、还是三击 mousemove 事件，当用户移动鼠标时触发，在该事件中，一定不能触发计算密集型任务 mouseover 事件，当用户鼠标指针悬停到新元素上时触发，mouseout，不在悬停在某个对象上时触发 mousewhell 事件，当用户鼠标滚轮时触发 键盘事件 用户每次按下或释放键盘上的按键时都会产生事件 传递给事件处理程序的对象中有 keyCode 字段 ， 它指定按下或释放的键是哪一个 keydown、keyup、keypress 事件，键盘按下、释放，keypress 按住时可以产生连续多个相同的字符 DOM 事件DOM的分级：根据W3C DOM规范，DOM是HTML与XML的应用编程接口（API），DOM将整个页面映射为一个由层次节点组成的文件。有1级、2级、3级共3个级别。 1级DOM：1级DOM在1998年10月份成为W3C的提议，由DOM核心与DOM HTML两个模块组成。DOM核心能映射以XML为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML通过添加HTML专用的对象与函数对DOM核心进行了扩展。 2级DOM鉴于1级DOM仅以映射文档结构为目标，DOM 2级面向更为宽广。通过对原有DOM的扩展，2级DOM通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。同时也对DOM 1的核心进行了扩展，从而可支持XML命名空间。 *2级DOM引进了几个新DOM模块来处理新的接口类型： DOM视图：描述跟踪一个文档的各种视图（使用CSS样式设计文档前后）的接口； DOM事件：描述事件接口； DOM样式：描述处理基于CSS样式的接口； DOM遍历与范围：描述遍历和操作文档树的接口；* 3级DOM3级DOM通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展，DOM3包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包括XML Infoset、 XPath、和XML Base。 “0级”DOM当阅读与DOM有关的材料时，可能会遇到参考0级DOM的情况。需要注意的是并没有标准被称为0级DOM，它仅是DOM历史上一个参考点（0级DOM被认为是在Internet Explorer 4.0 与Netscape Navigator4.0支持的最早的DHTML）。 HTML5 事件HTML5 及相关标准定义了大量新的 Web 应用 API，其中许多 API 都定义了事件。 音频和视频 &lt;audio&gt; 和 &lt;video&gt; 拖放事件 表单的新特性，表单验证机制，包括验证失败时在表单元素上会触发 invalid 事件 离线 Web 应用的支持 许多新的API应用使用 message 事件进行异步通信。跨文档通信 API 允许一台服务器上的文档能通过和另一台服务器上的文档脚本交换消息。 XMLHttpRequest 规范定义了一系列事件来追踪异步的 I/O 进度，loadstart、progress、loadend 触摸屏和移动设备事件可以在 Apple 开发者中心 查询更多信息","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"https://luoyec.cn/tags/事件/"}]},{"title":"JavaScript模块","date":"2017-12-15T17:03:11.000Z","path":"2017/12/16/cjqoyqsya001chl6pgoyetox5/","text":"JavaScript 模块JavaScript 模块在平时开发中都会接触到，但缺乏对模块整体理解，本文档试着从前端模块的发展历程作为切入点，以 ‘CommonJS’ 和 ‘ES6’ 模块作为深入学习的方向，深入理解和掌握 JavaScript 模块 JS 模块发展史JavaScript 模块化七日谈前端模块化开发那点历史AMD, CMD, CommonJS 和 UMD CommonJS 模块系统Node.js 模块 CommonJs 是一个由开源开发者组成的团队，主要围绕 JavaScript 实现一些 API 及开展研发实践。 该团队提出了一个 avaScript 模块规范。每个文件都可当作一个模块，并且每个文件可以访问两个对象：require 和 export。require 用来接收字符串（模块名），并返回该模块输出的对象。 export 对象用来导出该模块的方法和变量。require 方法返回的就是 export 对象。模块同步加载。服务器端 JavaScript 引擎 Node.js 就是用的这个模块系统。 异步模块定义（AMD）AMD 是一个采用异步方式加载依赖模块的模块系统。 如果模块在不同文件中，它们将采用 XHR 进行加载。某一模块将等其所依赖的模块一一加载后才会被执行。 AMD 模块必须是一个函数，并作为参数传入define 函数中。函数的返回值将传输给所有依赖的模块，所获得返回值又将作为参数传给模块方法。Require.js 库中实现了 AMD XHR 英文全名 XmlHttpRequest，中文可以解释为可扩展超文本传输请求。Xml 可扩展标记语言，Http 超文本传输协议，Request 请求。XMLHttpRequest 对象可以在不向服务器提交整个页面的情况下，实现局部更新网页。 百度百科：XMLHTTPRequest TypeScript 模块TypeScript，作为 JavaScript 的超集，也提供了一个模块系统。 当它被编译时，便开始使用 JavaScript 模块模式。TypeScript 模块使用 module 关键字定义，任何被输出的对象必须使用export 关键字定义。 import 关键字用来将其它模块加载入模块中，并捕捉该模块导出的对象。TypeScript 模块是同步加载的。 ES6 模块系统ES6 模块系统 ES6 模块系统启发于上述现有模块系统，它具有以下特性： 使用 export 关键词导出对象。这个关键字可以无限次使用 使用 import 关键字将其它模块导入某一模块中。它可用来导入任意数量的模块 支持模块的异步加载 为加载模块提供编程支持 阻塞非阻塞与同步异步怎样理解阻塞非阻塞与同步异步的区别？ “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。 同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 所谓同步，就是在发出一个 _调用_ 时，在没有得到结果之前，该 _调用_ 就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由 调用者 主动等待这个 _调用_ 的结果。 而异步则是相反，_调用_ 在发出之后，这个调用就直接返回了，所以没有返回结果。 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 典型的异步编程模型比如 Node.js 举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。 阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"模块","slug":"模块","permalink":"https://luoyec.cn/tags/模块/"}]},{"title":"ES6 模块系统","date":"2017-12-15T16:56:35.000Z","path":"2017/12/16/cjqoyqsxk000ahl6ppfuwsfd7/","text":"【ES6专栏】全面解析 ECMAScript 6 模块系统阮一峰：ECMAScript 6 入门 ES6 模块系统ES6 模块系统它具有以下特性： 使用 export 关键词导出对象。这个关键字可以无限次使用 使用 import 关键字将其它模块导入某一模块中。它可用来导入任意数量的模块 支持模块的异步加载 为加载模块提供编程支持 导出对象在现有的模块系统中，每个 JavaScript 代码文件在 ES6 中都是一个模块。 只有模块中的对象需要被外部调用时，模块才会输出对象，其余则都是模块的私有对象。该处理方式将细节进行封装，仅导出必要的功能。 从模块里导出对象，ES6 为我们提供了不同方法，见下面的讨论。 内联导出ES6 模块里的对象可在创建它们的声明中导出。一个模块中可无数次使用 export，所有的对象将被一起导出。请看下面的例子： 123456789101112131415161718192021222324export class Employee &#123; constructor(id, name, dob) &#123; this.id = id; this.name = name; this.dob = dob; &#125; getAge() &#123; return new Date().getFullYear() - this.dob.getYear(); &#125;&#125;export function getEmployee(id, name, dob) &#123; return new Employee(id, name, dob);&#125;export const CONFIG = '10.0.0.1';var emp = new Employee(1, 'Rina', new Date(1987, 1, 22));// console.log(emp);/* * 案例中的模块导出了两个对象： Employee类，getEmployee函数。因对象emp未被导出，所以其仍为模块私有。*/ 导出一组对象尽管内联导出很有效，但在大规模模块中，它就很难发挥作用了，因为我们可能无法追踪到模块导出来的对象。在这种情况下，更好的办法是，在模块的末尾单独进行导出声明，以导出该模块中的全部对象。 使用单独导出声明重写上一案例中的模块，结果如下： 12345678910111213141516171819202122232425class Employee &#123; constructor(id, name, dob) &#123; this.id = id; this.name = name; this.dob = dob; &#125; getAge() &#123; return new Date().getYear() - this.dob.getYear(); &#125;&#125;function getEmployee(id, name, dob) &#123; return new Employee(id, name, dob);&#125;var x = new Employee(1, 'Rina', new Date(1987, 1, 22));export &#123; Employee, getEmployee &#125;;/** * 在导出时，重命名对象也是可以的。如下例所示， * Employee在导出时名字改为了Associate， * 函数GetEmployee改名为getAssociate。 */// export &#123; Employee as Associate, getEmployee as getAssociate &#125;; Default导出使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。它既可以用于内联导出，也可以用于一组对象导出声明中。 下面案例展示了在组导出语句中使用default： 1234export default &#123; Employee, getEmployee &#125;; 导入模块现有模块可以使用关键字import导入到其它模块。一个模块可以被导入任意数量的模块中。下文展示了导入模块的不同方式。 无对象导入如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中。如下面案例所示： 1import './es6_module/doSomethings'; 导入默认对象采用Default导出方式导出对象，该对象在import声明中将直接被分配给某个引用，如下例中的“d”。 1import d from './module1.js'; 导入命名的对象正如以上讨论的，一个模块可以导出许多命名对象。如果另一模块想导入这些命名对象，需要在导入声明中一一列出这些对象。举个例子： 1import &#123;Employee, getEmployee&#125; from './module1.js'; 当然也可在同一个声明中导入默认对象和命名对象。这种情况下，默认对象必须定义一个别名，如下例。 1import &#123;default as d, Employee&#125; from './module1.js'; 导入所有对象以上几种情况，只有import声明中列举的对象才会被导入并被使用，而其它对象则无法在导入模块中使用。当然，这就要求用户了解哪些对象可以导出并加以利用。 如果模块导出大量对象，另一模块想引入所有导出的对象，就必须使用如下声明： 1import * as allFromModule1 from './module1.js'; 可编程式的按需导入如果想基于某些条件或等某个事件发生后再加载需要的模块，可通过使用加载模块的可编程API（programmatic API）来实现。使用 System.import 方法，可按程序设定加载模块。这是一个异步的方法，并返回 Promise。 该方法的语法示例如下： 123456System.import('./module1.js') .then(function(module1)&#123; //use module1 &#125;, function(e)&#123; //handle error &#125;); 如果模块加载成功且将导出的模块成功传递给回调函数，Promise 将会通过。如果模块名称有误或由于网络延迟等原因导致模块加载失败，Promise 将会失败。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"模块","slug":"模块","permalink":"https://luoyec.cn/tags/模块/"}]},{"title":"MySQL 基础 一","date":"2017-12-11T23:56:10.000Z","path":"2017/12/12/cjqoyqsz0002uhl6prh8lgeuq/","text":"数据库与关系型数据库数据库数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。 关系型数据库所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS 术语 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 Mysql数据库MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 安装验证安装 12luoyecs-iMac:~ luoyec$ mysqladmin --versionmysqladmin Ver 8.42 Distrib 5.7.20, for macos10.12 on x86_64 检查 MySql 服务器是否启动 123luoyecs-iMac:~ luoyec$ ps -ef | grep mysqld 74 856 1 0 10:17上午 ?? 0:00.72 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring --early-plugin-load=keyring_file=keyring_file.so 501 959 635 0 10:26上午 ttys002 0:00.01 grep mysqld 关闭目前运行的 MySQL 服务器 1$ mysqladmin -u root -p shutdown 基础SQL语句SELECTSELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 1SELECT name,country FROM Websites; SELECT DISTINCTSELECT DISTINCT 语句用于返回唯一不同的值, 也就是去掉列中重复值。12SELECT DISTINCT column_name,column_nameFROM table_name; WHEREWHERE 子句用于提取那些满足指定标准的记录。 下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 的所有网站：1SELECT * FROM Websites WHERE country='CN'; 运算符： AND &amp; OR AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR运算符显示一条记录。 下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 且id排名大于 2” 的所有网站： 1SELECT * FROM Websites WHERE country='CN' AND id&gt;2; 选取 id 等于2或者等于3的所有数据。 1SELECT * FROM Websites WHERE id=3 OR id=2; 您也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）。“Websites” 表中选取 alexa 排名大于 “15” 且国家为 “CN” 或 “USA” 的所有网站： 123SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); ORDER BY ORDER BY 关键字用于对结果集进行排序。 ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。 123SELECT column_name,column_nameFROM table_nameORDER BY column_name,column_name ASC|DESC; 选取所有网站，按id降序 1SELECT * FROM Websites ORDER BY id DESC; ORDER BY 多列的时候，先按照第一个column name排序，在按照第二个column name排序；如上述教程最后一个例子： 先将country值这一列排序，同为CN的排前面，同属USA的排后面； 然后在同属CN的这些多行数据中，再根据alexa值的大小排列。 ORDER BY 排列时，不写明ASCDESC的时候，默认是ASC。 INSERT INTOINSERT INTO 语句用于向表中插入新记录。 INSERT INTO 语句可以有两种编写形式。 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： 12INSERT INTO table_nameVALUES (value1,value2,value3,...); 第二种形式需要指定列名及被插入的值： 12INSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...); 向表中插入一个新行 12345-- id是自动更新的，可以省略INSERT INTO Websites (id, app_name, url, country) VALUES (4, 'bilibili', 'wwww.bb.com', 'JP');-- 只在url, country列插入数据INSERT INTO Websites (url, country) VALUES ('wwww.bib.com', 'JP'); UPDATEUPDATE 语句用于更新表中已存在的记录。 123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; ⚠️ 请注意 SQL UPDATE 语句中的 WHERE 子句！ WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE子句，所有的记录都将被更新！ 12-- 更新ID大于3的数据UPDATE Websites SET country='CN' WHERE id&gt;3; DELETEDELETE 语句用于删除表中的行。 12DELETE FROM table_nameWHERE some_column=some_value; ⚠️ 请注意 SQL DELETE 语句中的 WHERE 子句！ WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！ 12-- 删除app_name为''，且id&gt;3的行DELETE FROM Websites WHERE app_name='' AND id&gt;3;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://luoyec.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://luoyec.cn/tags/mysql/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"https://luoyec.cn/tags/关系型数据库/"},{"name":"nodejs","slug":"nodejs","permalink":"https://luoyec.cn/tags/nodejs/"}]},{"title":"Node.js 模块","date":"2017-12-09T06:40:43.000Z","path":"2017/12/09/cjqoyqsz40033hl6pjamzs2h1/","text":"Node.js 中文文档 modules《Node.js 实战》流程图工具 processon Node 功能的组织及重用 用目录和单独的文件组织起来的代码找起来要比整个程序代码都放在一个长文件中找起来更容易。 重用的问题 在某些语言中，例如PHP和Ruby，整合另一个文件（我们称之为“include”文件）中的逻辑，可能意味着在被引入文件中执行的逻辑会影响全局作用域。 也就是说被引入文件常见的任何变量，以及声明的任何函数都可能会覆盖包含它的应用程序所创建的变量和声明的函数。 在 PHP 中可以使用命名空间避免这个问题，Ruby 通过模块也提供了类似的功能。 Node的重用Node 的做法不会让开发者有机会在不经意间污染全局命名空间。 Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。 Node 模块允许你从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变量不值一个，那么它通过设定 exports 对象的属性来指明它们。如果模块只返回一个函数或变量，则可以设定 module.exports 属性。 exports假设有一个名为 foo.js 的文件： 123//foo.jsconst circle = require('./circle.js');console.log(`半径为 4 的圆的面积是 $&#123;circle.area(4)&#125;`); 在第一行中，foo.js 加载了同一目录下的 circle.js 模块。 circle.js 文件的内容为： 123456//circle.jsconst &#123; PI &#125; = Math;exports.area = (r) =&gt; PI * r ** 2;exports.circumference = (r) =&gt; 2 * PI * r; circle.js 模块导出了 area() 和 circumference() 两个函数。 通过在特殊的 exports 对象上指定额外的属性，函数和对象可以被添加到模块的根部。 模块内的本地变量是私有的，因为模块被 Node.js 包装在一个函数中。 module.exports如下，bar.js 会用到 square 模块，square 导出一个构造函数： 123const square = require('./square.js');const mySquare = square(2);console.log(`正方形的面积是 $&#123;mySquare.area()&#125;`); square 模块定义在 square.js 中： 123456// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`module.exports = (width) =&gt; &#123; return &#123; area: () =&gt; width ** 2 &#125;;&#125;; 使用场景如果只需要从模块中得到一个函数，那么从 require 中返回一个函数的代码要比返回一个对象的代码更优雅。 实例，以下是一个货币转换函数： 123456//test-currency.jsvar Currency = require('./currency');var canadianDollar = 0.91;var currency = new Currency(canadianDollar);console.log(currency.canadianToUS(50)); 123456789101112131415161718192021//currency.jsvar Currency = function(canadianDollar) &#123; this.canadianDollar = canadianDollar;&#125;;//随机一个两位小数Currency.prototype.roundTwoDecimals = function(amount) &#123; return Math.round(amount * 100) / 100;&#125;;//加元转美元Currency.prototype.canadianToUS = function(candian) &#123; return this.roundTwoDecimals(candian * this.canadianDollar);&#125;;//美元转加元Currency.prototype.USToCanadian = function(us) &#123; return this.roundTwoDecimals(us / this.canadianDollar);&#125;;module.exports = Currency; 另一个实例，搜索二叉树。 用 node_modules重用模块Node 中有一个独特的模块引入机制，可以不必知道模块在文件系统中具体位置，这个机制就是 node_modules 目录。 例如前面的 var Currency = require(&#39;./currency&#39;);，不写 ./, node 会遵照几个规则来寻找这个模块。 用环境变量 NODE_PATH 可以改变 Node 模块的默认路径。 注意事项 如果模块式目录，在木块目录中定义模块文件必须被命名为 index.js ，除非你在这个目录下 packjson.json 文件里特别指明。 Node 能把模块作为对象缓存起来。如果程序中两个文件引入了相同模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。 require 是 Node 中少数几个同步 I/O 操作，在 I/O 密集的地方尽量不要用 require， 所有同步调动都会阻塞 Node，直到调用完成才能做其他事情。所以通常只在程序最初加载时才使用 require 和其他同步操作。","categories":[{"name":"node","slug":"node","permalink":"https://luoyec.cn/categories/node/"}],"tags":[{"name":"模块","slug":"模块","permalink":"https://luoyec.cn/tags/模块/"},{"name":"node","slug":"node","permalink":"https://luoyec.cn/tags/node/"},{"name":"module","slug":"module","permalink":"https://luoyec.cn/tags/module/"}]},{"title":"React路由过渡动画","date":"2017-12-04T05:40:18.000Z","path":"2017/12/04/cjqoyqsza003jhl6p2uwvpymo/","text":"React 路由过渡动画 Animated page transitions with React Router 4, ReactTransitionGroup andAnimated 中文翻译： 英文原文： Animated.template文档 演示 Demo 原文中使用 create-react-app 从头构建路由动画，本文档只在如何在实际项目中使用路由过渡动画。 安装 react-transition-group需要注意的是开源作者修改了 V2 版本的 API，目前只能使用 V1 版本。 1$ yarn add react-transition-group@^1.2.0 &lt;TransitionGroup /&gt;接下来只需简单的几个步骤 替换路由默认的渲染方式，使用 &lt;TransitionGroup /&gt; 包裹路由组件并使用其中的路由渲染方法来渲染我们的组件。 在路由入口文件 `src/App.js` 或是 `App.js` 中引入 `TransitionGroup` 1import TransitionGroup from 'react-transition- group/TransitionGroup'; 为 Transition Group 渲染 添加一个特殊的方法，其只渲染单个 child，在 class App extends ... 之前添加。 1234 const firstChild = props =&gt; &#123; const childrenArray = React.Children.toArray(props.children);return childrenArray[0] || null; &#125;; 修改原有的路由，并用 TransitionGroup 包裹 1234567891011 &lt;Routeexact path=\"/\" children=&#123;(&#123; match, ...rest &#125;) =&gt; (&lt;TransitionGroup component=&#123;firstChild&#125;&gt; &#123;match &amp;&amp; &lt;Home &#123;...rest&#125; /&gt;&#125;&lt;/TransitionGroup&gt; )&#125;/&gt; &lt;Routepath=\"/subpage\" children=&#123;(&#123; match, ...rest &#125;) =&gt; (&lt;TransitionGroup component=&#123;firstChild&#125;&gt; &#123;match &amp;&amp; &lt;Subpage &#123;...rest&#125; /&gt;&#125;&lt;/TransitionGroup&gt; )&#125;/&gt; 附：实际项目中的配置： 123456789101112131415161718192021222324252627282930const Root = () =&gt; &#123;return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Switch&gt; &#123;routeList.mainRoute.map(item =&gt; &#123; return ( &lt;Route path=&#123;item.path&#125; key=&#123;item.path&#125; children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &lt;TransitionGroup component=&#123;firstChild&#125;&gt; &#123;match &amp;&amp; ( &lt;item.component &#123;...rest&#125; match=&#123;match&#125; /&gt; )&#125; &lt;/TransitionGroup&gt; )&#125; /&gt; ); &#125;)&#125; &#123;&lt;Redirect from=\"/\" to=&#123;routePath.App&#125; /&gt;&#125; &lt;/Switch&gt; &lt;/Router&gt; &lt;/Provider&gt; );&#125;; 新的生命周期方法完成上面的工作，现在你有全访问新的生命周期方法了。 1componentWillAppear() , componentWillEnter() and componentWillLeave() 创建高阶Animated组件创建 AnimatedWrapper.js 组件代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from 'react';import * as Animated from 'animated/lib/targets/react-dom';import TransitionGroup from 'react-transition-group/TransitionGroup';const AnimatedWrapper = WrappedComponent =&gt; class AnimatedWrapper extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; animate: new Animated.Value(0) &#125;; &#125; componentWillAppear(cb) &#123; // console.log('componentWillAppear'); Animated.spring(this.state.animate, &#123; toValue: 1 &#125;).start(); cb(); &#125; componentWillEnter(cb) &#123; // console.log('componentWillEnter'); setTimeout( () =&gt; Animated.spring(this.state.animate, &#123; toValue: 1 &#125;).start(), 250 ); cb(); &#125; componentWillLeave(cb) &#123; // console.log('componentWillLeave'); Animated.spring(this.state.animate, &#123; toValue: 0 &#125;).start(); setTimeout(() =&gt; cb(), 175); &#125; render() &#123; const style = &#123; opacity: Animated.template`$&#123;this.state.animate&#125;`, transform: Animated.template` translate3d(0,$&#123;this.state.animate.interpolate(&#123; inputRange: [0, 1], outputRange: ['12px', '0px'] &#125;)&#125;,0) `, height: Animated.template`100%` &#125;; return ( &lt;Animated.div style=&#123;style&#125; className=\"animated-page-wrapper\"&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/Animated.div&gt; ); &#125; &#125;;export default AnimatedWrapper; 上述代码主要做了这几件事 创建一个组件包裹我们的路由组件 从 TransitionGroup 接收声明周期方法，用以完成animation 使用 Animated 创建一个变量，可以用它来对封装的子组件中的 div 的不同样式属性实现动画效果 在路由组件中的使用1234567891011121314import React, &#123; Component &#125; from 'react';import AnimatedWrapper from './AnimatedWrapper';class HomeComponent extends Component &#123; render() &#123; return ( &lt;div className=\"page\"&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;p&gt;Hello from the home page!&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;const Home = AnimatedWrapper(HomeComponent);export default Home; 当路由切换的的时候，我们就能看到过渡效果了！","categories":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/tags/React/"},{"name":"路由动画","slug":"路由动画","permalink":"https://luoyec.cn/tags/路由动画/"}]},{"title":"二叉搜索树","date":"2017-12-03T19:30:51.000Z","path":"2017/12/04/cjqoyqt4g00iwhl6pgfr6hm8s/","text":"二叉搜索树《学习JavaScri数据结构与算法》 数据结构 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。百度百科：数据结构 为什么要学习数据结构？程序=算法+数据结构，计算机程序设计的本质是将业务逻辑转换成数理逻辑，通过逻辑推理以及数理运算解决客观世界存在的困难，而算法和数据解结构就是数理逻辑的推演模式和展现方式。 二叉搜索树 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。百度百科：二叉搜索树 一些名词概念一个节点可以有祖先及诶单和后台，一个节点的祖先（除了根节点）包括父节点、祖父节点、曾祖父节点… 子树：子树由节点和它的后台组成 节点的深度：节点的深度取决于它的祖先节点的数量 树的高度：高度取决于所有节点深度的最大值 树的遍历 前序遍历前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。前序遍历结果：ABDECF 前序遍历可用于复制一棵已有的二叉树，或是打印一个结构化的文档。 中序遍历指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式 以从最小到最大的顺序访问所有节点，中序遍历的一种应用就是排序操作。 后序遍历指先访问子树，然后访问根的遍历方式。其中的一种应用是计算文件系统中一个目录和它的子目录中所有文件所占空间的大小。 JavaScript 实现搜索树创建一棵树1234567891011121314151617181920212223242526272829303132333435function BinaryBree(key) &#123; //构造节点方法 var Node = function (key) &#123; this.key = key this.left = null this.right = null &#125; //二叉树根节点 var root = null //二叉树插入接口实现 var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; node.left = newNode &#125; else &#123; insertNode(node.left, newNode) &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode &#125; else &#123; insertNode(node.right, newNode) &#125; &#125; &#125; &#125; var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13] var binaryBree = new BinaryBree() nodes.forEach(function (key) &#123; binaryBree.insert(key) &#125;) 中序遍历123456789101112131415//中序遍历接口 this.inOrderTraverse = function (callback) &#123; inOrderTraverseNode(root, callback) &#125; //中序遍历接口实现方法 var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; inOrderTraverseNode(node.left, callback) callback(node.key) inOrderTraverseNode(node.right, callback) &#125; &#125; 前序遍历12345678910111213//前序遍历接口 this.preOrderTraverse = function (callback) &#123; preOrderTraverseNode(root, callback) &#125; //前序遍历接口实现 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) &#125; &#125; 后续遍历12345678910111213//后续遍历接口 this.postOrderTraverse = function (callback) &#123; postOrderTraverseNode(root, callback) &#125; //前序遍历接口实现 var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback) postOrderTraverseNode(node.right, callback) callback(node.key) &#125; &#125; 查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546//查找最小值 this.min = function () &#123; return minNode(root) &#125; var minNode = function (node) &#123; if (node) &#123; //如果当前节点存在左节点，继续执行循环 while (node &amp;&amp; node.left !== null) &#123; node = node.left &#125; &#125; return node.key &#125; //查找最大值 this.max = function () &#123; return maxNode(root) &#125; var maxNode = function (node) &#123; if (node) &#123; //如果当前节点存在右节点，继续执行循环 while (node &amp;&amp; node.right !== null) &#123; node = node.right &#125; &#125; return node.key &#125; //查找指定数值 this.search = function (key) &#123; return searchNode(root, key) &#125; var searchNode = function (node, key) &#123; if (node === null) &#123; return false &#125; if (node &lt; node.key) &#123; return searchNode(node.left, key) &#125; else if (key &gt; node.key) &#123; return searchNode(node.right, key) &#125; else &#123; return true &#125; &#125; 删除12345678910111213141516171819202122232425262728293031323334353637383940414243444546//删除指定指定节点接口 this.remove = function (key) &#123; root = removeNode(root, key) &#125; //查找排序二叉树中最小节点 var finMinNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left &#125; &#125; return node &#125; //删除指定指定节点实现 var removeNode = function (node, key) &#123; if (node === null) &#123; return null &#125; if (key &lt; node.key) &#123; node.left = removeNode(node.left, key) return node &#125; else if (key &gt; node.key) &#123; node.right = removeNode(node.right, key) return node &#125; else &#123; //左右都没有节点则为叶子节点，可直接删除 if (node.left === null &amp;&amp; node.right === null) &#123; node = null return node &#125; //只有右节点，将当前节点替换成右节点 if (node.left === null) &#123; node = node.right return node &#125; else if (node.right === null) &#123; //只有左节点，将当前节点替换成做左节点 node = node.left return node &#125; //拥有左右节点的情况 var aux = finMinNode(node.right) node.key = aux.key node.right = removeNode(node.right, aux.key) return node &#125; &#125; 完整项目文件","categories":[{"name":"JS数据结构与算法","slug":"JS数据结构与算法","permalink":"https://luoyec.cn/categories/JS数据结构与算法/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://luoyec.cn/tags/二叉树/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://luoyec.cn/tags/算法与数据结构/"}]},{"title":"All About React Router 4","date":"2017-11-18T16:08:35.000Z","path":"2017/11/19/cjqoyqt4400i4hl6p4mwe89b5/","text":"原文： All About React Router 4 示例代码 React Router 4 带来新的API以及新的心智模型 Inclusive Routing 引入路由123456789101112 const PrimaryLayout = () =&gt; ( &lt;div className=\"primary-layout\"&gt; &lt;header&gt; Our React Router 4 App &lt;Route path=\"/users\" component=&#123;UsersMenu&#125; /&gt; &lt;/header&gt; &lt;main&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;) UsersMenu 和 UsersPage 可以通过同一个路由被渲染到当前页面中， exact 精确匹配路由 &#39;/&#39; Switch 路由组当你需要将路由匹配到一个路由组时，使用 Switch 可以匹配到唯一路由 12345678910111213const PrimaryLayout = () =&gt; ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users/add\" component=&#123;UserAddPage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UsersPage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt;) 当使用 Switch 时，只有一个路由会被渲染。 我们仍然需要使用 exact 当设 HomePage 为首选被渲染的组件。否则等浏览到 /users 或则会使 ‘/users/add’ 时，HomePage 组件仍然会被渲染，如果发生同时渲染，那么先渲染的组件排在最前面。 当路由匹配 /users/add 时，也会同时匹配到 /users 路由，为确保优先渲染UserAddPage 可以将这个组件写到 UsersPage 前面，如果相反，则调换顺序。当然也可以将所有路由设置为 exact 精确匹配，这样就不存在先后问题。 Redirect 重定向当 Switch 没有匹配到任意一个路由的时候，将会发生路由重定向。 “Index Routes” and “Not Found” （已移除）在 V4 中不在使用 &lt;IndexRoute&gt;, 而是使用 &lt;Route exact&gt; 精确匹配路由。 如果没有路由被匹配，可以使用 &lt;Switch&gt; 和 &lt;Redirect&gt; 去重定向到默认路由，或者重定向到 404页面 Nested Layouts 嵌套布局这里展示两种不同的写法，以及为什么第二种是更好的写法 第一种采用 exact 精确匹配路由 1234567891011121314151617const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/users/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;Route path=\"/products\" exact component=&#123;BrowseProductsPage&#125; /&gt; &lt;Route path=\"/products/:productId\" component=&#123;ProductProfilePage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; )&#125; 这种写法在技术上是可行的，但是问题在于，props.match 是通过 &lt;Route&gt; 组件传递的。组件 BrowseUsersPage 的子组件并不是通过 &lt;Route&gt; 嵌套路路由中，子组件是不能直接拿到 props.match的。 当然这里可以通过高阶组件的方式将子组件包装：withRouter() 第二种写法在第一种写法的基础上做了修改，通过路由嵌套的方式布局组件，并且不再需要使用 exact 精确匹配路由，也不必使用 withRouter() 加工组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const PrimaryLayout = () =&gt; ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UserSubLayout&#125; /&gt; &lt;Route path=\"/products\" component=&#123;ProductSubLayout&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt;);const UserSubLayout = () =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=\"/users\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/users/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;);const UserSubLayout = props =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;props.match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;props.match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;); Match 匹配对象Match 对象提供了一下几种属性 params - (object) Key/value pairs parsed from the URL corresponding to the dynamic segments of the path isExact - (boolean) true if the entire URL was matched (no trailing characters) path - (string) The path pattern used to match. Useful for building nested s url - (string) The matched portion of the URL. Useful for building nested s match.path vs match.url 当路由不携带参数是两者的输出是相同的字符串，尝试打印这两者。 当路由匹配到例如 /users/5 时，match.url 将会输出 “/users/5” ; 而 match.path 输出 “/users/:userId”. Avoiding Match Collisions 避免匹配冲突123456789101112131415const UserSubLayout = (&#123; match &#125;) =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route exact path=&#123;props.match.path&#125; component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/add`&#125; component=&#123;AddUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId/edit`&#125; component=&#123;EditUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;) path-to-regexp 用于校验路由参数 12345678var re = pathToRegexp('/:foo(\\\\d+)')// keys = [&#123; name: 'foo', ... &#125;]re.exec('/123')//=&gt; ['/123', '123']re.exec('/abc')//=&gt; null Authorized Route 路由认证、权限管理根据用户登录状态管理其浏览路由的权限是应用中很常见的功能 with the help of v4 docs 1234567891011121314class App extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/auth\" component=&#123;UnauthorizedLayout&#125; /&gt; &lt;AuthorizedRoute path=\"/app\" component=&#123;PrimaryLayout&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ) &#125;&#125; 可以结合 react redux设计权限管理功能，&lt;AuthorizedRoute&gt; 组件先检测当前的登录状态，如果是正在登录，则显示 Loading… 如果已经登录则，则跳转到到 &lt;PrimaryLayout&gt; 组件中 如果未登录，则跳转到登录页 123456789101112131415161718192021222324class AuthorizedRoute extends React.Component &#123; componentWillMount() &#123; getLoggedUser() &#125; render() &#123; const &#123; component: Component, pending, logged, ...rest &#125; = this.props return ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; &#123; if (pending) return &lt;div&gt;Loading...&lt;/div&gt; return logged ? &lt;Component &#123;...this.props&#125; /&gt; : &lt;Redirect to=&quot;/auth/login&quot; /&gt; &#125;&#125; /&gt; ) &#125;&#125;const stateToProps = (&#123; loggedUserState &#125;) =&gt; (&#123; pending: loggedUserState.pending, logged: loggedUserState.logged&#125;)export default connect(stateToProps)(AuthorizedRoute) Other mentions 其他&lt;Link&gt; vs &lt;NavLink&gt; 这两个功能一样，都是路由跳转，但是NavLink有一个属性用来显示跳转选中的样式，activeStyle属性，写显示高亮样式的，接收一个对象{} 在我们路由导航有一个to属性 to属性是我们路由的要跳转的路径: 123456789101112131415import React from 'react'import &#123; NavLink &#125; from 'react-router-dom'const PrimaryHeader = () =&gt; ( &lt;header className=\"primary-header\"&gt; &lt;h1&gt;Welcome to our app!&lt;/h1&gt; &lt;nav&gt; &lt;NavLink to=\"/app\" exact activeClassName=\"active\"&gt;Home&lt;/NavLink&gt; &lt;NavLink to=\"/app/users\" activeClassName=\"active\"&gt;Users&lt;/NavLink&gt; &lt;NavLink to=\"/app/products\" activeClassName=\"active\"&gt;Products&lt;/NavLink&gt; &lt;/nav&gt; &lt;/header&gt;)export default PrimaryHeader Dynamic Routes 动态路由在 V4中最好的一部分改变是可以在所有地方包含 &lt;Route&gt; ， 它只是一个 React 组件。 路由将不再是神奇的东西，我们可以用在任何地方，试想一下，当满足条件时，整个路由都可以被路由到。 在这些条件不满足时，我们可以移除那些路由，甚至，可以嵌套路由。 React Router 4 变得更好用是因为这只是一个 Just Components™。","categories":[{"name":"React","slug":"React","permalink":"https://luoyec.cn/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"https://luoyec.cn/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"https://luoyec.cn/tags/react-router/"},{"name":"声明式路由","slug":"声明式路由","permalink":"https://luoyec.cn/tags/声明式路由/"}]},{"title":"Nginx反向代理","date":"2017-11-18T01:46:05.000Z","path":"2017/11/18/cjqoyqt4c00ilhl6pdbuuqn19/","text":"参考资源： Nginx 从听说到学会 Mac Nginx 安装（Brew） 用 nginx 的反向代理机制解决前端跨域问题 什么是 Nginx ==Nginx== 是一款轻量级的 ==Web== 服务器/反向代理服务器及电子邮件 ==（IMAP/POP3）== 代理服务器，并在一个 ==BSD-like == 协议下发行。其特点是占有内存少，并发能力强，事实上 ==nginx== 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 ==nginx== 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。——百度词条 Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接 高度的模块化和自由软件许可证是的第三方模块层出不穷 Nginx 是一个跨平台服务器，可以运行在 Linux, FreeBSD, Solaris, AIX, Mac OS, Windows 等操作系统上 这些优秀的设计带来的极大的稳定性。 Web 服务器lighttpd Lighttpd 是一个具有非常低的内存开销，cpu 占用率低，效能好，以及丰富的模块等特点。lighttpd 是众多 OpenSource 轻量级的 webserver 中较为优秀的一个。支持 FastCGI, CGI, Auth, 输出压缩(output compress), URL 重写,Alias 等重要功能。 Lighttpd 使用 fastcgi 方式运行 PHP,它会使用很少的 PHP 进程响应很大的并发量。 Fastcgi 的优点在于： 从稳定性上看, fastcgi 是以独立的进程池运行来 cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑. 从安全性上看, fastcgi 和宿主的 server 完全独立, fastcgi 怎么 down 也不会把 server 搞垮, 从性能上看, fastcgi 把动态逻辑的处理从 server 中分离出来, 大负荷的 IO 处理还是留给宿主 server, 这样宿主 server 可以一心一意作 IO,对于一个普通的动态网页来说, 逻辑处理可能只有一小部分,大量的图片等静态 IO 处理完全不需要逻辑程序的参与 从扩展性上讲, fastcgi 是一个中立的技术标准, 完全可以支持任何语言写的处理程序 php,Java,Python Apache apache 是世界排名第一的 web 服务器, 根据 netcraft 所作的调查,世界上百分之五十以上的 web 服务器在使用 apache. 1995 年 4 月, 最早的 apache(0.6.2 版)由 apache group 公布发行. apache group是一个完全通过 internet 进行运作的非盈利机构, 由它来决定 apache web 服务器的标准发行版中应该包含哪些内容.准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给 apache group 时,该团体审核它的具体内容, 进行测试 如果认为满意, 该代码就会被集成到 apache 的主要发行版中。 apache 的特性: 几乎可以运行在所有的计算机平台上支持最新的 http/1.1 协议 简单而且强有力的基于文件的配置(httpd.conf)支持通用网关接口(cgi)支持虚拟主机支持 http 认证集成 perl集成的代理服务器可以通过 web 浏览器监视服务器的状态,可以自定义日志支持服务器端包含命令(ssi)支持安全 socket 层(ssl)具有用户会话过程的跟踪能力支持 fastcgi支持 Java Nginx Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的 HTTP 和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器．Nginx 是由俄罗斯人 IgorSysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发. Nginx 以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。但是 Nginx 并不支持 cgi 方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用 FastCGI 方式来执行 PHP 程序。 nginx 做为 HTTP 服务器，有以下几项基本特性： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲 无缓存的反向代理加速，简单的负载均衡和容错 FastCGI，简单的负载均衡和容错模块化的结构。包括 gzipping, byte ranges, chunked responses,以及SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达50,000 个并发连接数。 Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web 响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 nginx 来说基本上是毫无用处的。就稳定性而言,nginx 比 lighthttpd 更胜一筹。 Nginx 支持热部署。它的启动特别容易,并且几乎可以做到 7X24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。 三种服务器比较 Nginx 安装Mac Nginx 安装（Brew） Homebrew1$ man brew 安装 Homebrew 1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 卸载 1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 其他常用命令： 123localhost:~ wany$ brew --version (查看当前电脑所安装的brew版本)localhost:~ wany$ brew update (更新电脑中的brew版本) 通过 brew 安装 Nginx 1$ sudo /usr/local/sbin/nginx 注意事项：安装 nignx, brew 所安装的软件都保存在 :/usr/local/Cellar/nginx 配置文件保存到了：/usr/local/etc/nginx/nginx.conf 建立软连接 1$ ln -s /usr/local/bin/nginx /usr/local/bin/nginx 启动 1$ sudo nginx 重启 1$ sudo nginx -s reload Nginx 反向代理用 nginx 的反向代理机制解决前端跨域问题 什么是跨域以及产生的原因跨域是指 a 页面想获取 b 页面资源，如果 a、b 页面的协议、域名、端口、子域名不同，或是 a 页面为 ip 地址，b 页面为域名地址，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。 跨域情况如下： 跨域常见的解决方法目前来讲没有不依靠服务器端来跨域请求资源的技术 1.jsonp 需要目标服务器配合一个 callback 函数。 2.window.name+iframe 需要目标服务器响应 window.name。 3.window.location.hash+iframe 同样需要目标服务器作处理。 4.html5 的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。 5.CORS 需要服务器设置 header ：Access-Control-Allow-Origin。 6.nginx 反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转 nginx 服务器，用于转发请求。 Nginx 反向代理解决跨域修改配置文件： 路径 12luoyecs-iMac:nginx luoyec$ pwd/usr/local/etc/nginx 修改 nginx.conf 1234567891011121314151617listen 9000; #监听9000端口号， server_name localhost; #当前服务器域名，一般是开发者本地电脑 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; # root html; # 根路径 # index index.html index.htm; #根路径下的入口文件 proxy_pass http://localhost:3000; &#125; location /mobile/ &#123; # 注意这里可以写正则表达式，（匹配规则，用于拦截请求，匹配任何以 /proxy/html/开头的地址，匹配符合以后，停止往下搜索正则） rewrite ^/mobild/(.*)$ /$1 break; #代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如www.c.com/proxy/html/api/msg?method=1&amp;para=2重写。只对/proxy/html/api/msg重写。 proxy_pass http://www.daolimen.com; # 既是把请求代理到其他主机 &#125; 重启 nginx 1$ sudo nginx -s reload 在浏览器中访问：http://localhost:9000/ 配置说明首先找到 nginx.conf 或者 nginx.conf.default 或者是 default 里面的这部份 其中 server 代表启动的一个服务，location 是一个定位规则。 12345location /｛ #所有以/开头的地址，实际上是所有请求root html ＃去请求../html文件夹里的文件,其中..的路径在nginx里面有定义，安装的时候会有默认路index index.html index.htm ＃首页响应地址 从上面可以看出 location 是 nginx 用来路由的入口，所以我们接下来要在 location 里面完成我们的反向代理。 假如我们我们是 www.a.com/html/msg.html 想请求 www.b.com/api/?method=1&amp;para=2； 我们的 ajax： 1234567var url = 'http://www.b.com/api/msg?method=1&amp;para=2'； &lt;br&gt;$.ajax(&#123; type: \"GET\", url:url, success: function(res)&#123;..&#125;, ....&#125;) 上面的请求必然会遇到跨域问题，这时我们需要修改一下我们的请求 url，让请求发在 nginx 的一个 url 下。 123456789var url = &apos;http://www.b.com/api/msg?method=1&amp;para=2&apos;；var proxyurl ＝ &apos;msg?method=1&amp;para=2&apos;；//假如实际地址是 www.c.com/proxy/html/api/msg?method=1&amp;para=2; www.c.com是nginx主机地址 $.ajax(&#123;type: &quot;GET&quot;,url:proxyurl,success: function(res)&#123;..&#125;,....&#125;) 再在刚才的路径中匹配到这个请求，我们在 location 下面再添加一个 location。 1234location ^~/proxy/html/&#123;rewrite ^/proxy/html/(.*)$ /$1 break;proxy_pass http://www.b.com/;&#125; 以下做一个解释： &#39;^~ /proxy/html/ &#39; 就像上面说的一样是一个匹配规则，用于拦截请求，匹配任何以 /proxy/html/开头的地址，匹配符合以后，停止往下搜索正则。 rewrite ^/proxy/html/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 www.c.com/proxy/html/api/msg?method=1&amp;para=2 重写。只对/proxy/html/api/msg 重写。 rewrite 后面的参数是一个简单的正则 ^/proxy/html/(.*)$ ,$1 代表正则中的第一个(),$2 代表第二个()的值,以此类推。 break 代表匹配一个之后停止匹配。 proxy_pass 既是把请求代理到其他主机，其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下: 不带/ 1234location /html/&#123; proxy_pass http://b.com:8300;&#125; 带/ 1234location /html/&#123; proxy_pass http://b.com:8300/;&#125; 上面两种配置，区别只在于 proxy_pass 转发的路径后是否带 “/”。 针对情况 1，如果访问 url = http://server/html/test.jsp，则被nginx代理后，请求路径会便问http://proxy_pass/html/test.jsp，将test/ 作为根路径，请求 test/路径下的资源。 针对情况 2，如果访问 url = http://server/html/test.jsp，则被nginx代理后，请求路径会变为 http://proxy_pass/test.jsp，直接访问server的根资源。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://luoyec.cn/categories/工程化/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://luoyec.cn/tags/跨域/"},{"name":"Nginx","slug":"Nginx","permalink":"https://luoyec.cn/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://luoyec.cn/tags/反向代理/"}]},{"title":"Eslint代码检查及格式化","date":"2017-11-11T15:31:18.000Z","path":"2017/11/11/cjqoyqt4500i5hl6pi914ovoq/","text":"资源列表：Eslint官网（中文） Configure ESLint, Prettier, and Flow in VS Code for React Development React开发，在VS Code中配置ESLint, Prettier, and Flow（上篇译文） Airbnb’s JavaScript Github Repo airbnb es6 官方文档 airbnb es6 规范文档（中文） Prettier官网 babel-esling npm库 代码规范及格式化本文档使用create-react-app脚手架创建一个新项目，从零开始继承所需要的工具，并完成所有的配置。操作系统为macOS，Windows下快捷键及安装方式可能有差异，不过不影响工具集成。 采用eslint-config-airbnb es6版，具有完整的中英文文档（详见资源列表），以及在此基础上定制规则。 VSCode扩展插件安装请自行安装一下扩展插件，暂时不必添加任何配置 Eslint Prettier JavaScript Formatter Babel ES6/ES7 Eslint ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。 JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript代码错误通常需要在执行过程中不断调适。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。 ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。为了便于人们使用，ESLint内置了一些规则，当然，你可以在使用过程中自定义规则。 ESLint 使用 Node.js 编写，这样既可以有一个快速的运行环境的同时也便于安装。 Prettier Prettier 一个 JavaScript 格式化工具. 它的灵感来源于 refmt，它对于 ES6、ES7、 JSX 和 Flow的语言特性有着高级的支持。通过将 JavaScript 解析为 AST 并且基于 AST 美化和打印，Prettier会丢掉几乎全部的原始的代码风格，从而保证 JavaScript 代码风格的一致性。 解析器(babel-eslint)Specifying ParserESLint 默认使用Espree作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求： 它必须是本地安装的一个 npm 模块。 它必须有兼容 Esprima 的接口（它必须输出一个 parse() 方法） 它必须产出兼容 Esprima 的 AST 和 token 对象。 注意，即使满足这些兼容性，也不能保证一个外部解析器可以与 ESLint 正常工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。 为了表明使用该 npm 模块作为你的解析器，你需要在你的 .eslintrc 文件里指定 parser 选项。例如，下面的配置指定了 Esprima 作为解析器： 123456&#123; \"parser\": \"esprima\", \"rules\": &#123; \"semi\": \"error\" &#125;&#125; 以下解析器与 ESLint 兼容： Esprima Babel-ESLint - 对Babel解析器的包装使其与 ESLint 兼容。 typescript-eslint-parser(实验) - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样就它就可以在 ESLint 中使用了。这样的目的是允许通过 ESLint （尽管不一定要通过所有的 ESLint 规则）来解析 TypeScript 文件。 注意，当使用自定义解析器时，为了使 ESLint 在非 ECMAScript 5 特性下正常工作，配置属性 parserOptions 仍然是必须的。解析器被传入 parserOptions，可能会也可能不会使用它们来决定开启哪个特征。 项目初始化及模块安装创建项目： 12$create-react-app eslint_test$cd eslint_test 全局安装 eslint 1$ npm install -g eslint 查看当前eslint-config-airbnb 所依赖的最新包： 1234567$ npm info \"eslint-config-airbnb@latest\" peerDependencies&#123; eslint: '^4.9.0', 'eslint-plugin-import': '^2.7.0', 'eslint-plugin-jsx-a11y': '^6.0.2', 'eslint-plugin-react': '^7.4.0' &#125; 建议手动的方式安装，需要注意的是eslint-plugin-jsx-a11y指定5.1.1版本，在更好版本中，存在bug，详见#2930 1234$ yarn add eslint-plugin-import$ yarn add eslint-plugin-jsx-a11y@5.1.1$ yarn add eslint-plugin-react$ yarn add eslint-config-airbnb 安装$ yarn add babel-eslint 1$ yarn add babel-eslint 安装 prettier-eslintyarn add prettier-eslint 创建.eslintrc文件，其配置如下 12345&#123; \"parser\": \"babel-eslint\", \"extends\": \"airbnb\", \"plugins\": [\"react\", \"jsx-a11y\", \"import\"]&#125; VSCode通用设置在使用prettier时，默认table宽度是两空格，这里设置成四空格 打开设置，mac下快捷键为cmd + , &quot;prettier.tabWidth&quot;: 4//Table宽度设为四个空格 &quot;editor.formatOnSave&quot;: true,//保存时自动格式化代码 &quot;javascript.format.enable&quot;: false,//禁用自带的js格式化 &quot;prettier.eslintIntegration&quot;: true,//使用&#39;prettier-eslint&#39; 代替 &#39;prettier&#39; 自定义规则红色下划线波浪，是eslint的提示，将鼠标移到该出可以看到具体的信息提示。 提示是因为eslint-config-airbnb推荐采用的是.jsx作为jsx文件的后缀名以及当前的组件可以采用纯函数的写法。 在自定义规则中，我们忽略文件后缀以及缩进宽度设置为4空格，当缩进不满足要求时，eslint提示为error。 123456789101112131415161718192021222324252627282930313233&#123; \"parser\": \"babel-eslint\", \"extends\": \"airbnb\", \"plugins\": [\"react\", \"jsx-a11y\", \"import\"], \"rules\": &#123; \"indent\": [ \"error\", 4, &#123; \"SwitchCase\": 1, \"VariableDeclarator\": 1, \"outerIIFEBody\": 1, \"FunctionDeclaration\": &#123; \"parameters\": 1, \"body\": 1 &#125;, \"FunctionExpression\": &#123; \"parameters\": 1, \"body\": 1 &#125;, \"CallExpression\": &#123; \"arguments\": 1 &#125;, \"ArrayExpression\": 1, \"ObjectExpression\": 1, \"ImportDeclaration\": 1, \"flatTernaryExpressions\": false, \"ignoredNodes\": [\"JSXElement\", \"JSXElement *\"] &#125; ], \"react/jsx-filename-extension\": [1, &#123; \"extensions\": [\".js\", \".jsx\"] &#125;] &#125;&#125; 当eslint正常工作的时候，更多优点等待挖掘 后续采用的eslint-config-airbnb 有完整的规则文档，但在实际生产中，具体的规则需要重新配置，这部分需要大家参与了，反馈提交，然后补充完善规则。 git commit 时执行脚本，自动格式化代码并检查不符合eslint规则，不能提交。 git commit 规范化，并输出成文档，集成 emoji 表情，这是下一个议题了。 Flow工作流 Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale. 官网 配置在 create react app 中使用，详见官方文档。 鉴于目前项目的复杂度，暂不集成。","categories":[{"name":"Eslint","slug":"Eslint","permalink":"https://luoyec.cn/categories/Eslint/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://luoyec.cn/tags/工具/"},{"name":"代码检查","slug":"代码检查","permalink":"https://luoyec.cn/tags/代码检查/"},{"name":"vs code","slug":"vs-code","permalink":"https://luoyec.cn/tags/vs-code/"}]},{"title":"58脚手架分享讲义","date":"2017-11-09T17:08:09.000Z","path":"2017/11/10/cjqoyqt6200kdhl6pgbq2h3ht/","text":"转自 目录大纲第一讲前言 假设，接到一个新的项目：演唱会售票系统，在做系统之前，要考虑很多问题 项目目录如何组织 使用何种类库 dev和prod环境如何搞 团队内部其他系统都用了什么 多人合作开发，团队环境和代码规范问题怎么解决 是否需要出文档，教其他团队成员配置环境，安装依赖等 每一个项目皆是如此，效率何在 我们这次脚手架是以react为例，主要是讲解开发思路，当然用vue的团队也可模仿，或者 后面我们的开源脚手架可以提供创建vue项目的功能 为什么不用create-react-app 不满足当前团队需求 不可以定制化，需要二次修改配置 没有开发组件的能力（后续有讲解组件开发的重要性） 为何不自己开发一个类似于 create-react-app 或者 vue-cli的工具呢 yeoman简单介绍 yeoman 提供了一个我们开发脚手架的能力 按照yeoman的规范，我们开发一个npm包，yeoman就会帮我们执行这个npm的功能（其实就是拿node操作一些相关的文件） yeoman的安装 install yo -g``` 会生成一个yo的全局命令123456789- 最最基础的脚手架功能 - 把全局环境node_modules包下面的模板工程 copy 到你的当前项目路径文件夹下&lt;img src=&quot;http://oyoee89se.bkt.clouddn.com/A4C21ECA-C440-4BF7-9E24-96C85A8FA4E6.png&quot; width=&quot;500&quot; /&gt;- 下面讲一下yo这个命令 是怎么生成到全局命令里面去的#### 启动命令原理示例- ```mkdir flash-cli &amp;&amp; cd ./flash-cli/ init``` 初始化package.json12345678910- 添加 index.js 文件 - ```#!/usr/bin/env node``` - linux的 \\*shell* 脚本，需在开头一行指定脚本的解释程序，此地规定的解释程序为node - env的作用：因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量 - Mac系统下执行 ```env``` 可以看到log ``` javascript #!/usr/bin/env node console.log(&quot;Hello Flash!&quot;) package.json 修改 12345678910111213&#123; \"name\": \"flash-cli\", \"version\": \"0.0.1\", \"description\": \"\", \"main\": \"index.js\", \"bin\": &#123; \"flash\": \"index.js\" &#125;, \"author\": \"战楼\", \"license\": \"ISC\"&#125; 目录结构 link```123456- 将此工程包 添加到 全局node-modules 下进行本地调试 （npm link 相当于 npm install flash-cli -g ，npm link 将当前包 以软链接的形式 放在全局node_modules环境下）- ```npm unlink``` 可以取消此软链接 &lt;img src=&quot;http://oyoee89se.bkt.clouddn.com/7DDD68E3-E8FF-4470-915F-67C1AA819D0C.png&quot; width=&quot;500&quot; /&gt;- ```/usr/local/bin/flash -&gt; /usr/local/lib/node_modules/flash-cli/index.js ->link1- 任意目录下执行 ```flash 下面我们进一步的完善此工具 简单的shell交互和文件操作 实现目标功能 打印欢迎语 用户输入姓名、选择性别、选择爱好标签、输入创建文件的文件名 根据模板生成html文件 浏览器自动打开生成的文件 打印结束语 实现效果预览 dependencies介绍 colors: 可以在terminal打印自定义样式的字 ejs: 模板渲染工具 inquirer: 提供terminal和用户交互的能力 mkdirp: 生成文件夹 or 生成指定路径的文件夹(语法糖) shelljs: 提供给node运行shell命令的能力 其他node的知识点 当前模块的完整绝对路径12345678910 - ```fs.readFileSync(filename, [encoding])``` 同步读取文件 - ```fs.writeFileSync(filename, data, [options])``` 同步写入文件 - ```process``` node进程对象 - ```process.platform``` 获取当前操作系统识别符 - ```darwin、win32、linux``` 等系统 - ```path``` node路径解析模块 - ```open &lt;filePath&gt;``` mac下使用默认工具打开文件 - ```start &lt;filePath&gt;``` windows下使用默认工具打开文件- 安装依赖 - ```npm i colors ejs inquirer mkdirp shelljs --save 基于已有目录结构新建tpl.html模板文件 当前目录结构 index.js修改如下 引入node模块 123456789#!/usr/bin/env noderequire('colors');const fs = require('fs');const path = require('path');const inquirer = require('inquirer');const ejs = require('ejs');const mkdirp = require('mkdirp');const shelljs = require('shelljs'); 打印欢迎语 12345```javascript//欢迎语console.log(&quot;\\n&quot; + &quot;Hello World, I&apos;m flash-cli&quot;.magenta + &quot;\\n&quot;);console.log(&quot;It&apos;s just a test&quot;.red + &quot;\\n&quot;); 常量声明 同一个字符串 尽量不要出现两次 1234//常量const ENCODE = 'utf-8';const BUILD_PATH = './build';const BUILD_FILE_TYPE = '.html'; 用户交互 inquirer 123456789101112131415161718//用户交互问题列表const question = [ ... &#123; type: 'input', name: 'fileName', default: 'index', message: '请输入你要生成文件的名字' &#125; ...];//交互inquirer.prompt(question).then(answer =&gt; &#123; const fileName = `$&#123;answer.fileName&#125;$&#123;BUILD_FILE_TYPE&#125;`;//文件名 createFile(answer, fileName);//创建文件 openFile(`$&#123;BUILD_PATH&#125;/$&#123;fileName&#125;`);//打开创建的文件&#125;); 创建文件 12345let createFile = (data, fileName) =&gt; &#123; let tpl = fs.readFileSync(__dirname + '/tpl.html', ENCODE);//读取模板文件 mkdirp.sync(BUILD_PATH);//生成build目录文件夹 fs.writeFileSync(`$&#123;BUILD_PATH&#125;/$&#123;fileName&#125;`, ejs.render(tpl, data), ENCODE); //写入index.html文件&#125;; 打开所创建的文件 123456789101112let openFile = buildFilePath =&gt; &#123; //mac if(process.platform == 'darwin')&#123; shelljs.exec(`open $&#123;buildFilePath&#125;`); &#125; else if(process.platform == 'win32') &#123; //windows shelljs.exec(`start $&#123;buildFilePath&#125;`); &#125; else &#123; console.log('This platform is ' + process.platform); &#125; endTip(buildFilePath);&#125;; 打印结束语 123const endTip = buildFilePath =&gt; &#123; console.log(\"\\n\" + \"build file: \" + (path.resolve(buildFilePath)).magenta + \"\\n\");&#125;; 教程代码：https://github.com/water-wheel/flash-cli 至此，我们已经从步行阶段到了骑自行车阶段了 generator-flash的简单介绍 下面我们先看下用yo开发出来的flash框架的效果 flash github地址: https://github.com/water-wheel/generator-flash yeoman generator的使用 yeoman: http://yeoman.io/ yeoman是什么？ 明河说 如果前端项目是工厂的产品的话，yeoman就像工厂的流水线，标准化、傻瓜化、批量化产品生产，生产过程乏味了，但效率提高了。 yeoman是定义了一套用于提高前端工程师效率规范的工作流工具 yeoman的使用 创建一个项目 generator-generator``` 创建1- ```mkdir generator-flash &amp;&amp; cd generator-flash &amp;&amp; npm init dependencies 123456789101112131415161718192021222324252627282930- package.json ```json &#123; &quot;name&quot;: &quot;generator-flash&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;files&quot;: [ &quot;generators&quot; ], &quot;keywords&quot;: [&quot;yeoman-generator&quot;], &quot;dependencies&quot;: &#123; &quot;yeoman-generator&quot;: &quot;^1.0.0&quot; &#125; &#125; ... &#123; &quot;name&quot;: &quot;generator-flash&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;files&quot;: [ &quot;app&quot;, &quot;project&quot;, &quot;component&quot; ], &quot;keywords&quot;: [&quot;yeoman-generator&quot;], &quot;dependencies&quot;: &#123; &quot;yeoman-generator&quot;: &quot;^1.0.0&quot; &#125; &#125; 支持两种目录结构 1234567891011121314├───package.json└───generators/ ├───app/ │ └───index.js └───router/ └───index.js ├───package.json├───app/│ └───index.js└───router/ └───index.js name```的使用 和 ```yo name:router```的使用 将直接唤起并运行 其下的index.js文件123456789101112131415161718192021 - 如果是第二种目录结构，则需要在package.json的files中添加多个app目录和router目录 - yeoman规定files必须是数组形式- app/index.js ```javascript const Generator = require(&apos;yeoman-generator&apos;); module.exports = class extends Generator &#123; method1() &#123; this.log(&apos;method 1 just ran&apos;); &#125; method2() &#123; this.log(&apos;method 2 just ran&apos;); &#125; &#125;; ``` - method 按照顺序执行 - Yeoman是按照优先级顺序依次执行所定义的方法。当你定义的函数名字是Yeoman定义的优先级函数名时，会自动将该函数列入到所在优先级队列中，否则就会列入到 default 优先层级队列中。 - ```initializing、prompting、configuring 、default 、writing 、conflicts 、install 、end Prefix method name by an underscore (e.g. _private_method). 异步流程控制 1234567891011121314151617181920212223242526 asyncTask() &#123; var done = this.async(); getUserEmail(function (err, name) &#123; done(err); &#125;); &#125; ``` - The prompt module is provided by Inquirer.js ```javascript prompting() &#123; return this.prompt([&#123; type : 'input', name : 'name', message : 'Your project name', default : this.appname // Default to current folder name &#125;, &#123; type : 'confirm', name : 'cool', message : 'Would you like to enable the Cool feature?' &#125;]).then((answers) =&gt; &#123; this.log('app name', answers.name); this.log('cool feature', answers.cool); &#125;); &#125; generator.composeWith() 执行另一个generator 1this.composeWith('name:route'); 自动安装依赖 this.npmInstall this.yarnInstall this.bowerInstall 合并安装this.installDependencies({npm: false, bower: true, yarn: true}) Template context this.sourceRoot() // returns ‘./templates’ this.templatePath(‘index.js’);// returns ‘./templates/index.js’ copy template this.fs.copyTpl(src, output, data) using ejs template syntax 第二讲 整体架构分析 模板工程的分类 generator-flash的执行流程 暴露尽可能少量的配置文件 扩展一般webpack配置的兼容性 为模板工程添加语法糖 数据mock功能的开发 组件中关于readme的统一化 黑科技 整体架构分析 团队目的 解决复杂的且重复的问题，给团队带来效率提升 从团队leader的角度看：我们每个团队成员，应该尽快的去完成业务需求，而不是天天配置开发环境，如果有现成的代码可用，就不要重复造轮子，拿来即用就好。 我们的目的就是要那一堆零件过来，然后拼装成一辆汽车，而不需要了解零件的制作工艺 剥离组件 组件剥离项目是非常重要的一个事情，它使得项目依赖清晰，开发更快捷 代码解耦、可复用性强、维护方便单一 组件最好维护到公司的npm私服上，没有npm私服的建议组件名 加个前缀，发到npm上 减少开发者的学习成本 项目的配置项越少 对开发人员的上手成本就越低 把webpack的配置内敛至npm包中，仅留下几个路径配置项 架构对比 传统架构设计 新架构设计 模板工程的分类 根据前端框架分类 React Vue JQuery 根据功能拆分 project component common 根据使用的主要功能插件分 react + router react + router + redux react + mobx + typescript 究其结果，都是要进行模板文件的copy，只不过 根据用户的选择不同，copy的内容不同罢了 下面先带大家过一遍 generator-flash 的执行流程，然后再从平时遇到的比较多的问题上开始看，一系列的影响效率的问题，然后去解决他们 generator-flash的执行流程 流程 (/app/index.js) 检测当前脚手架版本 (/_libs/logo.js) 打印欢迎语 选择创建工程类型 (project、component) 选择技术栈 项目名、描述、作者名、作者邮箱、gitlab group、version react的项目 是否使用redux 是否自动安装依赖 根据用户选择 copy 模板工程 至 项目目录 安装依赖 打印结束语 暴露尽可能少量的配置文件出来 问题：项目的webpack配置复杂，通常是有从入门到放弃一说的，可见它的复杂度之高，而暴露出来的配置项越多，开发者自己改动的可能性就越大，而脚手架就越不可控 解决： webpack通用配置 和 个性化配置分离 版本锁定、依赖内敛至npm 版本锁定：整个团队技术框架统一 依赖内敛：团队技术升级方便 扩展一般webpack配置的兼容性 webpack 具体配置不细讲了哈，推荐给大家看一个webpack的视频课程：https://m.qlchat.com/live/channel/channelPage/2000000172777118.htm 问题：webpack在多页应用开发时候，会出现 entry 多入口路径的配置问题，相信很多前端同学，没有玩过webpack时候，或者对webpack一知半解时候，配置此多页面入口路径是相当麻烦的一件事儿 我们自己的脚手架完全可以解决这个问题 解决： 原理：按照定义的规范去写目录结构，在运行代码之前，先用node解析一遍，当前的路径，自动计算出当前的 entry map，完美解决 代码：https://github.com/water-wheel/flash-scripts/blob/master/config/paths.js#L26 为模板工程添加语法糖 问题：在团队中，有多个业务线，每个业务线也都有多个项目，每个项目都会用到的功能，都需要开发人员开发一遍，或者从其他项目中copy一份出来，导致了业务代码乱七八糟，而且代码质量参差不一 解决：我们通过脚手架，为每个项目都内置一些工具方法， 例如一些工具函数：获取url的参数、判断当前容器类型、监听页面回退、获取cookie值等 reset.css scss mixin：兼容性flex方案、1像素线边框、单行（多行）文本截断、渐变、rem计算函数等 当然如果你们团队是hybrid开发时候，里面还可以内置一些 jsBridge 进去 flash脚手架的语法糖代码：https://github.com/water-wheel/generator-flash/tree/master/common 数据mock功能的开发 问题：前后端分离的项目，后端接口开发缓慢，前端业务依赖后端接口数据，如若是写一个常量的数据来mock，则上线前 需要更换接口的url，需要前端开发重新进行自测，才能交付 解决： 启一个本地服务来作为接口服务器 建一个mock文件夹 来放置 mock的接口数据，和mock的config配置(type: get | post | delay 等) 监听mock文件夹，如果有modify，则重启mock服务来更新接口数据 具体解决方案： 在npm start时候，我们fork一个进程，把mock server跑起来，然后监听mock文件夹，当mock文件夹发生修改时候，则重启这个进程 代码地址：https://github.com/water-wheel/flash-scripts/blob/master/scripts/mock.js mock接口服务 (读取本地mock文件的配置内容 和 配置列表，缓存起来，然后启动服务) 代码展示：https://github.com/water-wheel/flash-scripts/blob/master/mock/worker.js 组件中关于readme的统一化 问题：即使有了脚手架 帮我们把组件的工程创建好，但我们还是经常遇到其他人开发的组件，我们无法快速使用的问题 例如我们知道有loading这个组件，但是props的入参是什么，我们只能通过代码找到，有好一点儿的，作者在readme里面 写了loading的使用方式，但是可能下个dialog的组件 就在readme里面 以另一种风格去写dialog的组件使用了，这是一件很蛋疼的事儿 解决方案： 让readme风格 和 规范统一化 让使用者 在第一时间能找到 最简单的使用示例 和 配置参数，只需要copy过来就能用，不需要关心源码是怎么开发的，如果遇到问题，小窗下作者，立马能得到解决方法 我们readme的模板 示例： toast：https://github.com/water-wheel/toast loading：https://github.com/water-wheel/loading 黑科技 figlet 生成字符字 i figlet-cli -g```1- ```figlet OK FLASH tree 生成目录结构 i tree-cli -g```1- ```tree","categories":[{"name":"脚手架","slug":"脚手架","permalink":"https://luoyec.cn/categories/脚手架/"}],"tags":[{"name":"脚手架","slug":"脚手架","permalink":"https://luoyec.cn/tags/脚手架/"},{"name":"工具","slug":"工具","permalink":"https://luoyec.cn/tags/工具/"},{"name":"分享","slug":"分享","permalink":"https://luoyec.cn/tags/分享/"}]},{"title":"JavaScript:Promise","date":"2017-11-09T05:28:18.000Z","path":"2017/11/09/cjqoyqsyh001thl6pq9bzfw38/","text":"调表达程序异步和管理并发的两个主要缺陷:缺乏顺序性 和可信任性。 实际上，绝大多数 JavaScript/DOM 平台新增的异步 API 都是基于 Promise 构建的。 什么是Promise从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成(组合)，而不 用关心时序或底层的结果。 反控制反转回调本身就表达了一种控制反转，所以对回调模式的反转实际就是对反转的反转。 所以反控制反转—-把控制返还给调用代码。 维基百科：关注点分离 关注点分离（Separation of concerns，SOC）是对只与“特定概念、目标”（关注点）相关联的软件组成部分进行“标识、封装和操纵”的能力，即标识、封装和操纵关注点的能力。是处理复杂性的一个原则。由于关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离是面向对象的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用（将针对特定领域问题代码抽象化成较少的程式码，例如将代码封装成function或是class），业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好的管理起来。 具有 then 方法的鸭子类型 根据一个值的形态(具有哪些属性)对这个值的类型做出一些假定。这种类型检查(type check)一般用术语鸭子类型(duck typing)来表示——“如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子” 在 ES6 之前，社区已经有一些著名的非 Promise 库恰好有名为 then(..) 的方 法。这些库中有一部分选择了重命名自己的方法以避免冲突(这真糟糕!)。而其他的那 些库只是因为无法通过改变摆脱这种冲突，就很不幸地被降级进入了“与基于 Promise 的 编码不兼容”的状态。 Promise API 概述new Promise(..) 构造器1234var p = new Promise( function(resolve,reject)&#123; // resolve(..)用于决议/完成这个promise// reject(..)用于拒绝这个promise&#125; ); then(..) 和 catch(..)then(..) 接受一个或两个参数:第一个用于完成回调，第二个用于拒绝回调。 个拒绝回调作为参数，并自动替换默认完成 回调。换句话说，它等价于 then(null,..): Promise.all([ .. ]) 和 Promise.race([ .. ])对 Promise.all([ .. ]) 来说，只有传入的所有 promise 都完成，返回 promise 才能完成。 如果有任何 promise 被拒绝，返回的主 promise 就立即会被拒绝 对 Promise.race([ .. ]) 来说，只有第一个决议的 promise(完成或拒绝)取胜，并且其 决议结果成为返回 promise 的决议。 小结Promise 非常好，请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。 它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。 Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法，这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://luoyec.cn/tags/Promise/"}]},{"title":"2017-10-21表驱动法","date":"2017-10-23T13:51:02.000Z","path":"2017/10/23/cjqoyqt1l007zhl6pxs305p7p/","text":"表驱动法是一种编程模式(scheme)–从表里面查找信息而不使用逻辑语句（if和case），事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。 表驱动法使用总则在适当的环境下，采用表驱动法，所生成的代码会比复杂的逻辑代码更简单、更容易修改，而且效率更高。 使用表驱动法的两个问题 必须要回答的是怎样从表中查询条目的问题？（从表里查询记录的方法：直接访问、索引访问、阶梯访问） 你应该在表里存些什么？(数据或者动作) 直接访问表 计算每个月中的天数，把每个月的天数存在一张表里 计算保险费率，费率随着年龄、性别、婚姻以及吸烟与否的不同情况而变化。使用逻辑控制结构，代码变得很复杂与繁琐 更好的做法是把这些费率存入所有因素索引的数组里 灵活的消息格式在基于逻辑的方法中，其消息阅读子程序包含一个循环，用来读入消息、解释其ID，以及根据该ID调用20个子程序中的某一个。 采用面向对象的方法，那么问题的逻辑可言被隐藏在对象继承结构里，但是基本结构还是同样复杂。 采用表驱动法：采用此方法，比前面两种都更经济，其中消息的阅读子程序由一个循环组成，该循环复杂读入每一个消息头，对其ID解码，在Message数组中查询其消息描述，然后每次调用同一个子程序来解释该消息。 构造键值对构造键值对的方法： 复制信息从而能够直接使用键值 转换键值以使其能够直接使用：用一个函数将age转换成另一个数值 把键值转换提取成独立的子程序：如果必须构造一些数据来让它们像表键值一样使用，那么就把数据到键值的转换操作提取成独立的子程序。 索引访问表当使用索引的时候，先用一个基本类型从一张索引表中查出一个键值，然后再利用这一键值查出感兴趣的主数据。 阶梯访问表阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。 举例，等级区间： 小结 表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，那么问问自己是否通过一个差选表来加以简化 使用表的一项关键决策时决定如果去访问表。你可以采取直接访问、索引访问或者阶梯访问。 使用表达另一项关键决策时决定应该把什么内容放入表中。","categories":[{"name":"代码大全","slug":"代码大全","permalink":"https://luoyec.cn/categories/代码大全/"}],"tags":[{"name":"表驱动发","slug":"表驱动发","permalink":"https://luoyec.cn/tags/表驱动发/"},{"name":"查询表","slug":"查询表","permalink":"https://luoyec.cn/tags/查询表/"},{"name":"索引访问","slug":"索引访问","permalink":"https://luoyec.cn/tags/索引访问/"},{"name":"阶梯访问","slug":"阶梯访问","permalink":"https://luoyec.cn/tags/阶梯访问/"}]},{"title":"JavaScript回调","date":"2017-10-13T12:19:25.000Z","path":"2017/10/13/cjqoyqsyk0021hl6psv6vuc2f/","text":"顺序与异步 回调是编写和处理 JavaScript 程序异步逻辑的最常用 方式。确实，回调是这门语言中最基础的异步模式 所以，如果说同步的大脑计划能够很好地映射到同步代码语句，那么我们的大脑在规划异 步代码方面又是怎样的呢?答案是代码(通过回调)表达异步的方式并不能很好地映射到同步的大脑计划行为。 嵌套回调与链式回调一种典型的回调地狱： 123456789listen( \"click\", function handler(evt)&#123; setTimeout( function request()&#123; ajax( \"http://some.url.1\", function response(text)&#123; if (text == \"hello\") &#123;handler(); &#125; else if (text == \"world\") &#123; request();&#125; &#125; );&#125;, 500) ; &#125; ); 复杂的回调，对于程序的调试和追踪代理来很高的复杂度。 这就是回调方式最主要的缺陷:对于它们在代码中表达异步的方式，我们的大脑 需要努力才能同步得上。 控制反转：也就是把自己程序一部分的执行控制交给某 个第三方。在你的代码和第三方工具(一组你希望有人维护的东西)之间有一份并没有明 确表达的契约。 利用代码的执行依赖于，ajax(..)返回的结果。 省点回调为了更优雅地处理错误，有些 API 设计提供了分离回调 1234567function success(data) &#123; console.log( data );&#125; function failure(err) &#123; console.error( err ); &#125; ajax( \"http://some.url.1\", success, failure ); S6 Promise API使用的就是这种分离回调设计。 还有一种常见的回调模式叫作“error-first 风格”（node风格），第一个参数保留用作错误对象，如果成功，这个参数会被清空或者置假（后面的参数就是成功数据）。 123456789function response(err,data) &#123; // 出错? if (err) &#123; console.error( err );&#125;// 否则认为成功 else &#123; console.log( data ); &#125; &#125; ajax( \"http://some.url.1\", response ); 小结第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流 程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码，会导致坏 bug。 第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。这种控制转移导 致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"回调","slug":"回调","permalink":"https://luoyec.cn/tags/回调/"}]},{"title":"JavaScript异步：现在与未来","date":"2017-10-13T11:46:32.000Z","path":"2017/10/13/cjqoyqt4b00ihhl6pir3184d5/","text":"事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。 分块的程序在开发中，会把程序拆分成多个.js文件，这种拆分，意味着只有一个是现在执行的，其余的要等到将来才能执行。考虑使用Ajax请求： 1234// ajax(..)是某个库中提供的某个Ajax函数 var data = ajax( \"http://some.url.1\" ); console.log( data );// 啊哦!data通常不会包含Ajax结果 标准的Ajax请求不是同步完成的，意味着 ajax(..) 函数还没有返回 任何值可以赋给变量 data； 如果ajax(..)能够阻塞到响应返回，那么这种赋值是可以工作的。实际上并不是。 使用回调函数的方式： 123// ajax(..)是某个库中提供的某个Ajax函数ajax( \"http://some.url.1\", function myCallbackFunction(data)&#123;console.log( data ); // 耶!这里得到了一些数据! &#125; ); 异步控制台 尤其要提出的是，在某些条件下，某些浏览器的 console.log(..) 并不会把传入的内容立 即输出。出现这种情况的主要原因是，在许多程序(不只是 JavaScript)中，I/O 是非常低 速的阻塞部分。 console.log 是异步的，最好的选择是在JavaScript调试器中使用断点，而不要依赖于控制台输出。次优的方案是把对象序列化到一个字符串中，以强 制执行一次“快照”，比如通过 JSON.stringify(..) 事件循环 JavaScript 引擎本身所做的只 不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块!! JavaScript进入了其他环境，比如nodejs， 在这些环境中都用一个共同的点（thread，线程）即它们都提供了一种机制来处理程序中多个块的执行，且执行每 块时调用 JavaScript 引擎，这种机制被称为事件循环。 简单代码模式事件循环： 1234567891011121314// eventLoop是一个用作队列的数组 //(先进，先出)var eventLoop = [ ];var event;//“永远”执行 while (true) &#123;// 一次tickif (eventLoop.length &gt; 0) &#123;// 拿到队列中的下一个事件 event = eventLoop.shift();// 现在，执行下一个事件 try &#123; event(); &#125; catch (err) &#123; reportError(err); &#125; &#125;&#125; 循环的每一轮称为一个 tick。 对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这 些事件就是你的回调函数。 并行线程 异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。 并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行:在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。 在程序中多线程的共享内容，同时访问同一块内容，会造成程序的中断和交错运行，可能得到出乎意料、不确定的行为。 在JavaScript中不允许跨线程共享数据，这意味着不需要考虑因为线程竞争内存引起的中断和交错行为。当不同的先后执行顺序（例如异步函数的执行先后顺序不同）也会导致结果的不同。 完整运行举例说明什么是完整性： 123456789var a = 20; function foo() &#123; a = a + 1;&#125; function bar() &#123; a = a * 2;&#125;// ajax(..)是某个库中提供的某个Ajax函数 ajax( \"http://some.url.1\", foo );ajax( \"http://some.url.2\", bar ); 函数foo()开始执行后，它的所有代码都会在bar() 中的任意代码运行之前完成，或者相反。这被称为完整性运行（run-to-completion）特性 但是这不能消除全都的不确定性，依旧有两种可能的执行结果。 但是，这种不确定性是在函数(事 件)顺序级别上，而不是多线程情况下的语句顺序级别( 在 JavaScript 的特性中，这种函数顺序的不确定性就是通常所说的竞态条件(race condition)，foo() 和 bar() 相互竞争，看谁先运行。具体来说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。 并发 这里的“进程”之所以打上引号，是因为这并不是计算机科学意义上的真正 操作系统级进程。这是虚拟进程，或者任务，表示一个逻辑上相关的运算序 列。 非交互 两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务 彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接 受的。 交互 更常见的情况是，并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。正如前 面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。 协作还有一种并发合作方式，称为并发协作(cooperative concurrency)。这里的重点不再是通过 共享作用域中的值进行交互(尽管显然这也是允许的!)。这里的目标是取到一个长期运 行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己 的运算插入到事件循环队列中交替运行。 1234567var res = [];// response(..)从Ajax调用中取得结果数组 function response(data) &#123;// 添加到已有的res数组 res = res.concat(// 创建一个新的变换数组把所有data值加倍 data.map( function(val)&#123;return val * 2; &#125;)); &#125;// ajax(..)是某个库中提供的某个Ajax函数 ajax( \"http://some.url.1\", response ); ajax( \"http://some.url.2\", response ); 这里的问题在于如果返回的data数组很庞大，那么需要一段时间用于执行res数组写入操作，这过程中发生了阻塞。 那么，可以创建一种协调性更友好且不会霸占时间循环队列的并发系统，这样可以异步处理这些结果，每次处理之后返回事件循环，让其他事件有机会进行。 1234567891011121314var res = [];// response(..)从Ajax调用中取得结果数组 function response(data) &#123;// 一次处理1000个var chunk = data.splice( 0, 1000 );// 添加到已有的res组 res = res.concat(// 创建一个新的数组把chunk中所有值加倍 chunk.map( function(val)&#123;return val * 2; &#125;));// 还有剩下的需要处理吗? if (data.length &gt; 0) &#123;// 异步调度下一次批处理 setTimeout( function()&#123; response( data ); &#125;, 0 );&#125; &#125;// ajax(..)是某个库中提供的某个Ajax函数 ajax( \"http://some.url.1\", response ); ajax( \"http://some.url.2\", response ); 我们把数据集合放在最多包含 1000 条项目的块中。这样，我们就确保了“进程”运行时 间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高 站点 /App 的响应(性能)。 setTimeout(..0)：可以模拟异步调度，但并不直接把项目插入到事件循环队列。当有两个定时器为0时，并不能顺序处理。 任务 在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列(job queue)。这个概念给大家带来的最大影响可能是 Promise 的异步特性。 while 循环实现的持续运行的循环，循环的每一轮称为一个 tick。 对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这 些事件就是你的回调函数。 任务队列的概念： 在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件 添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目(一个任务)。 Promise 的异步特性是基于任务的 语句顺序由于JavaScript引擎需要编译代码，所以语句的执行顺序并不总是按顺序的，在正常情况下，这种优化对于程序的执行并没有影响。 编译器语句重排序几乎就是并发和交互的微型隐喻。 这可以理解为最小单元的异步执行。 小结 尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访 问，所以对状态的修改都是在之前累积的修改之上进行的。 一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。 任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一 个或多个后续事件。 并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时 在运行(尽管在任意时刻只处理一个事件)。 通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块，以便其他“进程”插入进来。 项目总结在实际开发中，经常遇到数据重复改写的问题，这种状态的竞争往往很难预见，处理对业务逻辑的梳理之外，还需要对语言的底层有较好的理解。以便于修复一些难以解决的BUG。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://luoyec.cn/tags/异步/"}]},{"title":"JavaScript 原生函数","date":"2017-10-11T14:50:14.000Z","path":"2017/10/11/cjqoyqsy60013hl6pwft5fny1/","text":"原生函数常用的原生函数有： String() Number() Boolean() Array() Object() Function() RegExp() Data() Error() Symbol() 封装对象通过构造函数（如 new String(‘abc’)）创建出来的是封装了的基本类型值（如 “abc”）的封装对象。 内部属性12345678910111213141516Object.prototype.toString.call( [1,2,3] ); // \"[object Array]\" Object.prototype.toString.call( /regex-literal/i ); // \"[object RegExp]\" Object.prototype.toString.call( null ); // \"[object Null]\" Object.prototype.toString.call( undefined ); // \"[object Undefined]\" Object.prototype.toString.call( \"abc\" ); // \"[object String]\" Object.prototype.toString.call( 42 ); // \"[object Number]\" Object.prototype.toString.call( true ); // \"[object Boolean]\" 封装对象包装 一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什 么时候应该使用封装对象。换句话说，就是应该优先考虑使用 “abc” 和 42 这样的基本类型 值，而非new String(“abc”)和new Number(42)。 如果想要自行封装基本类型值，可以使用 Object(..) 函数(不带 new 关键字): 12345678910var a = \"abc\"; var b = new String( a ); var c = Object( a ); typeof a; // \"string\" typeof b; // \"object\" typeof c; // \"object\" b instanceof String; // true c instanceof String; // true Object.prototype.toString.call( b ); // \"[object String]\" Object.prototype.toString.call( c ); // \"[object String]\" 拆封如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数: 123456var a = new String( \"abc\" ); var b = new Number( 42 ); var c = new Boolean( true ); a.valueOf(); // \"abc\" b.valueOf(); // 42 c.valueOf(); // true Symbol(..)符号(Symbol)。符号是具有唯一性的特殊值(并 非绝对)，用它来命名对象属性不容易导致重名 符号并非对象，而是一种简单的标量基本类型。 小结JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。 对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实 现对这些属性和方法的访问。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"封装","slug":"封装","permalink":"https://luoyec.cn/tags/封装/"},{"name":"解封","slug":"解封","permalink":"https://luoyec.cn/tags/解封/"},{"name":"原生函数","slug":"原生函数","permalink":"https://luoyec.cn/tags/原生函数/"}]},{"title":"JavaScript 值","date":"2017-10-11T05:17:29.000Z","path":"2017/10/11/cjqoyqt4a00iehl6pum4eklbh/","text":"数组 数组可以容纳任何类型的值，可以是字符串、 数字、对象(object)，甚至是其他数组(多维数组就是通过这种方式来实现的) 使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数 组的 length 属性并不会发生变化。 可以通过下标对数组元素进行索引，但是同时，数组也是对象，所以可以通过点操作符以及[‘’]获取数组元素： 123456var a = [ ];a[0] = 1;a[\"foobar\"] = 2;a.length;a[\"foobar\"];a.foobar; 需要注意的是，当使用[‘1’]数字字符串的性质，会被强制类型转换成十进制数字。 在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值， 用数组来存放数字索引值。 类数组有时需要将类数组(一组通过数字索引的值)转换为真正的数组，这一般通过数组工具函数(如 indexOf(..)、concat(..)、forEach(..) 等)来实现。 Array.from() 方法返回一个数组复本 12345Array.from('dsdgarg')(7) [\"d\", \"s\", \"d\", \"g\", \"a\", \"r\", \"g\"]Array.from([1,2])(2) [1, 2] 字符串在JavaScript中字符串与字符串数组不是一回事，尽管这两者很相似。 12var a = \"foo\";var b = [\"f\",\"o\",\"o\"] 都有length属性以及indexOf()方法和concat(…) 方法 都可以通过b[1]获取元素， 但是低版本的IE中需要通过a. chartAt(1)方法获取指定下标的字符 一个有趣的事情，我们可以使用数组的方法来处理字符串 12345678a.join; // undefined a.map; // undefined var c = Array.prototype.join.call( a, \"-\" ); var d = Array.prototype.map.call( a, function(v)&#123; return v.toUpperCase() + \".\"; &#125; ).join( \"\" ); c; // \"f-o-o\" d; // \"F.O.O.\" 字符串反转的例子，数组有一个方法reverse() 123456a.reverse;b.reverse();b;// undefined// [\"!\",\"o\",\"O\",\"f\"]// [\"f\",\"O\",\"o\",\"!\"] 一个变通(破解)的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串: 12345var c = a// 将a的值转换为字符数组 .split( \"\" )// 将数组中的字符进行倒转 .reverse()// 将数组中的字符拼接回字符串 .join( \"\" );c; // \"oof\" 这种方法的确简单粗暴，但对简单的字符串却完全适用。上述方法对于包含复杂字符(Unicode，如星号、多字节字符等)的 字符串并不适用。 数字 JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数 指数格式显示，toExponential() 函数 1234567var a = 5E10; a; // 50000000000 a.toExponential(); // \"5e+10\" var b = a * a; b; // 2.5e+21 var c = 1 / a; c; // 2e-11 tofixed(..) 方法可指定小数部分的显示位数: 123456var a = 42.59; a.toFixed( 0 ); // \"43\" a.toFixed( 1 ); // \"42.6\" a.toFixed( 2 ); // \"42.59\" a.toFixed( 3 ); // \"42.590\" a.toFixed( 4 ); // \"42.5900\" toPrecision(..) 方法用来指定有效数位的显示位数:: 1234567var a = 42.59; a.toPrecision( 1 ); // \"4e+1\" a.toPrecision( 2 ); // \"43\" a.toPrecision( 3 ); // \"42.6\" a.toPrecision( 4 ); // \"42.59\" a.toPrecision( 5 ); // \"42.590\" a.toPrecision( 6 ); // \"42.5900\" 较小的数值0.1 + 0.2 === 0.3; // false 相加的结果是一个比较接近的数字0.30000000000000004，那么如何判断相加是相等的呢？ 设置一个误差范围值： 从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfill: 123 if (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2,-52);&#125; 使用 Number.EPSILON 来比较两个数字是否相等 1234567function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125; var a = 0.1 + 0.2; var b = 0.3; numbersCloseEnoughToEqual( a, b ); numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false 数的极限范围 1.798e+308 5e-324（不是负数，但无限接近0） 整数的安全范围能够被“安全”呈现的最大整数是 2^53 - 1，即 9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991，在 ES6 中被定义为 Number. MIN_SAFE_INTEGER。 整数的检测Number.isInteger(..)方法： 1234567891011//ES6之前 if (!Number.isInteger) &#123; Number.isInteger = function(num) &#123; return typeof num == \"number\" &amp;&amp; num % 1 == 0; &#125;;&#125;//ES6语法Number.isInteger( 42 ); // true Number.isInteger( 42.000 ); // true Number.isInteger( 42.3 ); // false 检测一个值是否是安全的整数，number.isSafeInteger(..) 方法: 123456789101112if (!Number.isSafeInteger) &#123; Number.isSafeInteger = function(num) &#123; return Number.isInteger( num ) &amp;&amp; Math.abs( num ) &lt;= Number.MAX_SAFE_INTEGER;&#125;; &#125;Number.isSafeInteger( Number.MAX_SAFE_INTEGER );Number.isSafeInteger( Math.pow( 2, 53 ) );Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );// true// false// true 一些特殊的值 null：指的是空值，或者曾经赋值，但现在没有值，初始化时会赋值成null以便于和undefined区分 undefined：指的是没有值，从未赋值 void运算符：通过void运算符可以让表达式返回undefined NaN：不是数字的数字，如果数学运算的操作数不是数字类型，就无法返回一个有效的数字，这种情况下返回值为NaN，推荐使用ES6中的Number.isNan(..)方法，以避免一些历史遗留的问题 -0+0: 转换让人迷惑，还是查文档吧 值和引用 引用就像一种特殊的指 针，是来指向变量的指针(别名)。如果参数不声明为引用的话，参数值总是通过值复制 的方式传递，即便对复杂的对象值也是如此。 简单值(即标量基本类型值，scalar primitive)总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。 复合值(compound value)——对象(包括数组和封装对象，参见第3章)和函数，则总 是通过引用复制的方式来赋值 / 传递。 由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。 123456var a = [1,2,3]; var b = a; a; // [1,2,3] b; // [1,2,3]// 然后b = [4,5,6]; a; // [1,2,3] b; // [4,5,6] 引用指向的值本身，所以在函数参数传递的时候： 12345678910function foo(x) &#123; x.push( 4 ); x; // [1,2,3,4]// 然后x = [4,5,6]; x.push( 7 );x; // [4,5,6,7]&#125;var a = [1,2,3];foo( a );a; // 是[1,2,3,4]，不是[4,5,6,7] 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。 值复制如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个复本，这样传递的 就不再是原始值。例如: 1foo( a.slice() ); slice(..)不带参数会返回当前数组的一个浅副本，由于传递给函数的是指向该副本的引用，所以在函数中的操作不会影响到a指向的数组。 相反的，如果要将基本数据类型的值传递到函数内，并且修改之，就需要将该值封装套一个复合值（对象或者数组等）中，然后通过引用复制的方式传递 小结null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之 前默认值都是 undefined。void 运算符返回 undefined。 数字类型有几个特殊值，包括 NaN(意指“not a number”，更确切地说是“invalid number”)、+Infinity、-Infinity 和 -0。 简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递，而复合值(对象等) 通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不 能指向别的变量 / 引用，只能指向值。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"类型","slug":"类型","permalink":"https://luoyec.cn/tags/类型/"}]},{"title":"JavaScript类型","date":"2017-10-10T05:27:27.000Z","path":"2017/10/10/cjqoyqsyl0024hl6pfzc82dtm/","text":"类型 要正确合理地进行类型转换(参见第 4 章)，我们必须掌握 JavaScript 中的各个类型及其内 在行为。几乎所有的 JavaScript 程序都会涉及某种形式的强制类型转换，处理这些情况时 我们需要有充分的把握和自信。 内置类型JavaScript 有七种内置类型（也称基本类型）: • 空值(null)• 未定义(undefined)• 布尔值(boolean)• 数字(number)• 字符串(string)• 对象(object)• 符号(symbol，ES6中新增) typeof运算符 需要注意的是，null类型比较特殊 typeof null === “object”; // true 所以需要复合条件来检测null值类型： 12var a = null(!a &amp;&amp; typeof a === 'object'); //true 还有一种情况 1typeof function a() &#123; /* ... */&#125; === 'function' //true function实际上是object的一个‘子类型’ 函数不仅是对象，还可以拥有属性。例如: 123 function a(b,c) &#123; /* .. */&#125; 函数对象的 length 属性是其声明的参数的个数: 1a.length; // 2 因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2。 数组也是object的一个‘子类型’ 1typeof [1,2,3] === \"object\"; // true 值和类型 JavaScript 不做“类型强制”;也就是说，语言引擎不要求变量总是 持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为 数字类型值。 当变量未持有值的时候为undefined，此时typeof返回‘undefined’ 12var a;typeof a; // \"undefined\" undefined（声明未赋值）与undeclared（未声明）123var a; a; // undefined b; // ReferenceError: b is not defined 但需要注意的是，typeof运算符对两种情况都一样的结果： 123var a; typeof a; // \"undefined\" typeof b; // \"undefined\" typeof Undeclared顶层的全局变量声明 var DEBUG = true 只在 debug.js 文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环 境中不予加载。 问题是如何在程序中检查全局变量 DEBUG 才不会出现 ReferenceError 错误。这时 typeof 的 安全防范机制就成了我们的好帮手: 123456789//这样会抛出错误if (DEBUG) &#123; console.log( \"Debugging is starting\" )&#125;//这样是安全的if (typeof DEBUG !== 'undefined') &#123; console.log('Debugging is starting')&#125; 这不仅对用户定义的变量有用，也对内建的API有帮助： 123if(typeof atob === 'undefined') &#123; atob = function() &#123; /* ... */ &#125;&#125; 除了使用typeof运算符，也可以使用window全局对象，因为访问不存在的对象属性不会有ReferenceError错误。问题在于，全局对象并不总是window，例如在服务器端，node.js等 123456 if (window.DEBUG) &#123; // ..&#125; if (!window.atob) &#123; // ..&#125; 总之，typeof的安全防范机制为我们提供了更多选择 小结JavaScript 有 七 种 内 置 类 型:null、undefined、boolean、number、string、object 和symbol，可以使用 typeof 运算符来查看。 变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。 很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。 undefined 是值的一种。undeclared 则表示变量还没有被声明过。遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined，并且typeof对undefined和undeclared变量都返回 “undefined”。 然而，通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量，有时是个不错的 办法。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"类型","slug":"类型","permalink":"https://luoyec.cn/tags/类型/"}]},{"title":"行为委托","date":"2017-10-08T07:10:13.000Z","path":"2017/10/08/cjqoyqt1j007vhl6p2b4gjshr/","text":"[[Prototype]] 机制就是指对象中的一个内部链接引用 另一个对象。JavaScript 中这个机制的本质就是对象之间的关联关系 面向委托的设计模式为了更好地学习如何更直观地使用 [[Prototype]]，我们必须认识到它代表的是一种不同于类(参见第 4 章)的设计模式。 类理论类设计模式鼓励你在继承时使用方法重写(和多态) 委托理论123456789101112131415161718192021222324252627Task = &#123; setID: function(ID) &#123; this.id = ID &#125;, outputID: function() &#123; console.log(this.id) &#125;&#125;//让XYZ委托TaskXYZ = Object.create(Task)XYZ.prepareTask = function(ID, Label) &#123; this.setID(ID) this.lable = Label&#125;XYZ.outputTaskDetails = function() &#123; this.outputID() console.log(this.lable)&#125;XYZ.prepareTask(1222, 'hh')XYZ.outputTaskDetails()/** * 1222 * hh */ 将XYZ委托给Task， 当XYZ对象执行setID方式时，该对象本身并没有该方法，会沿着原型链查找到Task对象上， this.id = ID其实是隐式绑定。当前的this绑定这XYZ并不是Task 打印XYZ与Task对象的属性，如下： 1234567&#123; prepareTask: [Function], outputTaskDetails: [Function], id: 1222, lable: 'hh' &#125; &#123; setID: [Function: setID], outputID: [Function: outputID] &#125; 委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一个对象(Task)。 这种设计模式需要注意的几个问题： 委托中最好把状态保存在委托者(XYZ、ABC)而不是委托目标(Task)上。如上例子中，id与label都属于对象XYZ 进行避免在不同级别中使用相同的方法或属性命名，提倡更有描述性的方法名，尤其是要写清相应对象行为的类型。 使用this的隐式绑定，将需要的属性绑定到委托者身上，尤其是对于一些私有的数据属性，这并不需要保存在委托目标上。 互相委托（禁止）你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。 之所以要禁止互相委托，是因为引擎的开发者们发现在设置时检查(并禁止!)一次无限 循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查。 比较思维模型对比JavaScript中面向对象与对象关联两种设计模式： 12345678910111213function Foo(who) &#123; this.me = who;&#125;Foo.prototype.identify = function() &#123;return \"I am \" + this.me; &#125;;function Bar(who) &#123; Foo.call( this, who ); &#125; Bar.prototype = Object.create( Foo.prototype );Bar.prototype.speak = function() &#123;alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = new Bar( \"b1\" );var b2 = new Bar( \"b2\" ); b1.speak();b2.speak(); 子类 Bar 继承了父类 Foo，然后生成了 b1 和 b2 两个实例。b1 委托了 Bar.prototype，后者委托了 Foo.prototype。 12345678910111213141516171819Foo = &#123; init: function(who) &#123; this.me = who; &#125;, identify: function() &#123; return \"I am \" + this.me;&#125; &#125;;Bar = Object.create( Foo );Bar.speak = function() &#123; alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = Object.create( Bar );b1.init( \"b1\" );var b2 = Object.create( Bar );b2.init( \"b2\" );b1.speak();b2.speak(); 对象关联风格代码的思维模型 对象之间的关联关系。 小结行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章)，也可以拥抱更自然的 [[Prototype]] 委托机制。 当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"原型链","slug":"原型链","permalink":"https://luoyec.cn/tags/原型链/"},{"name":"委托","slug":"委托","permalink":"https://luoyec.cn/tags/委托/"}]},{"title":"原型","date":"2017-10-08T06:04:27.000Z","path":"2017/10/08/cjqoyqt0w006dhl6ppczzsfp0/","text":"Prototype JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 使用for…in…，会查找对象的整条原型链。因此，当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链。 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。 属性设置和屏蔽在于原型链上层时myObject.foo = “bar”会出现的三种情况。 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。 如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。 有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码: 123456789101112var anotherObject = &#123; a:2&#125;;var myObject = Object.create( anotherObject ); anotherObject.a; // 2 myObject.a; // 2 anotherObject.hasOwnProperty( \"a\" ); // true myObject.hasOwnProperty( \"a\" ); // false myObject.a++; // 隐式屏蔽! anotherObject.a; // 2 myObject.a; // 3 myObject.hasOwnProperty( \"a\" ); // true ++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]] 查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a “类” JavaScript 和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。 JavaScript 会在两 个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 委托 构造函数”使用 new 调用时，它就会构造一个对象并赋值 给 a，这看起来像是 new 的一个副作用(无论如何都会构造一个对象)。这个调用是一个构 造函数调用，但是 NothingSpecial 本身并不是一个构造函数。 换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 回顾“构造函数”一些随意的对象属性引用，比如 a1.constructor，实际上是不被信任的，它们不一 定会指向默认的函数引用。此外，很快我们就会看到，稍不留神 a1.constructor 就可能会 指向你意想不到的地方。 a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。 小结如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype，指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。 虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但 是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"原型","slug":"原型","permalink":"https://luoyec.cn/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"https://luoyec.cn/tags/原型链/"}]},{"title":"混合对象“类”","date":"2017-10-06T15:50:15.000Z","path":"2017/10/06/cjqoyqt1c007dhl6piirtz1oh/","text":"介绍面向类的设计模式:实例化(instantiation)、继承(inheritance)和 (相对)多态(polymorphism)。 类理论类 / 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。 “类”设计模式类并不是必须的编程基础，而是一种可选 的代码抽象。 JavaScript 提供了一些近似类的语法。 总结一下，在软件设计中类是一种可选的模式，你需要自己决定是否在 JavaScript 中使用 它。 类的机制 构造：类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)。 类的继承：同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会 包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。 多态： 任何方法都可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。 另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。 多重继承：有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制 到子类中。 混入：一个对象并不会被复制到其他对 象，它们会被关联起来。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来 模拟类的复制行为，这个方法就是混入。 混入JavaScript 开发者也想出了一个方法来 模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入:显式和隐式。 显式混入123456789101112131415161718192021// 非常简单的 mixin(..) 例子 :function mixin( sourceObj, targetObj ) &#123;for (var key in sourceObj) &#123;// 只会在不存在的情况下复制 if (!(key in targetObj)) &#123; targetObj[key] = sourceObj[key]; &#125;&#125;return targetObj; &#125;var Vehicle = &#123; engines: 1, ignition: function() &#123; console.log( \"Turning on my engine.\" );&#125;,drive: function() &#123; this.ignition(); console.log( \"Steering and moving forward!\" ); &#125;&#125;;var Car = mixin( Vehicle, &#123; wheels: 4,drive: function() &#123; Vehicle.drive.call( this ); console.log( \"Rolling on all \" + this.wheels + \" wheels!\" );&#125; &#125; ); 函数实际上没有 被复制，复制的是函数引用 混合复制12345678910111213// 另一种混入函数，可能有重写风险 function mixin( sourceObj, targetObj ) &#123;for (var key in sourceObj) &#123; targetObj[key] = sourceObj[key];&#125;return targetObj; &#125;var Vehicle = &#123; // ...&#125;;// 首先创建一个空对象并把 Vehicle 的内容复制进去var Car = mixin( Vehicle, &#123; &#125; );// 然后把新内容复制到 Car 中 mixin( &#123;wheels: 4,drive: function() &#123; // ...&#125;&#125;, Car ); 隐式混入123456789101112131415var Something = &#123; cool: function() &#123;this.greeting = \"Hello World\";this.count = this.count ? this.count + 1 : 1; &#125;&#125;;Something.cool(); Something.greeting; // \"Hello World\" Something.count; // 1var Another = &#123;cool: function() &#123;// 隐式把 Something 混入 AnotherSomething.cool.call( this ); &#125;&#125;;Another.cool();Another.greeting; // \"Hello World\" Another.count; // 1(count不是共享状态) 小结混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态(OtherObj.methodName.call(this, …))，这会让代码更加难 懂并且难以维护。 总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋 下更多的隐患。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"},{"name":"闭包","slug":"闭包","permalink":"https://luoyec.cn/tags/闭包/"}]},{"title":"关于this","date":"2017-10-06T15:24:44.000Z","path":"2017/10/06/cjqoyqt0r005yhl6pwsgjaiaj/","text":"关于this 任何足够先进技术和魔法无异 实际上，JavaScript中this的机制并没有那么先进，但是开发者往往把理解过程复杂化，毫无疑问，在缺乏清晰认识的情况下，this对你来说完全是一种魔法。 为什么要用到this：如果不使用this，那就需要给函数传入一个上下文对象，而this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以让API设计得更加简洁易于复用。 this是什么太拘泥于“this”的字面意思就会产生一些误解。有两种常见的对于 this 的解释，但是它 们都是错误的。 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被 这样的解释误导过，但其实它们都是错误的。this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this全面解析每个函数的 this 是在调用 时被绑定的，完全取决于函数的调用位置(也就是函数的调用方法)。 调用位置 调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。 绑定规则默认绑定123function foo() &#123; console.log( this.a );&#125;var a = 2; foo(); // 2 函数调用时应用了 this 的默认绑定，因此 this 指向全局对象，注意在严格模式下，全局对象无法使用默认绑定，因此this会绑定到undefined 隐式绑定12345function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2,foo: foo &#125;; obj.foo(); // 2 隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 隐式丢失一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 123456function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2,foo: foo &#125;;var bar = obj.foo; // 函数别名!var a = \"oops, global\"; // a是全局对象的属性 bar(); // \"oops, global\" 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 显式绑定使用函数的 call(..) 和 apply(..) 方法 这两个方法是如何工作的呢?它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。 12345function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2 &#125;; foo.call( obj ); // 2 装箱：如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。 硬绑定123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2&#125;;var bar = function() &#123; foo.call( obj );&#125;; bar(); // 2 setTimeout( bar, 100 ); // 2// 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 Function.prototype. bind： 1234567function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125; this全面解析 | 89var obj = &#123; a:2&#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3 console.log( b ); // 5 new绑定在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 1234function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 判断this 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 小结 由new调用?绑定到新创建的对象。 由call或者apply(或者bind)调用?绑定到指定的对象。 由上下文对象调用?绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和ES6之前代码中的self = this机制一样。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"},{"name":"闭包","slug":"闭包","permalink":"https://luoyec.cn/tags/闭包/"}]},{"title":"作用域闭包","date":"2017-10-04T03:16:16.000Z","path":"2017/10/04/cjqoyqt4h00j0hl6pq263y76h/","text":"魔术师的幕后藏着一个人，我们将要揭开他的伪装 启示 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。 实质问题一个闭包的直接定义，当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使喊你数是在当前词法作用域之外执行 以下的例子是闭包吗？ 1234567891011function foo () &#123; var a = 2 function bar () &#123; console.log(a) //2 &#125; bar()&#125;foo() 这是闭包吗?技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却 是非常重要的一部分!) 以下代码清晰展示了闭包: 123456789101112function foo () &#123; var a = 2 function bar () &#123; console.log(a) &#125; return bar&#125;bar baz = foo()baz() //2 ,这就是闭包的效果 函数bar（）的词法作用域能够访问foo（）的内部作用域，然后将bar（）函数本身当做一个值类型来进行传递。在这个例子中，bar（）函数在自己定义的词法作用域以外的地方执行。 闭包阻止了foo（）的内存回收 引申出来的一点，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包 12345678910111213(function foo() &#123; var a = 2 function bar() &#123; console.log(a) &#125; barz(bar)&#125;)() //立即执行function barz(fn) &#123; fn()&#125; 把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。 也可以是间接的传递函数： 12345678910111213var fnfunction foo() &#123; var a = 2 function baz() &#123; console.log(a) &#125; fn = baz //将baz分配给全局变量&#125;function bar() &#123; fn() //闭包&#125;foo()bar() 无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行 这个函数都会使用闭包。 闭包小结本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包! 循环和闭包 输出结果为5次6，延迟函数会在循环结束时才执行，即使将延时时间设为0，也会等待循环结束之后才执行。它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 以下方法是否可行？ 12345for (var i=1; i&lt;=5; i++) &#123; (function() &#123;setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125;)();&#125; 依然是输出5次6，这个IIFE只是一个什么都没有的空作用域，需要包含一点实质性内容才能为我们所用，它需要有自己的变量 123456for (var i=1; i&lt;=5; i++) &#123; (function() &#123;var j = i;setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 );&#125;)(); &#125; ok，再对IIFE进行改进！ 12345for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123;setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)( i );&#125; 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 重返块作用域仔细思考我们对前面的解决方案，我们使用IIFe在每次迭代时都创建了一个新的作用域，换句话说，每次迭代我们都需要一个块作用域。 使用let，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域 因此，上面的循环闭包可以写成： 12345for (var i=1; i&lt;=5; i++) &#123;let j = i; // 是的，闭包的块作用域! setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 );&#125; for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。因此可以改写成: 1234for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 模块一个模块的例子： 123456789101112131415161718192021222324252627function CoolModult() &#123; var something = 'cool' var anoter = [1,2,3] function doSomething() &#123; console.log(something) &#125; function doAnohter() &#123; console.log(anoter.join(' ! ')) &#125; return &#123; doSomething: doSomething, doAnohter: doAnohter &#125;&#125;var foo = CoolModult()foo.doSomething()foo.doAnohter()/*cool1 ! 2 ! 3*/ 首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行 外部函数，内部作用域和闭包都无法被创建。 其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。 引申出来的，模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例） 封闭函数必须返回至少一个内部函数，这样的内部函数才能在私有作用于中形成闭包，并且可以访问或者修改私有状态 改写为单例模式123456789101112131415161718192021var foo = (function CoolModult() &#123; var something = 'cool' var anoter = [1,2,3] function doSomething() &#123; console.log(something) &#125; function doAnohter() &#123; console.log(anoter.join(' ! ')) &#125; return &#123; doSomething: doSomething, doAnohter: doAnohter &#125;&#125;)()foo.doSomething()foo.doAnohter() 将模块函数转换成了 IIFE(参见第 3 章)，立即调用这个函数并将返回值直接赋值给 单例的模块实例标识符 foo。 现代的模块机制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var MyModules = (function Manager() &#123; var modules = &#123;&#125; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]] &#125; modules[name] = impl.apply(impl, deps) &#125; function get(name) &#123; return modules[name] &#125; return &#123; define: define, get: get &#125;&#125;)()MyModules.define('bar', [], function() &#123; function hello(who) &#123; return 'Let me introduce: ' + who &#125; return &#123; hello: hello &#125;&#125;)MyModules.define('foo', ['bar'], function()&#123; var hungry = 'hippo' function awesome() &#123; console.log(bar.hello(hungry).toUpperCase()) &#125; return &#123; awesome: awesome &#125;&#125;)var bar = MyModules.get('bar')var foo = MyModules.get('foo')console.log( bar.hello('hippo'))foo.awesome()/** * Let me introduce: hippo * LET ME INTRODUCE: HIPPO */ 这段代码的核心是modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装 函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管 理的模块列表中。 未来的模块机制123456789101112131415161718192021bar.jsfunction hello(who) &#123;return \"Let me introduce: \" + who;&#125;export hello; foo.js// 仅从 \"bar\" 模块导入 hello() import hello from \"bar\";var hungry = \"hippo\";function awesome() &#123; console.log( hello( hungry ).toUpperCase() );&#125;export awesome;baz.js// 导入完整的 \"foo\" 和 \"bar\" 模块 56 | 第 5 章 module foo from \"foo\"; module bar from \"bar\"; console.log( bar.hello( \"rhino\" ) ); // Let me introduce: rhino foo.awesome(); // LET ME INTRODUCE: HIPPO import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭 包模块一样。 小结 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。 模块有两个主要特征: 为创建内部作用域而调用了一个包装函数; 包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭 包。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"},{"name":"闭包","slug":"闭包","permalink":"https://luoyec.cn/tags/闭包/"}]},{"title":"提升","date":"2017-10-03T07:25:48.000Z","path":"2017/10/03/cjqoyqt13006uhl6pupaww6mz/","text":"前面的章节，详细讨论了作用域的概念，以及根据声明的位置和方式将变量分配给 作用域的相关原理。函数作用域和块作用域的行为是一样的，可以总结为:任何声明在 某个作用域内的变量，都将附属于这个作用域。 编译过程因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。当你看到var a = 2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个 声明:var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。 我们的第一个代码片段会以如下形式进行处理: 12var a;a = 2; console.log( a ); 其中第一部分是编译，而第二部分是执行。 类似地，我们的第二个代码片段实际是按照以下流程处理的: 12var a; console.log( a ); a = 2; 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变 了代码执行的顺序，会造成非常严重的破坏。 例子： 1234foo();function foo() &#123;console.log( a ); // undefined var a = 2;&#125; foo函数的声明被提升了，因此该函数可以被执行。因此这段代码实际上会被理解为下 面的形式: 1234function foo() &#123; var a; console.log( a ); // undefineda = 2; &#125;foo(); 可以看到，函数声明会被提升，但是函数表达式却不会被提升。 1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;; 因为此时foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。 同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中提升使用: 1234 foo(); // TypeError bar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式: 123456var foo;foo(); // TypeError bar(); // ReferenceErrorfoo = function() &#123;var bar = ...self... // ...&#125; 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。 考虑以下代码： 1234567891011foo() //1var foofunction foo() &#123; console.log(1)&#125;foo = function() &#123; console.log(2)&#125; 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式: 123456function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制: 123456foo(); // \"b\"var a = true; if (a) &#123;function foo() &#123; console.log(\"a\"); &#125; &#125;else &#123;function foo() &#123; console.log(\"b\"); &#125;&#125; 但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。 (判断语句并不具有作用域) 小结我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题!","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"},{"name":"提升","slug":"提升","permalink":"https://luoyec.cn/tags/提升/"}]},{"title":"谈项目中如何选择框架和库","date":"2017-10-03T06:43:25.000Z","path":"2017/10/03/cjqoyqt1n0086hl6p6sugt76t/","text":"谈项目中如何选择框架和库 概要：我们在项目开发中，根据项目的不同的情况，我们在做技术选型的时候会有所不同，当然我们在框架和库方面也会有所不同，哪具体如何选择呢？克军将和大家谈一谈项目中如何选择框架和库。 基本的前提：成本与效率 实现目标的成本和效率 用第三方库以及自己造轮子？ 良好的架构设计比代码更重要 团队协作的成本和效率 不能被团队接收的方案不是好方案？ 后续迭代的成本和效率 兼顾可维护性以及可迭代性的架构设计，这意味着在项目之初需要花掉时间成本 轮子的选择 对于需要用轮子的人和造轮子的人，都需要关注的问题是，这个轮子解决的问题是什么，痛点是什么。在项目中，最大的瓶颈在哪？轮子对于项目是否匹配。 各种维度的比较 模式、体量、性能、前景、普及率、局限性、活跃性、契合度、成熟度、学习成本、周边资源、文档质量 在不同特点的项目中，权重是不一样的。 选择的原则妥适性在原则 避免过度实践，引入了暂时用不到的技术 库的选择 缩小依赖范围和稳定方向依赖 避重趋轻、避繁逐简、以简获繁、避虚就实 可替代性 主框架的选择 没有不二法则 拥抱未来 经验价值高 架构的优势为重 熵软件熵，软件在经过各种修改之后，无序程度会上升。在前期，首先在选择的过程中，有些工具import cods插件。包分析工具，分析包所占比重。 库选择： 扩展语言类 基础功能 兼容问题 少量成熟的组件","categories":[{"name":"开发实践分享","slug":"开发实践分享","permalink":"https://luoyec.cn/categories/开发实践分享/"}],"tags":[{"name":"前端早读课","slug":"前端早读课","permalink":"https://luoyec.cn/tags/前端早读课/"},{"name":"架构设计","slug":"架构设计","permalink":"https://luoyec.cn/tags/架构设计/"}]},{"title":"函数作用域和块作用域","date":"2017-10-03T06:02:42.000Z","path":"2017/10/03/cjqoyqt4i00j3hl6pkous1g0u/","text":"本章讨论的问题是，是否只有函数会生成新的作用域，在Javas中其他的结构能生成作用域吗？ 函数中的作用域考虑一下代码：12345678910111213function foo(a)&#123; var b = 2 //一些代码 function bar ()&#123; //... &#125; //更多的代码 var c = 3&#125; 在这个代码片段中，foo（…） 的作用域气泡中包含了标识符a、b、c和bar，无论标志服声明出现在作用域中的何处，这个标识符所代表的变量或函数都将属于所处作用域的气泡。 所以，这些在foo中定义的标识符无法从全局作用域中进行访问，这会导致ReferenceError 总结一下函数作用域，属于这个函数的全局变量都可以在整个函数的范围内使用以及复用。但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能导致意想不到的问题。 隐藏内部实现对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示：从所写的代码中挑选出任意一个片段，然后利用函数声明对它进行包装，实际上就是把代码隐藏起来了。 这其实就是在这个代码片段周围创建了一个作用域气泡，也就是说任何声明（变量或者函数）都将绑定在这个新创建的包装函数的作用域中。 出发点以及目的，为什么要对代码进行隐藏：应该最小限度的暴露必要内容，而将其他内容都“隐藏起来”，这类似于某个模块或者对象的API设计。 规避冲突“隐藏”作用域中的变量和函数所带来的另一个好处是，是可以避免同名标识符之间的冲突。 12345678function foo() &#123; function bar(a) &#123;i = 3; //修改for循环所属作用域中的i console.log( a + i ); &#125;for (var i=0; i&lt;10; i++) &#123;bar( i * 2 ); // 糟糕，无限循环了!&#125; &#125;foo(); 这段代码的问题在于，函数bar修改了变量i，这会导致for循环没法满足终止的条件，出现无限循环。 解决这问题的几种方法： 将函数bar中的i，声明为var i= 3； 这个i就是之前提过的“遮蔽变量”，及在当前作用域和上层作用域重复定义的变量，屏蔽上层的作用域定义的变量。 但是更好的方法，是应该讲作用域“隐藏”起来，内部声明是唯一最佳的选择。 以下是在软件开发中常见的需要进行冲突管理的情况： 全局命名空间变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。 这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象，这个对象就被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间的）属性。 例如：123456789var MyreallyCoolLibrary = &#123; awesome: &quot;stuff&quot;, dosometing: functino () &#123; //... &#125;, doAnoterhThing: fucntion() &#123; //.. &#125;&#125; 模块管理另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器 的机制将库的标识符显式地导入到另外一个特定的作用域中。 两种模式的共性显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用 域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域 中，这样可以有效规避掉所有的意外冲突。 函数作用域虽然利用函数可以生成作用域，但这种方法有两个弊端，首先必须声明一个具名函数foo，这意味着这个名称本身“污染”了所在的作用域，这是不必要的。其实，必须显示地通过函数名（foo（））调用这个函数才能运行其中代码。 为解决以上问题，Javas提供了方案： 12345678var a = 2(function foo() &#123; var a = 3 console.log(a) //3&#125;)()console.log(a) //2 将函数用（）包裹起来，这会将函数当做函数表达式而不是一个标准的函数声明来处理。 如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明和函数表达式的区别函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。换句话说，(function foo(){ .. })作为函数表达式意味着foo只能在..所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。 参考：详解Javascript 函数声明和函数表达式的区别 匿名和具名123 setTimeout( function() &#123; console.log(\"I waited 1 second!\");&#125;, 1000 ); 这叫做匿名函数表达式，因为声明也名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数书写起来简单便捷，但是有几个确定需要考虑： 匿名函数在栈追踪中不会显示出有意义的函数名，调试变得困难 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。 匿名函数省略了对于代码可读性/可理解性而言很重要的函数名，一个描述性的名称可以让代码不言自明。 行内函数表达式行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践: 123setTimeout( function timeoutHandler() &#123; // &lt;-- 快看，我有名字了! console.log( \"I waited 1 second!\" );&#125;, 1000 ); 立即执行函数表达式1234567var a = 2 (function foo() &#123; var a = 3 console.log(a) //3 &#125;)()console.log(a) //2 由于函数被包含在一对（）内部，一次成为一个表达式，通过在欧威加上另一个（）可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。 IIFE（立即执行函数表达式）这种模式很常见，几年前社区给它规定了一个术语:IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression); 函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使 用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值 得推广的实践。 1234var a = 2; (function IIFE() &#123;var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式:(function(){ .. }())， 第一种形式中函数表达式被包含在( )中，然后在后面用另一个()括 号来调用。第二种形式中用来调用的()括号被移进了用来包装的( )括号中。这两种形式在功能上是一致的。选择哪个全凭个人喜好。 IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。 123456var a = 2;(function IIFE( global ) &#123;var a = 3;console.log( a ); // 3 console.log( global.a ); // 2 &#125;)( window ); console.log( a ); // 2 IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。 123456var a = 2(function IIFE( def ) &#123; def( window );&#125;)(function def( global ) &#123;var a = 3;console.log( a ); // 3 console.log( global.a ); // 2&#125;); 函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。 块级作用域块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息。 try/catch非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。 123456try &#123;undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123;console.log( err ); // 能够正常执行! &#125; console.log( err ); // ReferenceError: err not found err仅仅存在于catch分句内部，当视图从别处引用它时会抛出错误 letlet关键字可以将变量绑定到任意作用域中，通常是{…}内部，换句话说，let为其生命的变量隐式生成所在块作用域 123456var foo = true;if (foo) &#123;let bar = foo * 2;bar = something( bar ); console.log( bar ); &#125; console.log( bar ); // ReferenceError 变量提升：提升是指声明会被视为存在于其所出现的作用域的整个范围内 const除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。 小结函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指{ .. }内部)。 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字(var 关键字的表亲)，用来在任意代码块中声明变量。if (..) { let a = 2; }会声明一个劫持了if的{ .. }块的变量，并且将变量添加到这个块中。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"}]},{"title":"词法作用域","date":"2017-10-03T03:39:52.000Z","path":"2017/10/03/cjqoyqt1m0083hl6pzk93n3h5/","text":"作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用(比如 Bash 脚本、Perl 中的一些模式等)。 词法阶段词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。 考虑一下代码：1234567891011function foo(a) &#123; var b = a * 2 function bar (c) &#123; console.log(a, b, c) &#125; bar(b * 3)&#125;foo(2) 在这个例子中有三个逐级嵌套的作用域，为了帮助理解，可以将他们想象成几个逐级包含的气泡。 包含整个全局作用域，其中只有一个标识符： foo 包含着foo所创建的作用域，其中有三个标识符： a、bar和b 包含着由bar所常见的作用域，其中只有一个标识符： c 下一章会讨论不同类型的作用域，但现在只是简单的假设没一个函数都会创建一个新的作用域气泡bar的气泡位置被完全包含在foo所创建的气泡中，唯一的原因就是我们希望定义函数bar的位置 查找作用域气泡的结构和相互位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。f引擎会从最内部的作用域中查找，如果没有找到会依次沿着上一级所嵌套的作用域中查找。 作用域查找会在找到第一个匹配的标识符时停止。 多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。 欺骗词法量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪 明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代 码会运行得更慢这个事实。 evalJavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样。 withwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。 小结JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"}]},{"title":"作用域是什么","date":"2017-10-03T02:49:13.000Z","path":"2017/10/03/cjqoyqt0n005rhl6pke9sdtj5/","text":"几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。 需要一套设计良好的规则来存储变量，以便能够方便的找到这些变量，这套规则称为作用域。 编译原理在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。 分词/词法分析 解析/语法分析 代码生成 比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时 间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。 变量的赋值变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如 果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。 引擎、编译器、作用域之间的关系 引擎负责整个JAvaScript程序的编译以及执行过程 编译器，复杂语法分析以及代码生成等脏活累活 作用域，复杂手机并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 编译器遇到一个变量是如何解析的 遇到var a，编译器询问作用域是否已经有了一个该名称的变量存在于同一个作用域的集合中，如果是，编译器会忽略该声明，继续进行编译。否则，他会要求作用域在当前作用域中声明一个新的变量，并命名为a 接下编译器会为引擎生成运行时所需的代码，如果当前的作用域集合中存在一个变量a，如果是，则会使用这个变量，如果不是，则会继续查找该变量。 LHS、RHS如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。 一个简单的例子： 123console.log(a) //RHS，只需要查询并获取a的值a = 2 //LHS，这并不关心当前的值是什么，只想为a赋值一个2 在函数调用中： 12345function foo(a) &#123; console.log(a)&#125;foo(2) 最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。 为了给参数a（隐式的）赋值，需要进进行一次LHS查询 打印输出语句中，会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法。 作用域嵌套遍历嵌套作用域的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续继续查找，当抵达最外层的全局作用域是，无论找到还是没找到，查找过程都会停止。 异常如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。 相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。 小结 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。 如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。赋值操作会导致 LHS 查询。 = 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作, 即都会导致 LHS 查询。 JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2 这样的声明会被分解成两个独立的步骤：首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。接下来，a = 2会查询（LHS查询）变量 a 并对其进行赋值。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。","categories":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://luoyec.cn/categories/你不知道的JavaScript/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"作用域","slug":"作用域","permalink":"https://luoyec.cn/tags/作用域/"}]},{"title":"礼物说分享","date":"2017-09-25T03:37:13.000Z","path":"2017/09/25/cjqoyqt1g007nhl6p6ko50xst/","text":"此次为时两小时的分享，收获最大的两点： 几乎所有的业务都可以流程化、模块化，并且可以在网上直接找到解决方案 跨领域成为常态：单一的知识体系已经不足以支撑","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://luoyec.cn/categories/经验分享/"}],"tags":[{"name":"成长","slug":"成长","permalink":"https://luoyec.cn/tags/成长/"},{"name":"大牛","slug":"大牛","permalink":"https://luoyec.cn/tags/大牛/"}]},{"title":"路由协议与应用协议","date":"2017-09-19T12:51:45.000Z","path":"2017/09/19/cjqoyqt1q008dhl6pwbk04pjc/","text":"路由协议在互联网世界中，夹杂着复杂的LAN和广域网。然而，再复杂的网络结构中，也需要通过合理的路由将数据发送到目标主机。而决定这个路由的，正是控制模块。 路由控制的定义IP地址与路由控制路由器根据路由控制表（Routing Table）转发数据包。它根据所受到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。 静态路由与动态留路由静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法，而动态路由是指让路由协议在运行过程中自动设置控制信息的一种方法。这些方法都有他们各自的利弊。 路由算法距离向量算法是指根据距离（代价）和方向决定目标网络或目标主机位置的一种方法。 链路状态算法那 应用协议 应用层协议概要TCP和IP等下层协议是不依赖与上层应用类型、实用性非常广的协议。而应用协议则是为了实现某些应用而设计和创造的协议。 开发者只要关心选用哪种应用协议、如何开发即可，而不必担心应用中的数据该以何种方式发送到目标主机等问题。 应用层协议相当于OSI中第5、6、7层的协议 远程登录TELNETTELNET利用TCP的一条连接，通过这一条连接想主机发送文字命令并在主机上执行。本地用户好像直接与远端主机内部的Shell相连似的，直接在本地操作。 SSHSSH是加密的远程登录系统。TELNET中登录时无须密码就能发送容易造成通信窃听和非法入侵的微信。 SSH可以提供： 可以使用更强的认证机制 可以转发文件 可以使用端口转发功能 文件传输FTP是两个相连计算机之间进行文件传输是使用的协议。 电子邮件WWW 万维网（WWW，World Wide Web）是将互联网中的信息以超文本形式展现的系统，也叫Web。 基本概念 www定义了三个重要概念，他们分别是访问信息的手段与位置（URI，Uniform Resource Identifier）、信息的表现形式（HTML，HyperText Markup Language）以及信息转发（HTTP，HyperTyxt Transfer Protocol）等操作。 RUL：是一种可以用于WWW之外的高效识别码，他被用于主页地址、电子邮件、电话号码等各种组合中。 HTML：是描述web网页的一种语言，指定浏览器显示的内容，包括图像、动画、音频、视频等 HTTP：HTTP连接一个TCP了解，然后在这个TCP连接上进行请求和应答数据报文的发送。","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"TCP与UDP","date":"2017-09-19T11:53:34.000Z","path":"2017/09/19/cjqoyqszh003thl6pmpmc7kpe/","text":"TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用和通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。 传输层定义IP首部中有一个协议字段，用来标识网络层（IP）的上一层采用的是哪一种传输层协议，根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容还是UDP的内容。 通信处理 两种传输层协议TCP和UDPTCP是面向连接的、可靠的流协议。所谓流就是指不间断的数据结构，可以类比水流。 TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口等机制实现可靠性传输。 UDPUDP是不具有可靠性的数据报协议，在这种情况下，虽然可以保证发送消息的大小，却不能保证消息一定到达。 应用场景： 包总量较少的通信（DNS、SNMP）等 视频、音频等多媒体通信（即使通信） 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） 套接字（Soket）在应用程序中利用套接字，可以设置对端的IP地址、端口号、并实现数据的发送与接收 端口号定义端口号用来识别同一台计算机中进行通信的不同应用程序，一次，它也被称为程序地址。 根据端口号识别应用传输层利用端口号识别本机中正在进行通信的应用程序。 端口号如何确定 标准既定的端口号 时序分配法：例如每需要一个新的端口号就在之前的分配的号码的基础上加1 端口与协议端口号由其使用的传输层协议决定，因此，不同的传输协议可以使用相同的端口号。 数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果是TCP则传给TCP模块，由传输协议各自独立处理。 连接管理UDP是一种面向无连接的通信协议，因此不检查对端是否可用痛殴更新，直接将UDP包发送出去。TCP相反。 UDP首部格式 源端口号（Source Port）：表示发送端口号，字段长16位。 目标端口号（Destination Port）：表示接收端口号，字段长度16位。 包长度（Length）：该字段保存了UDP首部的长度跟数据的长度之和。单位字节为8 校验和（Checksum）：校验和是为了提供可靠的UDP首部和数据而设计的。 TCP首部格式 源端口号（Source Port）：表示发送端端口号，字段长16位 目标端口号（Destination Port）：表示接受端口号，字段长度16位。 序列号（Sequence Number）:是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小 确认应答号（Acknowledgement Number）：下一次应该收到的数据的序列号。 数据偏移（Data Offset）：表示TCP所传输的数据部分应该从TCP包的哪个位开始计算。也可看作TCP首部的长度。 保留（Reserved）：为 以后扩展 控制位（Control Flag）: 字段长8位，每一位从左至右分别为 CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。 窗口大小（Window Size）：用于通知从农耕相同TCP首部的确认应答号所指位置开始能够接受的数据大小。TCP不允许发送超过此处所表示大小的数据。 校验和（Checksum）：如果计算校验和字段在内的所有数据的16位和以后，得出的结果是“16位全部为1”说明所收到的数据时正确的。 紧急指针（Urgent Pointer）：紧急指针指出了紧急数据的末尾在报文段中的位置。 选项（Options）：用于提高TCP传输性能。","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"IP协议相关技术","date":"2017-09-18T12:42:21.000Z","path":"2017/09/18/cjqoyqsy2000yhl6pmr5dlvpo/","text":"IP（Internet Protocal）旨在让最终目标主机收到数据包，但是在这一过程中仅仅IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。 DNSDNS(Domain Name System)，将字符串自动转成具体的IP地址 主机识别码：是指为每台计算机赋以唯一的主机名，在进行网络通信时可以直接使用主机名称而无需输入一大串的IP地址。并且此时，系统必须自动将主机名转换成具体的IP地址。 域名的构成 域名服务器是指管理域名的主机和响应的软件，他可以管理所在分层的相关信息。 解析器进行DNS查询的主机和软件叫做DNS解析器，用户使用的工作站和个人电脑都属于解析器 DNS查询解析器为了调查IP地址，向域名服务器进行查询处理。首先在自己的数据库中查找，如果没有则再向上一层根域名服务器进行查询处理。 DNS如同互联网中的分布式数据库ARP只要确定了IP地址，就可以向这个目标地址发送IP数据，然而，在底层数据链路层，进行实际通信时有必要了解每个IP地址所对应的MAC地址。 概要ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接受数据分包的网络设备对应的MAC地址。如果目标不在同一个链路上时，可以通过ARP查找下一级路由器调转的MAC地址。不过ARP只适用于IPv4. RARPRARP（Reverse Address Resolution Protocal）是将ARP反过来，从MAC地址定位IP地址的一种协议。 代理ARP采用ARP（Proxy ARP）的路由器可以将ARP请求转发给邻近的网段。 ICMP其主要功能，确定IP包是否成功送达目的地址，通知在发送过程当中IP包被丢弃的原因，改善网络设置等。 DHCP实现即插即用 能够自动设置IP地址、统一管理IP地址分配，由此产生了DHCP（Dynamic Host Configuration Protocal）。只要计算机连接了网络，就可以进行TCP/IP 通信。 NAT概念 NAT（Network Address Translator）用于网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。 IP隧道 IP隧道为了IPv4与IPv6之间的相互通信。 IP隧道可以将那些从网络A发送过来的IPv6包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C（采用IPv4的网络）","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"IP协议","date":"2017-09-18T12:07:00.000Z","path":"2017/09/18/cjqoyqsxy000whl6pax6g2scu/","text":"序IP作为整个TCP/IP中至关重要的协议，主要复杂数据包发送给最终目标计算机。因此，IP能够让世界上任何两台计算机之间进行通信。 IP相当于OSI参考模型的第3层 网络层的主要作用是“实现终端节点之间的通信”，这种终端节点之间的通信也叫“点对点（end to end）通信”。 网络层的下一层–数据链路层的主要作用就是互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。 网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点的数据包传输。 主机与节点那些配有IP地址的设备叫“主机”，既配有IP地址又具有路由控制能力的设备叫做路由器。 网络层与数据链路层的关系 IP基础知识 IP大致分为三大模块，分别是IP寻址、路由以及IP分包、组包 IP地址属于网络层地址 IP地址用于在“连接到网络中所有主机中识别出进行通信的目标地址。”， 因此，在TCP/ IP 通信中所有主机或路由器必须设定自己的IP地址。 路由控制 发送数据至最终目标地址 路由控制表 IP属于面向无连接 IP面向无连接，即在发包之前，不需要建立与对端目标地址之间的连接。而面向有连接的情况，需要事先建立连接，如果对端主机关机与不存在，也就不可能建立连接。 IP地址的基础知识IP地址的定义 IP地址（IPv4地址）由32位正整数来表示。TCP/IP 通信要求将这样的IP地址分配给每个参与通信的主机。 IP地址由网络和主机两部分标识组成IP地址由“网络标识（网络地址）”和“主机标志（主机地址）”两部分组成。 网络标志在数据链路中每个配置不同的值，网络标志必须保证相互连接的每个段的地址不重复。 IP地址的分类IP地址分为四个级别，分别为A、B、C、D类，它根据IP地址中从第一位到第四位的比特列队其网络标识和主机标识区分。 A类地址A类地址是以首位为“0”开头的地址。0.0.0.0~127.0.0.0是A类网络地址。 B类地址B类IP地址是前两位为“10”的地址。128.0.0.1~191.255.0.0 C类地址前两位为“110”的地址， 192.168.0.0~239.255.255.0 D类地址前两位为“1110”的地址，224.0.0.0~239.255.255.255，D类地址没有主机标识，常被用于多播 关于分配IP主机地址的注意事项要用比特位标识主机地址时，不可用全部为0或者全部为1，全部为0的情况是表示对应的网络地址或IP地址不可获知的情况下才使用。全部为1的主机地址，通常作为广播地址。 广播地址将IP地址中主机地址全部设置为1，如 172.20.255.255 本地广播：在本网络内的广播 直接广播：在不同网络之间的广播叫直接广播 IP多播子网掩码分类造成浪费？随着互联网的覆盖范围逐渐增大，网络地址越来越不足应对需求，直接使用ABC类地址就显得很浪费。 子网与子网掩码现在，一个IP地址的网络标志和主机标识已经不再受限于该地址的类别，而是由一个叫“子网掩码”的识别码通过子网网络地址细分出别ABC类更小粒度的网络。 路由控制数据包需要路由器持有的控制表指明真正发送的目标地址。 这种控制表有两种获得途径： 管理员手动录入（静态路由） 路由器与其他路由器相互交互信息时自动刷新（动态路由） IP地址与路由控制IP地址的网络地址部分用于进行路由控制。 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先yaoquedingIP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。 默认路由 默认路由标记为0.0.0.0，标识一张路由表中包含所有的网络及其子网络信息。 主机路由 整个IP地址的所有位都参与路由，这意味着要基于主机在网卡上配置的IP地址本身。 环回地址 使用特殊的IP地址 127.0.0.1作为环回地址，此时，数据包不会流向网络 路由控制表的聚合利用网络地址的比特分布可以有效地进行分层配置，对内即有多个子网掩码，对外呈现出同一个网络地址。这样可以更好的构建网络，通过路由信息的聚合可以有效地减小路由表的条目 IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议。 IPv4首部 通过IP进行通信时，需要在数据前面加上IP首部信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"数据链路","date":"2017-09-15T05:17:56.000Z","path":"2017/09/15/cjqoyqt15006yhl6poyrp9p9j/","text":"数据链路的作用数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外的介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。 数据链路的相关技术MAC地址MAC地址用于识别数据链路中互连的节点。 例外情况–MAC地址不一定是唯一的只要不在同一个数据链路就不会出现问题。 厂商识别码它可以分析出局域网中的包是由哪个厂商的网卡发出的。 共享介质型网络 共享介质型网络是指多个设备共享一个通信介质的一种网络。在这种方式下，设备之间使用同一个载波通信信道进行发送和接收。 争用方式 令牌传递方式 非共享介质网络在这种方式下，网络中每个站直连交换机，由交换机负责转发数据帧。发送端与接收端并不共享通信介质，因此很多情况下采用全双工通信方式。 半双工与全双工半双工是指，只发送或只接收的通信方式，类似于无线电收发器。全双杠：在使用交换机与双绞线电缆（或光纤电缆）的情况下，既可以通过交互机端口与计算机之间进行一对一的连接，也可以通过相连电缆内部的收发线路分别进行接收和发送数据。 根据MAC地址转发以太网交互机就是持有多个端口的网桥，它们根据数据链路中每个帧的目标MAC地址，决定哪个网络接口发送数据。 环路检测技术 生成树方式 源路由法 VLAN对VLAN进行了扩展，不必重新修改布线，只要修改网段即可。 以太网以太网帧格式以太网前端有一个叫做前导码的部分，它由0、1数字交替组合而成，标识一个以太网帧的开始，也是对端网卡能够确保其同步的标志。 以太网帧本体是以太网的首部，它总共14个字节，分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。 无线通信","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"TCP/IP 基础知识","date":"2017-09-12T06:08:14.000Z","path":"2017/09/12/cjqoyqsze003phl6pg7ymygt8/","text":"TCP（Transmission Control Protocool）和IP（Internet Protocol）是互联网的众多通信协议中最为著名的。本章介绍TCP/IP 的发展历程及其协议概况。 TCP/IP 出现的背景及其历史从军用技术的应用谈起ARPANET的诞生TCP/IP 的诞生UNIX系统的普及及与互联网的扩张商用互联网服务的启蒙TCP/IP 的标准化 TCP/IP 协议分层模型 硬件（物理层）TCP/IP的最底层复杂数据传输的硬件。这种硬件就相当于以太网或电话线等物理层设备。 网络接口层（数据链路层）网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。驱动程序是在操作系统与硬件之间起桥梁作用的软件。 互联网层（网络层）互联网层使用IP协议，它相同于OSI模型中的第三层网络层。IP协议基于IP地址转发分包数据。 IPIP是跨越网络产送数据包，是整个互联网都能收到数据的协议。IP协议使数据能够发送到地球另一端，这期间它使用IP地址作为主机的标识。 ICMPIP数据包在发送途中一旦发生异常导致无法到底对端目标地址时，需要给发送端一个发生异常的通知。ICMP就是为了一功能而定制的，它有时也被用作诊断网络的健康状况。 ARP从分组数据包IP地址中解析出物理地址（MAC地址）的一种协议。 传输层传输层最主要的功能就是能够让应用程序之间实现通信。在计算机内部，通过应用程序端口号来区分哪些程序正在进行通信。 TCPTCP是一种面向有链接的传输层协议，它既可以保证两端通信主机之间的通信可达，还可以正确处理传输过程中丢包、传输顺序乱掉的异常情况。此外TCP还能够有效利用带宽，环节网络拥堵。 缺点是，为了建立连接和断开连接，需要至少7次的手包和发包，导致网络流量的浪费。这并不适用于视频会议等场合使用。 UDP它是一种面向无连接的传输层协议。UDP不关注端是否真的收到了传送过去的数据。 UDP常用于分组数据较少或多播、广播通信以及使用通信等多媒体领域。 应用层（会话层以上的分层）-电子邮件（E-Mail） SMTP协议 文件传输（FTP） 在FTP中进行文件传输时会建立两个TCP链接，分别是发送传输请求时所要用到的控制链接与实际传输数据时所要用到的数据连接。 远程登录（TELNET与SSH） 网络管理（SNMP） TCP/IP 分层模型与通信示例数据包首部 每个分层中，都会对所发送的数据附件一个首部，在这个首部中包含了该层必要的信息，如发送目标地址以及协议相关的信息。 在数据包的首部，明确表明了协议应该如何读取数据，反过来，看到首部，也就能够了解协议必要的信息以及所要处理的内容。 发送数据包以一封邮件的发送为例子： 应用程序处理：鼠标点击送就开始了TCP/IP的通信了 TCP模块的处理：TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输 IP模块的处理：IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端加上自己的IP首部 网络接口（以太网驱动的处理）：给TP传过来的IP包附加上以太网首部并进行发送处理 经过数据链路的包 数据包的接收处理包的接受流程是发送路程逆序过程。","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"网络基础知识","date":"2017-09-10T23:46:16.000Z","path":"2017/09/11/cjqoyqt1i007rhl6p3kl7k926/","text":"本章总结了深入理解TCP/IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。 计算机网络出现的背景从独立模式到网络互联模式 计算机网络，根据其规模可分为WAN（Wide Area Network， 广域网）和LAN（Local Area Networ， 局域网） 分组交换协议 分组交换是指将大数据分割为一个个叫包（Packet）的较小单位进行传输的方法。 标准化：所谓标准化是指不同厂商所生产的异构产品之间具有兼容性、便于使用的规范化过程。 OSI参考模型 OSI参考模型在各个分层的作用 OSI参考模型通信处理举例 传输方式的分类面向有连接型和面向无连接型 电路交换与分组交换让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。数据被细分后，所有的计算机就可以一齐收发数据，这样也提高了通信线路的利用率。 根据接收端数量分类单播（Unicast）1对1通信，早期的固定电话就是单播通信的例子。 广播（Broadcast）将消息从1台主机发送与之相连的所有其他主机。 多播（Multicast）也是将消息发给多个接收主机，不同之处在于多播要限定某一组作为接收端。 任播（Anycast）指的是在特定多态主机中选出一台作为接收端的一种通信方式。 地址在实际的网络通信中，每一层的协议所使用的地址都是不尽相同的，例如TCP/IP中使用MAC地址、IP地址、端口号等信息作为地址标识。甚至在应用层中，可以将电子邮件地址作为网络通信的地址。 MAC地址由设备制造商对每块网卡分别指定。但对于寻址并没有起到任何作用，所以不能算作有层次的地址。正因如此，虽然MAC地址是真正复杂通信地址，但在实际寻址过程中，IP地址却必不可少。 网络构成的要素","categories":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/categories/图解TCP-IP/"}],"tags":[{"name":"图解TCP/IP","slug":"图解TCP-IP","permalink":"https://luoyec.cn/tags/图解TCP-IP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"}]},{"title":"分析算法","date":"2017-09-06T12:04:30.000Z","path":"2017/09/06/cjqoyqt0t0066hl6pzil9b5ix/","text":"关注的是计算时间 分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存、通信宽带或计算机硬件这类资源，但通常我们想度量的是计算时间。 最坏情况和最好情况往往集中于只求最坏情况的运行时间，即对规模为n的任何输入，算法的最长运行时间 最坏的运行时间确定了一个上界，这可以确保算法绝对不会需要比这更长的运行时间 对于某些算法，最坏的情况经常出现 “平均情况”往往与最坏大致一样差 增长量级我们只考虑公式中最重要的项（如 an^2）,因为当n的值很大时，低阶相对来说不太重要。我们也忽略最重要的项的常数项，因为对大的输入，在确定计算效率时常量银子不如增长率重要。 练习题θ记号 θ(n^3) - θ(n^2) - 100n 忽略低阶项则为 θ(n^3) 选择排序 123456for i &lt;- 1 to length[A]-1 do min &lt;- i for j &lt;- i+1 to length[A] do if A[j] &lt; A[min] then min &lt;-j exchange(A[i], A[min]) 使用TypeScript实现选择算法 1234567891011121314151617181920212223242526272829303132333435class SelectSort &#123; private sortArray: Array&lt;number&gt; public constructor(arr: Array&lt;number&gt;) &#123; this.sortArray = arr this.selectSort() &#125; private selectSort(): void &#123; let len: number = this.sortArray.length for (let i: number = 0; i &lt; len; i++) &#123; let min: number = this.sortArray[i] let temp: number let index: number for (let j = i + 1; j &lt; len; j++) &#123; if (this.sortArray[j] &lt; min) &#123; min = this.sortArray[j] index = j &#125; &#125; temp = this.sortArray[i] this.sortArray[i] = min this.sortArray[index] = temp &#125; &#125; public printSortWell() &#123; console.log(this.sortArray.toString()) &#125;&#125;let selectSort: SelectSort = new SelectSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])selectSort.printSortWell() 选择排序时间复杂度 选择排序的时间复杂度是O(N2)。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1！因此，选择排序的时间复杂度是O(N2) 线性查找再次考虑线性查找问题，在平均情况下，需要检查输入序列中的多少个元素？假定待查找的元素是数组中任何一个元素的可能性相等，在最坏情况下又怎样呢？用O形式表示，线性查找最坏情况运行时间是多少？并说明 平均情况下需要查找序列中(1+n)/2个元素 最坏情况下：n个元素。即O(n)为最坏 修改算法以获取最佳运行时间应如何修改任何一个算法，才能使之具有较好的最佳情况运行时间 根据算法的最佳情况改变输入数据的分布（比如说顺序），使之符合最佳情况条件，这样就能拥有最佳运行时间。 总之是制造出符合最佳情况的条件","categories":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/categories/算法导论/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/tags/算法导论/"},{"name":"习题答案","slug":"习题答案","permalink":"https://luoyec.cn/tags/习题答案/"}]},{"title":"异步操作和async函数","date":"2017-09-03T15:59:51.000Z","path":"2017/09/03/cjqoyqt0z006khl6pi7835s4r/","text":"异步编程对于JavaScript是极为重要的。JavaScript只有一个线程，如果异步编程，得卡死，基本没法用。 ES6诞生之前，异步编程的方法大概有以下几种： 回调函数 事件监听 发布/订阅 Promise对象 ES7中的async函数更是给出异步编程的终极解决方案 基本概念异步所谓“异步”，简单说就是一个任务分成两段执行，先执行第一段，然后转而执行其他任务，等做完准备工作再回过头执行第二段。 相应的，连续执行的就叫同步。 回调所谓“回调”就是把任务的第二段单独写在一个函数中，等到重新执行该任务时直接调用这个函数。 读取文件进行处理是这样写的： 1234fs.readFile('/etc/passwd', function(err, data) &#123; if (err) throw err console.log(data)&#125;) 为什么nodejs约定回调函数的第一个参数必须是错误对象err（如果没有错误，该参数就是null）？原因是执行拆分成两段，在这两段之间抛出的错误程序无法捕获，只能当做参数传入第二段 Promise当回调函数过多，多重嵌套。代码不是纵向发展而是横向发展，很快代码就会乱成一团。Promise就是为了解决这个问题诞生的。 Promise不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载改成纵向加载。 123456789101112131415var readFile = require('fs-readfile-promise')readFile(fileA).then(function(data)&#123; console.log(data.toString())&#125;).then(function()&#123; return readFile(fileB)&#125;).then(function()&#123; console.log(data.toString())&#125;).catch(function(err)&#123; console.log(err)&#125;) Promise最大的问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义并不清楚。 Thunk函数传名调用和传值调用 传值调用：在进入函数之前，就计算参数的值 12345var x = 1f(x + 5) //传值调用等同于f(6) 传名调用：传值调用比较简单，但是对参数求值时并未使用这个参数，有可能造成性能损失。而传名调用就是只在执行时求值 Thunk函数的含义编译器“传名调用”实现往往是先将参数放到一个临时函数中，在将这个临时函数传入函数体。这个临时函数就叫Thunk 12345678910111213function f(m) &#123; return m * 2&#125;f (x + 5)//等同于 参数放到一个临时函数var thunk = function() &#123; return x + 5&#125;function f(thunk) &#123; return thunk() * 2&#125; async函数async函数返回值是Promise，你可用then方法指定下一步操作。 async函数实现async函数的实现就是将Generator函数和自动执行器包装在一个函数中12345678async function fn(args) &#123; //参数运算&#125;//等同于function fn(args) &#123; return spawn(function *)&#125; asycn的用法同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行时，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后台的语句 123456789async function getStokPriceByName(name) &#123; var symbo = await getStockSymbol(name) var stockPrice = await getStockPrice(symbol) return stockPrice&#125;getStockPriceByName('goog').then(function(result)&#123; console.log(result)&#125;) 上面的代码是一个获取股票报价的函数，函数前面的async关键字表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面这个例子指定了多少毫秒后输出一个值。 123456789101112function timeout((resolve) =&gt; &#123; setTimeout(resolve, ms)&#125;)async function asyncPrint(value, ms) &#123; await timeout(ms) console.log(valuse)&#125;asyncPrint(\"Hello World!\", 50)//50毫秒后输出, \"Hello World!\" 注意点await命令后面的Promise对象，运行结果可能是Rejected，所以最好把await命令放在try…catch代码块中 123456789async function myFunction() &#123; try &#123; await( await somethingThatReturnAPromise() )catch (err) &#123; console.log(err) &#125; &#125;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://luoyec.cn/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://luoyec.cn/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://luoyec.cn/tags/异步/"},{"name":"《ES 6标准入门》","slug":"《ES-6标准入门》","permalink":"https://luoyec.cn/tags/《ES-6标准入门》/"}]},{"title":"算法基础-插入排序&&习题2.1-3、2.1-4","date":"2017-09-02T07:23:24.000Z","path":"2017/09/02/cjqoyqt1f007jhl6pfjm75lp0/","text":"插入排序 对于少量排序，它是一个很好的算法。开始时，我们的左手为空，并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中的正确位置。为了找到一张牌的正确位置，我们从右往左将它与已在手中的每张牌比较。如图所示，拿在左手中的牌总是排序好的。 TypeScript实现1234567891011121314151617181920212223242526272829303132class InsertionSort &#123; private sortArray: Array&lt;any&gt; public constructor(A: Array&lt;any&gt;) &#123; this.sortArray = A this.insertionSort() &#125; private insertionSort(): void &#123; for (let j = 1; j &lt; this.sortArray.length; j++) &#123; let key: any = this.sortArray[j] let i: number = j - 1 while (i &gt;= 0 &amp;&amp; this.sortArray[i] &gt; key) &#123; this.sortArray[i + 1] = this.sortArray[i] i = i - 1 &#125; this.sortArray[i + 1] = key &#125; &#125; public printSortResult(): void &#123; console.log(this.sortArray) &#125;&#125;let sort = new InsertionSort([31, 41, 59, 26, 41, 58])sort.printSortResult()/* 运算结果：[ 26, 31, 41, 41, 58, 59 ]*/ 时间复杂度插入排序的时间复杂度分析。在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + … + (N - 1)，等差数列求和，结果为 N^2 / 2，所以最坏情况下的复杂度为 O(N^2)。 最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(N)。 练习题考虑以下查找问题：输入： n个数的一个序列A={ a1, a2, …, an } 和一个值v。输出： 下标i使得v=A[i]或者当v不在A中时，v为特殊值NIL。写出线性查找 的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保循环不变式满足三条必要的性质 伪代码 12345LINEAR-SEARCH(A, v)1 for i &lt;- 1 to len(A)2 do if A[i] == v3 then return i4 return NIL 二进制相加考虑把两个n位二进制证书加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数和应按二进制形式存储在一个（n+1）元数组中。 其实就是二进制相加， 用TypeScript实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BinaryAddition &#123; private A: Array&lt;number&gt; = [1, 1, 0, 0, 1, 0, 1, 1, 1, 0] private B: Array&lt;number&gt; = [1, 1, 1, 0, 1, 1, 0, 1, 1, 1] private C: Array&lt;number&gt; = [] private lastflow: number = 0 public constructor() &#123; this.binaryAdditionResult() this.printResult() &#125; private addMethod(a: number, b: number): number &#123; let r: number = a + b + this.lastflow if (r &gt; 1) &#123; this.lastflow = 1 return r % 2 &#125; else &#123; this.lastflow = 0 return r &#125; &#125; private binaryAdditionResult(): void &#123; let n: number = this.A.length for (let i = n - 1; i &gt;= 0; --i) &#123; this.C[i + 1] = this.addMethod(this.A[i], this.B[i]) &#125; this.C[0] = this.lastflow &#125; private printResult(): void &#123; console.log('A ' + this.A) console.log('B ' + this.B) console.log('C ' + this.C) &#125;&#125;let binaryAddition: BinaryAddition = new BinaryAddition()/* 运算结果：A 1,1,0,0,1,0,1,1,1,0B 1,1,1,0,1,1,0,1,1,1C 1,1,0,1,1,1,0,0,1,0,1*/","categories":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/categories/算法导论/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/tags/算法导论/"},{"name":"习题答案","slug":"习题答案","permalink":"https://luoyec.cn/tags/习题答案/"}]},{"title":"算法在计算中的作用","date":"2017-08-30T15:10:01.000Z","path":"2017/08/30/cjqoyqt1d007hhl6py2jybuh2/","text":"算法给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子？凸包问题概念假设平面上有p0~p12共13个点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。 直观地讲，可以把Q中每个点都想象成是露在一块板外的铁钉，那么凸包就是包围这些铁钉的一条拉近了的橡皮绳所构成的形状。 实例根据所有的果树的位置，找出一个n边形的最小篱笆，使 得所有果树都包围在篱笆内部，或者在篱笆边沿上。也就是，一组平面上的点，求一个包含所有点的最小的凸多边形。 除速度外，在真实环境中还可能使用哪些其他有关效率的夺量 占用资源的大小（在计算机中可以成为空间），问题解决的程度 选择一种你以前一直的数据结构，并且讨论其优势和局限 栈:后进先出，非常适合于保存程序调用的迒回地址之类的特殊应用（递归调用），缺点是无法进行随机的读写 最短路径与旅行商问题的相似之处和不同之处 相同之处：都是要求出最短总距离 不同之处：终点的不同，同时最短路径不需要遍历全部的点，而那个旅行商问题就是需要遍历所有的点的问题 商旅问题没有已知的有效算法，然而，我们知道一些算法，他们给朱一个离最小值不太远的总距离。35章中会讨论近似算法问题。 提供一个问题，其中只有最佳解才行，然后提供一个问题，其中近似最佳的一个解也足够好 最短路径、商旅问题 作为技术的一种算法给出在应用层需要算法内同的应用的一个例子，并且讨论设计的算法的功能 在一次有 210 人参加的考试结束后，老师需要对平均分迕行计算。假设老师不借助于计算机类的自动工具，而是采取传统的手工计算平均分。计算方法：看过考分后，大概估计一个值K ，然后与 210 个分数的数据迕行比较，找出分数与k的误差ci，如果发现有ci=-ci，则去掉，假设最后的误差和是bi，那么平均分就可以写成K+bi/210.设计的算法的功能：该算法对于计算机返样的自动化计算工具来说意义不大，但是对于手工计算来说，却是很实用的。在计算的过程中，首先把大数转换成了小数，然后在比较时又直接把一些数据剔除，减少了运算量。最终大大加快了计算效率，幵且提高了计算准确度。 假设我们正在比较插入排序和归并排序在相同机器上面的实现，对于规模为n的输入，插入排序运行8n^2步，而归并排序运行64nlgn步。问对于哪些n值，插入排序优于归并排序？答： 令 8n^2 &lt; 64nlgn=&gt; 化简得n &lt; 8lgn=&gt; 2^(n/8) &lt; 2^(lgn)=&gt; 2^(n/8) &lt; n=&gt; 令t=n/8 , n=8t=&gt; 2^t &lt; 8t=&gt; 制表： 1 2 3 4 5 68t 8 16 24 32 40 482^t 2 4 8 16 32 64当t=0 8t=0 2^t=1当t=0.2, 8t=1.6 2^t=1.15当t=5.1， 8t=40.8 2^t=34.3当t=5.4, 8t=43.2 2^t=42.2当t=5.5, 8t=44 2^t=45.25所以，当0.2 &lt; t &lt; 5.5时，即1 &lt; n &lt; 44时，插入排序优于归并。 n的最小值为何值时，运行时间为100n^2的一个算法在相同的机器上面快于运行时间为2^n的另外一个算法答：令100n^2&lt;2^n =&gt; 由图可得当n&gt;14.325时，满足不等式，又n为正整数，所以n取最小值15。 思考题运行时间的比较 答：具体的答案数据就不列出来了，但可以肯定的是，从上到下，算法效率是逐渐降低的，意思是说一个算法若能做到lgn的效率是极佳的，而如果做到n！的话则是最不可取的了。 参考资料： 算法导论1：第一章算法的作用 奕思第一章 算法在计算机中的应用 技术老鸟","categories":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/categories/算法导论/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://luoyec.cn/tags/算法导论/"},{"name":"习题答案","slug":"习题答案","permalink":"https://luoyec.cn/tags/习题答案/"}]},{"title":"Egret MVC通用框架HTTP请求实践（GET请求）","date":"2017-08-29T09:31:52.000Z","path":"2017/08/29/cjqoyqsxo000fhl6pw7waybhj/","text":"参考资料：URLLoader网络通讯Egret游戏通用开发框架–MVC篇 引 在原有MVC的基础上， 增加了一层Proxy用于进行通信。 BaseModel，是Model的基类，负责该Module的数据存储，每个Module只存在一个Model BaseGuiView、BaseSpriteView，是View的基类，都实现了IBaseView接口，负责该Module的View层显示及View层的基础逻辑，两个类的不同在于，BaseGuiView继承自egret.gui.SkinnableContainer，用于使用GUI的View，BaseSpriteView继承自egret.Sprite，用于不使用GUI的View，每个Module可以有多个View BaseController，是Controller的基类，负责Module内部、Module与Module之间的事件交互，每个Module只存在一个Controller BaseProxy，是Proxy的基类，负责该Module与服务器的数据通信交互，支持Http和WebSocket 实例财富榜实例文件结构 如何请求数据在Controller构造函数中初始化模块内的View、Proxy、Model，并且注册模块内、模块内部事件监听 1234public constructor() &#123; this.registerFunc(JackWealthConst.GAMERANKING_C2S, this.getGameRanking, this) this.registerFunc(JackWealthConst.GAMERANKING_S2C, this.getGameRankingSuccess, this)&#125; 在getGameRanking()方法中，调用Proxy的方法，用以HTTP请求，此时需要获取到GET请求所需的参数，这里只需要获取gameID 1234567891011121314151617 /** * 请求获取财富值排行榜处理 */ private getGameRanking(): void &#123; let userInfo:any = egret.localStorage.getItem(JackGameConst.Get_User_Information) let gameId:string = JSON.parse(userInfo).gameId this.jackWealthProxy.getGameRanking(gameId) &#125;//Proxy.tspublic getGameRanking(gameId: string): void &#123; let param: string = `/gameRanking?gameId=$&#123;gameId&#125;` this.getHttpMsg(HttpConst.JACK_GAME_RANKING, param)&#125; 在Proxy中，需要注册从服务器返回的消息监听，并有相应的处理函数，用以通知Controller数据请求成功 12345678910111213141516171819class JackWealthProxy extends BaseProxy &#123; public constructor($controller: BaseController) &#123; super($controller); //注册从服务器返回消息的监听 this.receiveServerMsg(HttpConst.JACK_GAME_RANKING, this.getGameRankingSuccess, this); &#125; public getGameRanking(gameId: string): void &#123; let param: string = `/gameRanking?gameId=$&#123;gameId&#125;` this.getHttpMsg(HttpConst.JACK_GAME_RANKING, param) &#125; private getGameRankingSuccess(obj: any): void &#123; this.applyFunc(JackWealthConst.GAMERANKING_S2C, obj) &#125;&#125; 数据请求成功在Controller中已经注册了监听到数据请求成功的处理函数，在该处理函数中完成模块所需的逻辑处理 123456789/** * 请求获取财富值排行榜成功 */private getGameRankingSuccess(gameRanking: any): void &#123; //保存数据 this.jackWealthModel.gameRanking = gameRanking //本模块UI的处理 this.addItemToWealth()&#125; 扩展框架的HTTP请求框架原有的请求方法中，只写了POST（可能有误？） 参考URLLoader网络通讯 修改 /core/net/http/Http.ts增加所需要的属性 当我们需要创建一个网络连接的时候，我们需要创建一个 URLLoader 对象，该对象负责网络的连接状态操作， 同时负责接收网络回传的数据。网络通信时，需要的网络通信数据由 URLRequest 对象负责管理。 12345//GET请求相关属性private _getRequest: egret.URLRequest //URL请求对象private _getCache: Array&lt;any&gt; //请求缓存，其实数组，实现按顺序请求private _isGetRequesting: boolean //是否在请求的标志符private _urlGetLoader: egret.URLLoader; // 初始化属性和添加事件监听 1234567this._getRequest = new egret.URLRequest()this._getRequest.method = egret.URLRequestMethod.GETthis._getCache = []this._urlGetLoader = new egret.URLLoader()this._urlGetLoader.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onGetError, this) 核心方法 12345678910111213141516171819202122232425262728/** * 增加HTTP GET请求数据方法 */public getData(type: string, param: string): void &#123; this._getCache.push([type, param]) this.get()&#125;private get(): void &#123; if (this._isGetRequesting) &#123; return &#125; if (this._getCache.length == 0) &#123; return &#125; let arr: Array&lt;any&gt; = this._getCache.shift() let type: string = arr[0] let getparam: string = arr[1] this._type = type this._getRequest.url = this._serverUrl + getparam this._urlGetLoader.addEventListener(egret.Event.COMPLETE, this.onGetLoaderComplete, this) this._urlGetLoader.load(this._getRequest) this._isGetRequesting = true&#125; 请求成功之后需要派发相应事件，需要注意的这个时间的类型，就是之前在Proxy方法中参数的 this.getHttpMsg(HttpConst.JACK_GAME_RANKING, param) 123456789101112private onGetLoaderComplete(event: egret.Event): void &#123; this._urlGetLoader.removeEventListener(egret.Event.COMPLETE, this.onGetLoaderComplete, this) let msg: any = JSON.parse(this._urlGetLoader.data) if (msg) &#123; App.MessageCenter.dispatch(this._type, msg) &#125; else &#123; Log.trace(\"Http错误\") &#125; this.nextGet();&#125; 派发事件后，在相应注册了事件监听Controller中就能拿到请求成功的数据msg了，用以保存到Model、通知view进行相应的数据渲染 渲染结果","categories":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/categories/Egret/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://luoyec.cn/tags/HTTP/"},{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/tags/Egret/"},{"name":"MVC","slug":"MVC","permalink":"https://luoyec.cn/tags/MVC/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（15）","date":"2017-08-26T04:03:04.000Z","path":"2017/08/26/cjqoyqszx004phl6p5tl9dzgj/","text":"设计模式 创建一个软件系统时，实际上是对一个真实系统建模。 设计模式的基本概念以最佳实践原则为中心。所谓最佳实践，当创建好的、高效的解决方案时，这些解决方案会以某种方式记录下来，使其他人能够从先前已取得的成功获益——当然也包括从以往的失败学习。 为什么研究设计模式 每个模式都描述了在我们环境中反复出现的一个问题，然后介绍这个问题解决方案的核心，以便多次使用这个解决方案，而不必反复地重复工作。 模式的四大要素 模式名是描述一个设计问题 问题描述了何时应用这种模式 解决方案描述了构成设计的元素，以及元素之间的关系、元素的职责和协作 结果描述应用这种模式的结果和开销 模型/视图/控制器（MVC） 《设计模式》将MVC组件定义如下：模型是应用对象，视图是屏幕表示，而控制器定义了用户界面与用户输入之间的交互方法。 设计模式的不同类型 创建型模式：这些模式为你创建对象，而不是由你直接实例化对象。这样在确定给定情况下需要创建哪些对象时，程序会有更多的灵活性 结构性模式：可以帮助你将多组对象组合为更多的结构，如果复杂用户界面或审计数据 行为型模式：帮助你定义系统中对象之间的通信，以及复杂程序中如何控制数据流 创建型模式 抽象工厂模式 生成器模式 工厂方法模式 原型模式 单例模式 结构型模式 适配器模式 桥接模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型模式 职责链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 策略模式 模板方法模式 访问者模式 小结简单介绍设计模式，及《设计模式》中列举的模式类型。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（9）","date":"2017-08-26T03:36:02.000Z","path":"2017/08/26/cjqoyqt0h005ghl6pm76gfzth/","text":"构建对象前面主要的内容是继承、接口、抽象类和组合如果结合使用。本章主要关于整体设计中对象之间如何关联的问题。 继承和组合在构建对象上的方式有显著区别，使用继承是，结果是单个类，其中覆盖继承层次结构中的所有行为和属性。而使用组合时，会使用一个或者多个类来构建另一个类。 使用组合使用组合的原因，可以通过结合不太复杂的部分来构建系统。 分阶段构建 要构建高质量的软件，必须遵守的一条最高原则才能成功：尽可能成功。要让软件系统正常地工作而且易于维护，它们必须分解为较小、更可管理的部分。 诺贝尔得主Herbert Simon对稳定系统的观点： “稳定的复杂系统通常采用一种层次结构的形式，其中各个系统都是由更简单的子系统构成，而各个子系统则由更贱的下一级子系统构成” “稳定的复杂系统几乎都是可以分解的” “稳定的复杂系统几乎总是由几个不同类型的子系统组成，并以不同的结合方式组织” “能正常工作的稳定系统几乎总是由能正常工作的简单系统发展而来” 不同类型的组合一般来说，组合有两种类型：关联和聚集 聚集聚集是指一个复杂对象由其他对象组成。 关联当一个对象希望另一个对象为它完成某个服务时则使用关联。 结合使用关联和聚集 与以往一样，做设计决策时并没有一种绝对正确的答案。设计不是精确的科学，尽管我们可以遵守一些一般规则，但是这些规则并不是硬性规定。 避免依赖性小结聚集和关联。继承表示在现有对象基础上创建新对象，而组合表示不同对象之间的交互。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（8）","date":"2017-08-26T03:05:58.000Z","path":"2017/08/26/cjqoyqt0g005chl6pjsedpv49/","text":"框架与重用： 使用接口和抽象类实现设计本章讨论代码重用、框架、契约、接口和抽象类等主题 代码：重用还是不重用OO方法提供了一些机制，有利于可重用diamante的开发。创建可重用代码的一种方法就是创建框架。本章将重点讨论如何使用接口和抽象类来创建框架，并促进重用diamante开发。 什么是框架框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法; 另一种定义认为，框架是可被应用开发者定制的应用骨架。 什么是契约契约是要求开发人员遵守应用编程接口规范所需的机制。 抽象类实现契约的一种方法是通过抽象类来实现；。抽象类（abstract class）包含一个或者多个没有提供任何具体实现的方法。 采用这种只有声明而没有实现的方法，可以实现多态。在实例化的对象中重写父类的方法。 接口接口并没有被声明为一个类，接口包含了抽象方法，这些方法中没有实现。也可以说，接口不提供任何实现。因此，实现了接口的任何类都必须提供所有的方法的实现。 集成问题：抽象类可以同时提供抽象方法和具体方法，而接口之鞥呢提供抽象方法。为什么会存在这一个区别？ 继承时建立在密切的联系的继承上，而接口并没有这种联系。抽象类表示某种实现，但是接口并不会提供任何类型的实现，只提供行为，说明是一个说明方法。所以接口可以独立在抽象类之外而不受的类的制约，在需要的时候都可以实现接口。 编译器的证明建立契约定定义契约的简单规则是提供一个未实现的方法，可以通过抽象类提供，也可以通过接口提供。因此，当设计一个子类来实现某个契约时，它必须为父类或接口中未实现的方法提供实现。 小结设计了和对象模型时，最为重要的是理解对象直接如何关联。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（7）","date":"2017-08-23T14:27:46.000Z","path":"2017/08/23/cjqoyqt0d005ahl6pv53ey2z8/","text":"掌握继承和组合继承和组合都是实现重用的机制。 继承（inheritance）是指从其他类继承属性和行为。 组合（subclass）是指使用其他对象来构建对象。 重用对象最根本的是，继承和组合都是构建OO系统的重要技术。只是设计人员和开发人员需要花时间来了解这两种技术的优点和缺点，并在合适的情况下正确加以使用。 继承一般化与特殊化其思想是，逐步向下建立继承树时对象会越来越具体。 设计决策设计时要保证更低的复杂性还是提供更多的功能？ 组合如果某个对象由其他对象组成，而这些对象作为字段包含在内，在这个新对象就称为复合对象（compound object）、聚合对象（aggregate object）或组合对象（composite object） 一个很经典的机车的例子： 为什么封装在OO中如此重要继承如何削弱封装 问题在于，如果从一个父类继承一个实现，然后修改这个实现，那么父类的修改会对整个类层次结构产生涟漪作用。这种涟漪效应可能会影响所有的子类。 严格设计好继承关系是解决这个问题的方法。 多态的一个详细例子 多态的字面含义是多种形状，将一条消息发送给一个对象时，这个对象必须定义相应的方法对这个消息做出响应。 对象职责小结 组合在大多数情况下都比继承更适用，不过这不并不意味着继承一无是处，组合和继承都可以使用，但只应该在其适当的上下文中使用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（6）","date":"2017-08-23T13:51:17.000Z","path":"2017/08/23/cjqoyqt0c0056hl6pn5jd37ic/","text":"利用对象实现设计本章的重点是介绍如何设计好的系统。 设计指导原则一般的一个可靠的OO设计过程包括以下步骤： 完成适当的分析 建立一份描述系统的工作陈述 从这个工作陈述中收集需求 开发一个用户界面原型 明确类 确定各个类的职责 确定各个类如何互相交互 创建一个高层模型来描述要构建的系统 本章主要关注最后一点，系统或者对象模型由类图和类交互构成。这个模型应当真实地表示系统，而且要易于理解和修改。 完成适当的分析设计阶段的重点则是要让每个人都了解系统（包括老系统和新的系统），并确定系统需求。 建立工作陈述工作陈述（statement of work，SOW）是一个描述系统的文档。 收集需求需求文档（requirements document）描述了用户系统系统做什么。需求是必须实现的系统的最终描述，软件开发过程中的所有文档都要以这些需求为基础。 开发用户界面原型明确类重点标记所有名词。 确定各个类的职责确定各个类如何互相交互创建一个高层模型来描述要构建的系统既然已经确定了所有类，而且列出了类职责并明确了类如何协作，下面就可以构建一个类模型来标识完成系统。 将使用UML对系统建模。 案例研究： blackjack","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（5）","date":"2017-08-22T16:31:50.000Z","path":"2017/08/23/cjqoyqt0a0052hl6p48e9mak9/","text":"类设计指导原则本章为如何设计健壮的类提供一些建议。 真实世界系统建模面向对象（OO）程序设计的主要目标之一就是以类似于人们真正的思维方式对真实世界的系统建模。设计类就是创建这些模型的面向对象方式。 第一次转向OO开发时，许多人倾向于采用一种结构化的方式思考。由此导致主要的错误之一就是创建的类只包含行为而没有数据。实际上，他们创建的只是结构化模型的一组函数或子例程。 明确公共接口设计类时，最重要的问题可能就是保证公共接口的最小。构建类的根本目的就是提供一些有用而且简洁的功能。 最小接口提供最小接口可以使类尽可能简洁。 扩展接口对于一个特定应用，及时一个类的公共接口还不够，使用对象技术也能很容易的利用继承扩展并调整这个接口。简单来讲，如何设计时考虑到继承，新类可以继承一个原有的类，从而创建一个有扩展接口的新类。 隐藏实现设计健壮的构造函数（和析构函数）首先，也是最重要的，构造函数应当将对象置于一种安全的初始状态。这包括属性初始化和内存管理等问题。 析构函数要包含适当的清理功能。 内存泄露如果一个对象未能适当地释放它在对象生存周期中获得的内存，那么只要创建这个对象这个对象的应用还在执行，对于整个操作系统来说这部分内容就丢失了。在极端情况，消耗掉系统所有可用的内存。 在类中设计的错误处理对类建立文档以及使用注释 过多的文档要注意，如果注释过多也会有问题，看起来很杂乱，有可能影响建立文档的初衷 构建类要以合作为出发点设计时充分考虑重用设计时充分考虑到可扩展性为一个类增加新特性可能很简单，只需扩展一个现有的类，增加一些新方法，并修改其他方法的行为。不必重写代码。这里使用继承。 名字要有描述性 好的命名确保坚持一种命名约定很有意义。使名字具有描述性是一个很好的开发实践，这在各种开发泛型中都使用。 抽出不可移植的代码将这些不可移植的代码单独放在一个类中，或者至少放在一个方法中。 提供一种复制和比较对象的方法让作用域尽可能小这种思想是尽可能将属性和行为置于局部。采用这种方式，维护、测试和扩展类就会容易很多。 类应当对自己负责类的设计原则是：所有对象都应当尽可能自行负责自己的行为。 设计时充分考虑可维护性一个类中的修改不会对其他类产生影响，或者影响尽可能小。 高度耦合的类彼此相当依赖的类被认为是高度耦合（highly coupled）。因此对一个类的修改还要求对另一个类进行修改，这两个类就是高度耦合的。没有这种依赖关系的耦合度很低。 采用迭代类设计推荐一种迭代过程，这与提供最小接口的概念恰好一致。 测试接口使对象持久性保存对象状态以备以后使用的三种方法： 平面文件系统：可以通过串行化对象将对象保存在一个平面文件中 关系数据库：必须使用某种中间件将对象转换成关系模型 OO数据库：这是保证对象持久化的最合理的做法 对象串行化和封送通过网络发送一个对象，然后在另一端重新合成。这个过程成为串行化（serializing）一个对象。通过网络发送对象的行为称为封送（marshaling）一个对象。 主要的问题是，串行化和反串行化都必须使用相同的规范。这有些类似于加密算法。 小结这一章提供了许多指导原则。一类不会独立存在，类必须设计与其他类交互。彼此交互的一组类会作为系统的一部分。最后，再由这些系统为最终用户提供服务。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"},{"name":"OO","slug":"OO","permalink":"https://luoyec.cn/tags/OO/"}]},{"title":"Egret 图片缓动动画实现","date":"2017-08-22T10:18:36.000Z","path":"2017/08/22/cjqoyqsxr000jhl6pipkhleik/","text":"参考官方缓动动画文档参考官方实例演示 前言egret中实现动画的方式，有几种，缓动动画、关键帧、序列帧、龙骨动画。在不同场景下可以选择适合的动画实现方式。这里只介绍缓动动画。 通常情况下，游戏中或多或少都会带有一些缓动动画。例如界面弹出，或者道具飞入飞&gt;出的特效等等。在制作这些缓动动画的时候我们仅仅 希望简单的办法实现这种移动或者&gt;变形缩放的效果。Egret中的 Tween 缓动动画类就为我们提供了相关的功能。 添加tween模块从Egret 2.5 开始，以官方扩展模块的形式支持 Tween 。在现有的 Egret 项目中，修改egretProperties.json中的modules，添加 tween 模块： 123&#123; \"name\": \"tween\"&#125; 在项目所在目录内执行一次引擎编译： 1egret build -e 本步骤已经完成，现在项目中既可以使用 Tween 相关的API了。 资源加载 只有当所需的资源加载完成之后才能获取资源，并赋予动画。 使用通用MVC框架，这里简单介绍其资源加载策略。 以下为部分代码 main.ts1234567891011121314151617181920212223242526272829303132333435363738394041class Main extends egret.DisplayObjectContainer &#123; //初始化场景及模块 this.initScene(); this.initModule(); App.SceneManager.runScene(SceneConsts.LOADING); //加载资源版本号 if (false) &#123; App.ResVersionManager.loadConfig(\"resource/resource_version.json\", this.loadResVersionComplate, this); &#125; else &#123; this.loadResVersionComplate(); &#125; &#125; private loadResVersionComplate(): void &#123; //初始化Resource资源加载库（这里加载自动以的资源配置方案，如龙骨动画资源、框架核心资源），静态资源加载完成事件 App.ResourceUtils.addConfig(\"resource/default.res.json\", \"resource/\"); App.ResourceUtils.addConfig(\"resource/resource_core.json\", \"resource/\"); App.ResourceUtils.addConfig(\"resource/resource_ui.json\", \"resource/\"); App.ResourceUtils.addConfig(\"resource/resource_battle.json\", \"resource/\"); App.ResourceUtils.loadConfig(this.onConfigComplete, this); &#125; /** * 配置文件加载完成,开始预加载preload资源组。 */ private onConfigComplete(): void &#123; //加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。 var theme = new eui.Theme(\"resource/default.thm.json\", this.stage); theme.addEventListener(eui.UIEvent.COMPLETE, this.onThemeLoadComplete, this); &#125; /** * 主题文件加载完成 */ private onThemeLoadComplete(): void &#123; new BlackJack(); &#125;&#125; BlackJack.ts 12345678910111213141516171819202122232425262728293031class BlackJack &#123; public constructor() &#123; var groupName: string = \"preload\" //此处将页面所需的资源分组加载，加载完成后就能拿到图片以实现动画啦 var subGroups: Array&lt;string&gt; = [\"preload_core\", \"preload_ui\", \"welcome\"] App.ResourceUtils.loadGroups(groupName, subGroups, this.onResourceLoadComplete, this.onResourceLoadProgress, this) &#125; private onResourceLoadComplete(): void &#123; this.initModule() App.Init() //音乐音效处理 App.SoundManager.setBgOn(true) App.SoundManager.setEffectOn(!App.DeviceUtils.IsHtml5 || !App.DeviceUtils.IsMobile) //场景管理 有三类场景 App.SceneManager.runScene(SceneConsts.UI) &#125; private onResourceLoadProgress(itemsLoaded: number, itemsTotal: number): void &#123; App.ControllerManager.applyFunc(ControllerConst.JackLoading, LoadingConst.SetProgress, itemsLoaded, itemsTotal); &#125; /** * 初始化所有模块 */ private initModule(): void &#123; App.ControllerManager.register(ControllerConst.JackWelcome, new JackWelcomeConstroller()) &#125;&#125; JackWelcomeConstroller.ts 12345678910111213/* 初始化view模块，并注册到全局的view管理器中*/class JackWelcomeConstroller extends BaseController &#123; private jackWelcomeView: JackWelcomeView public constructor() &#123; super() this.jackWelcomeView = new JackWelcomeView(this, LayerManager.UI_Main) App.ViewManager.register(ViewConst.JackWelcome, this.jackWelcomeView) &#125;&#125; JackWelcomeView.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class JackWelcomeView extends BaseEuiView &#123; public constructor($controller: BaseController, $parent: eui.Group) &#123; super($controller, $parent) this.skinName = \"resource/black_jack/skins/JackWelcomeUiSkin.exml\" &#125; private welcomeInfoBtn: eui.Button /** * 对面板初始化，用于子类继承 */ public initUI(): void &#123; super.initUI() this.welcomeInfoBtn.addEventListener(egret.TouchEvent.TOUCH_TAP, this.imagesTweenStart, this) this.addImageToStage() &#125; /* 需要赋予动画的三个图片元素 */ private banner: egret.Bitmap private infoGo: egret.Bitmap private infoText: egret.Bitmap /* 实例化图片，并添加到当前页面中 */ private addImageToStage(): void &#123; let banner = new egret.Bitmap() //获取前面加载好的资源文件 banner.texture = RES.getRes('welcome_banner_png') banner.x = -50 banner.y = 274 this.addChild(this.banner = banner) let infoText = new egret.Bitmap() infoText.texture = RES.getRes('welcome_info_text_png') infoText.x = 35 + this.width infoText.y = 190 this.addChild(this.infoText = infoText) let infoGo = new egret.Bitmap() infoGo.texture = RES.getRes('welcome_info_go_png') infoGo.x = 269 + this.width infoGo.y = 924 this.addChild(this.infoGo = infoGo) &#125; /* 监听触发动画的按钮 */ private imagesTweenStart(): void &#123; let bannerDis: number let infoTextDis: number let infoGoDis: number if (this.banner.x == -50) &#123; bannerDis = -850 infoTextDis = 35 infoGoDis = 269 &#125; else &#123; bannerDis = -50 infoTextDis = 800 infoGoDis = 1034 &#125; /* 关键代码 */ egret.Tween.get(this.banner).to(&#123; x: bannerDis &#125;, 300, egret.Ease.sineIn) egret.Tween.get(this.infoText).to(&#123; x: infoTextDis &#125;, 300, egret.Ease.sineIn) egret.Tween.get(this.infoGo).to(&#123; x: infoGoDis &#125;, 300, egret.Ease.sineIn) &#125;&#125; 实现效果","categories":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/categories/Egret/"}],"tags":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/tags/Egret/"},{"name":"缓动动画","slug":"缓动动画","permalink":"https://luoyec.cn/tags/缓动动画/"},{"name":"交互效果","slug":"交互效果","permalink":"https://luoyec.cn/tags/交互效果/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（4）","date":"2017-08-22T06:27:50.000Z","path":"2017/08/22/cjqoyqt09004yhl6pboxlwzug/","text":"类剖析实例化对象时，几乎总要与其他对象交互，一个对象也有可能作为另一个对象的一部分，或者是一个继承层次结构中组成部分。 类名简单的标识、具有描述性、提供类做什么以及与其在交互系统中如何交互的信息。 注释注释风格 12345678910/****//**/ 属性 尽可能地隐藏数据属性私有，能够保证接口设计尽可能少的设计原则是一致的。访问这些属性的唯一途径就是通过所提供的方法接口。 static关键字对于这个类实例化的所有对象来说，这个属性只有一个副本。 private关键字属性私有，其他对象无法直接访问它，必须使用类提供的接口 传递引用1private myCab： Cab Cab对象可能由另一个对象穿件，因此，将把对象引用传递到Cabbie对象。注意，目前只创建了Cab对象的一个引用，根据这个定义并没有真正分配内存。 构造函数在构造函数中初始化属性。也可以在构造函数中，将不需要赋值的属性赋值为null，那么以后再使用该类时就能检查其属性是否为null 可以传递参数给构造函数，已完成初始化属性工作。这里需要注意的是，所有的构造函数都应该定义为public ，如果是私有的构造函数，那么其他对象就不能访问他们，包括实例化对象的对象。 访问方法一个类应当很好的保护自己的属性。 静态属性如果一个属性是静态的，而且类为这个属性提供了一个设置方法，那么调用这个设置方法的任何对象都可以修改这个副本。因此，对于所有对象来来说，该属性的值都会发生改变。 公共接口方法够赞函数和访问方法都声明为公共方法，是公共接口的一部分。 私有的实现方法私有方法只是实现的一部分，不能由其他类访问。 小结没有太多的内容，主要是前几章节的一个总结。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"},{"name":"OO","slug":"OO","permalink":"https://luoyec.cn/tags/OO/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（3）","date":"2017-08-21T00:25:09.000Z","path":"2017/08/21/cjqoyqt08004vhl6pjypes8sq/","text":"高级面向对象概念本章将会介绍更高级的OO概念，如构造函数、操作符重载和多重继承，还将考虑错误处理技术，并强调面向对象设计中应用作用域的重要性。 构造函数 注意构造函数没有返回值，如果为方法提供一个返回值，编译器就不会把它作为一个构造函数 创建一个新对象时，首先要做的事情之一就是调用构造函数。 new关键字创建一个新实例，并分配所需的内存。然后构造函数被调用，传入参数列表中的参数。构造函数为开发人员提供了一个机会来完成适当的初始化。 初始化属性在结构化程序设计中，通常需要一个名为housekeeping或initialization的例程来完成初始化工作。 默认构造函数如果没有为类提供显式的构造函数，就会提供一个默认的构造函数。 这时候，默认构造函数唯一的工作就是调用父类的构造函数。会默认的插入以下默认构造函数： 1234567891011class Hero &#123; constructor() &#123; &#125;&#125;class magic extends Hero &#123; constructor() &#123; super() &#125;&#125; 一般的经验是，总应该提供一个构造函数，即使你不打算在其中做任何事情。 使用多个构造函数在TypeScript中没有这部分内容，求证实？ 重载方法重载允许程序员多次使用同一个方法名，只要每次方法的签名不同，签名由方法名和一个参数列表组成。 Java中的重载方法示例： 123public void getCab()public void getCab(int numberOfPassngers) 父类如果构造使用继承时，必须知道父类如何构造。会完成以下几个步骤： 构造函数中首先做的是调用该类的父类的构造函数，如果没有显示的调用父类的构造函数就会自动调用父类的默认构造函数。在TypeScript中也是如此。 1234567891011class Hero &#123; constructor() &#123; console.log('我是父类的构造函数') &#125;&#125;class Magic extends Hero &#123;&#125;let magic = new Magic() //log: 我是父类的构造函数 然后初始化对象的个各类属性 然后执行构造函数中其余代码 错误处理抛出异常一个try/catch块结构： 12345try &#123; //possible nasty code&#125;catch(Exception e)&#123; //code to handle the exception&#125; 如果try块中抛出了一个异常，catch块就会处理这个异常。执行try块中时如果抛出一个异常，会发生以下情况： try块的执行会终止 检查catch子句，确定对出现的异常是否班阔一个合适的catch块（每个try块可能不止有一个catch子句） 如果没有能够处理所抛出异常的catch子句，则把异常传递到下一个更高层的try块 如果某个catch子句匹配，则执行该catch子句中的语句 再从try块之后的语句继续执行 作用域的概念属性作用域、方法作用域 操作符重载即改变一个操作符的含义。 多重继承多重继承允许继承多个类。 对象操作 类和引用复杂数据结构和对象的问题在于，它们包含引用。只建立引用的一个副本并不会复制它引用的数据结构或对象。同样的，比较对象时，如果是将一个指针与另一个指针相比较，这只会比较引用，而不是它们所指的对象 深复制与浅复制深复制（deep coty）是指，沿着所有引用（指针）完成复制，从而为所引用的所有对象创建新的副本。深复制可能涉及多个层次。一个对象可能包含许多对象的引用，而所引用的这些对象可能又引用更多对象，所以复制本身可能会带来显著的开销。浅复制（shallow copy）则只是复制引用，而不沿着引用层继续向下。 小结本章主要分析了构造函数、默认构造函数、错误处理、继承、多重继承以及对象操作（深复制与浅复制）的概念。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（2）","date":"2017-08-20T23:32:21.000Z","path":"2017/08/21/cjqoyqt00004shl6povpxi9qm/","text":"如何以对象方式思考OO设计所期望的最终结果是一个健壮、功能完备的对象模型，换句话说，也就是一个完备的系统。 将会讨论以下几个问题： 了解接口和实现之间的区别 以更抽象的方式思考 尽可能为用户提供最小接口 了解接口和实现之间的区别在设计类时，必须了解用户需要知道什么以及用户不需要知道什么。 适当的构造类分为两个部分设计—-接口和实现 接口在最理想的情况下，应该只为最终用户提供他们所需要的服务。 明确用户在设计一个类时，也许最重要的就是明确类的受众或用户。 实现实现的细节对用户是隐藏的。需要记住的一个实现的目标：改变实现不需要同时改变用户的代码。 接口/实现示例根据需求提供相应的接口，例如一个简单的数据库读取器： DataBaseReader类的一个UML类图 公共接口如果一个方法是公共的，应用程序员就可以访问它，因此，它可以认为是类接口的一部分。 对象持久性是指保存对象的状态，从而可以在以后恢复并使用。没有持久存储的对象一旦出了作用域实际上就已经死亡了。例如可以把对象的状态保存在数据库中。 设计接口是使用抽象思维抽象接口通常是实现一个优秀可重用OO设计所采用的做法。 尽可能为用户提供最小接口要做到这一点，需要遵守以下规则： 只为用户提供他们确实需要的东西 最好是当用户确实需要时才增加接口，而不要为用户提供他们不需要的接口 公共接口定义用户能够访问的信息 用用户角度设计类，而不要从信息系统的角度进行设计 确保设计类时将与真正使用这个类的人（不只是开发人员）反复考虑需求和设计 小结关于OO思维过程的问题并不是固定的，采用OO方式做事与其说是一门科学不如说是一门艺术。你可以用自己的方式来描述OO思维。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"《写给大家看的面向对象编程书》总结&&实践（1）","date":"2017-08-20T15:50:04.000Z","path":"2017/08/20/cjqoyqt0s0063hl6p7r6g66fl/","text":"面向对象概念介绍过程式程序设计与OO程序设计 OO和过程式程序设计的区别在OO设计中，属性和行为都包含在一个对象中，而在过程式程序设计中，属性和行为是分开的 适当的设计可以断言，如果设计得当，OO模型中根本不会有诸如全局数据之类的东西。这一点保证了OO系统中高度的数据完整性。 对象不只是数据结构和基本数据类型，还包含方法。在一个对象中，方法用于完成数据操作和其他动作。更为重要的一点是，可以孔子对象成员（包括属性和方法）的访问。 数据隐藏在OO术语中，数据表示为属性，行为表示为方法。限制对某些属性或方法的访问称为隐藏。 对象到底是什么对象数据存储在一个对象中的数据表示对象的状态，在OO程序设计中，该数据称为属性。 对象行为对象的行为就是对象能够做什么，也就是在面对过程语言中，行为由过程、函数和子例程定义。在OO程序设计术语中，这些行为包含在方法中，要通过发送消息来调用方法。 获取方法和设置方法（set、get）获取方法和设置方法的概念支持数据隐藏的概念。因为其他对象不能直接处理另一个对象内部数据，所以获取方法和设置方法提供了对对象数据的一种可控访问。有时也被称为访问方法和修改方法。 UML类图 UML类图每个类图定义为3个不同部分：类名本身、数据（属性）和行为（方法） 创建一个对象时，称之为对象被实例化。例如这里你创了三个员工，实际上就会创建3个完全不同的Employee类实例。每个对象都包含其自己的属性和方法副本。 类到底是什么简单的说，类就是对象的一个蓝图。实例化一个对象时，就是使用一个类作为构建这个对象的基础。应该先有类，如果没有类，对象就无法实例化。 属性 访问指示当某个数据类型或者方法定义我public时，其他对象可以直接访问它。当某个数据类型或方法定义为private时，只有特定对象能够访问。还有一个访问修饰符protected，它允许相关对象访问。 方法方法实现了一个类所需的行为。从这个类实例化的各个对象都有该类所定义的方法。方法可能实现其他对象（消息）所调用的行为，或者提供这个类内部的基本行为。内部行为是不允许其他对象访问的私有方法。除非是暴露了相应的set、get方法。 消息消息是对象之家的通信机制。例如当对象A调用对象B的一个方法时，对象A就是在向对象B发送一个消息。当然，只有对象的公共方法能够被另一个对象调用。 封装和数据的隐藏使用对象的主要优点之一，就是对象不需要公开它的所有属性和行为。在好的OO设计中，对象只应该公开其他对象与之交互所必须的接口。与对象设计无关的细节应当对所有的对象隐藏。 接口接上文，接口定义了对象间通信的基本途径。每个类设计都要指定接口来正确地实现对象的实例化和操作。在大多数OO语言中，接口中的方法都指定为public 私有数据要实现数据隐藏，所有属性都应该声明为private。因此属性不是接口的一部分。只有public方法才数据类接口。将属性声明为public会破坏数据隐藏的概念。 一个简单的例子，包含了私有属性、私有方法、公共接口 1234567891011121314151617181920class IntSquare &#123; //私有属性 private squareValue: number //公共接口 public getSquare(value: number) &#123; this.squareValue = this.calculateSquare(value) return this.squareValue &#125; //私有方法 private calculateSquare(value: number) &#123; return value * value &#125;&#125;let intSquare = new IntSquare()console.log(intSquare.getSquare(10)) 继承OO程序设计中最强大的一个特性就是代码重用，你可以编写一个过程，然后根据需要使用多次。不过OO设计更近一步，允许通过组织类并抽取各个类的共性来定义类之间的关系，这不仅有利于代码重用，还可以实现更好的整体设计。 父亲类和子类父类包含继承自该类的所有子类共同的属性和方法。 抽象继承的强大之处就在于其抽象和组织技术。 在当前的多数OO语言中，一个类只能有一个父类；不过一个父类可以有多个子类。一个类只能有一个父类叫单重继承（java、.net）、一个类只能有多个父类叫多重继承（如C++） 多态字面意思是多种形状。问题引申，由于每个子类都是一个单独的实体，他们可能需要对同一个消息做出不同的响应。 多态是指类似对象可以采用不同的方式对相同的消息做出相应。 构造函数如果一个方法与所在的类同名，而且没有提供任何返回类型，这就是构造函数。可以把构造函数当做类的入口点，这里非常适合完成初始化和准备工作。 小结本章主要包含以下部分： 封装：将属性和方法封装到一个对象中 继承: 一个类可以从另一个类继承，并且可以利用父类定义的属性和方法 多态：对象可以采用不同的方式对相同的消息做出响应 组合：一个对象由其他对象构建而成 示例代码定义一个类，直接实例化或者在另一个对象中实例化 1234567891011121314151617181920212223242526272829class Person &#123; private strName: string private strAddress: string get name(): string &#123; return this.strName &#125; set name(name: string) &#123; this.strName = name &#125;&#125;class TestPerson &#123; private personq: Person = new Person() constructor() &#123; this.personq.name = 'aaa' console.log(this.personq.name) &#125;&#125;let person = new Person()person.name = 'jojo'console.log(person.name) //jojolet testPerson = new TestPerson() //aaa","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"面对对象","slug":"面对对象","permalink":"https://luoyec.cn/tags/面对对象/"}]},{"title":"mongodb二（命令行操作）","date":"2017-08-16T13:58:13.000Z","path":"2017/08/16/cjqoyqszu004ihl6pccv51h6b/","text":"MongoDB分片在MongoDB里面存在另一种集群，就是分片技术，可以满足MongoDB数据大量增长的需求。当MongoDB存储海量数据的时候，一台机器可能不足以存储数据，也不足以提供可接受的读写吞吐量。这是，我们需要通过在多台机器上分割数据，使得数据库系统能存储和处理更多数据。 为什么使用分片技术 复制所有的写入操作到主节点 延迟敏感数据会在主节点查询 单个副本集限制在12个节点 当请求量巨大时会出现内存不足 本地磁盘不足 垂直扩展价格高 MongoDB分片下图展示了在MongoDB中使用分片集群结构分布： 上图中主要有如下所述三个主要组件： Shard：用于存储实际的数据块，实际生产环境中有一个shard server角色可由几台机器组一个replica set承担，防止主机单点故障 Config Server：mongod实例，存储了整个ClusterMetadata，其中包括chunk信息 Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。 实例具体实例参考菜鸟教程 MongoDB备份（mongodump）与恢复（mongorestore）数据备份在MongoDB中我们使用mongodump命令来备份MongoDB数据，该命令可以导出所有数据到指定目录中。mongodump命令可以通过参数指定导出的数据量级转存的服务器。 语法1234&gt;mongodump -h dbhost -d dbname -o dbdirectory//-h:mongoDB所在服务器地址，如127.0.0.1，也可以指定端口号：127.0.0.1：27017 //-d:需要备份的数据库实例，例如test//-o:备份的出局存放位置，例如： c:\\data\\dump ，当然该目录需要提前建立，当备份完成后，系统会在dump目录下件一个test目录，这个目录里存放该数据库实例的备份数据 实例在当前目录下，新建终端，备份到当前目录 123456789101112131415luoyecs-iMac:~ LW-luoyec$ mongodump2017-07-26T05:11:32.736+0800 writing admin.system.version to 2017-07-26T05:11:32.739+0800 done dumping admin.system.version (1 document)2017-07-26T05:11:32.739+0800 writing test.fruits to 2017-07-26T05:11:32.739+0800 writing test.user to 2017-07-26T05:11:32.740+0800 writing test.meterial to 2017-07-26T05:11:32.740+0800 writing test.col to 2017-07-26T05:11:32.740+0800 done dumping test.user (2 documents)2017-07-26T05:11:32.740+0800 writing movie.的 to 2017-07-26T05:11:32.740+0800 done dumping test.fruits (7 documents)2017-07-26T05:11:32.740+0800 writing test.values to 2017-07-26T05:11:32.741+0800 done dumping test.meterial (1 document)2017-07-26T05:11:32.741+0800 done dumping test.col (3 documents)2017-07-26T05:11:32.741+0800 done dumping movie.的 (0 documents)2017-07-26T05:11:32.741+0800 done dumping test.values (0 documents) mongodump 命令可选参数列表如下所示： 数据恢复 mongodb使用mongorestore命令来恢复备份到数据。 语法123456789101112131415&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;/*--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！&lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。*/ 实例1&gt;mongorestore 执行以上命令输出结果如下：","categories":[{"name":"mongodb","slug":"mongodb","permalink":"https://luoyec.cn/categories/mongodb/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://luoyec.cn/tags/mongodb/"},{"name":"命令行","slug":"命令行","permalink":"https://luoyec.cn/tags/命令行/"},{"name":"增删改查","slug":"增删改查","permalink":"https://luoyec.cn/tags/增删改查/"}]},{"title":"mongodb一（命令行操作）","date":"2017-08-16T13:46:13.000Z","path":"2017/08/16/cjqoyqt6300kehl6pbbg1vmbk/","text":"参考资料：菜鸟教程 创建数据库实例use 创建数据库1234&gt; use runoob //如数据库不存则创建，否则切换到制定数据库switched to db runoob&gt; db //显示当前操作的数据库runoob show dbs 查看所有数据库 1234&gt; show dbs //如果数据库中没有数据，则不会显示出来admin 0.000GBlocal 0.000GBrunoob 0.000GB insert 插入数据 123456&gt; db.runoob.insert(&#123;\"name\":\"lyctea\"&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; show dbsadmin 0.000GBlocal 0.000GBrunoob 0.000GB 删除数据库语法删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名1db.dropDatabase() 实例删除数据库 runoob 首先，查看所有数据库： 1234&gt; show dbsadmin 0.000GBlocal 0.000GBrunoob 0.000GB 接下来我们切换到数据库 runoob： 123&gt; use runoobswitched to db runoob&gt; 执行删除命令： 12&gt; db.dropDatabase()&#123; \"dropped\" : \"runoob\", \"ok\" : 1 &#125; 最后，我们再通过 show dbs 命令数据库是否删除成功： 123&gt; show dbsadmin 0.000GBlocal 0.000GB 删除集合集合删除语法格式如下: 1db.collection.drop() //collection 是集合名 以下实例删除了 runoob 数据库中的集合 runoob： 123456&gt; show tablesrunoob&gt; db.runoob.drop()true&gt; show tables&gt; 插入文档文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON 插入文档MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下： 1db.COLLECTION_NAME.insert(document) 实例以下文档可以存储在 MongoDB 的 runoob 数据库 的 col 集合中： 123&gt; db.col.insert(&#123;title: 'MongDB master',description: 'Mongo is s Nosql database'&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;) 查看已经插入的文档，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。 12&gt; db.col.find()&#123; \"_id\" : ObjectId(\"597005c9c1f1597f764b41bb\"), \"title\" : \"MongDB master\", \"description\" : \"Mongo is s Nosql database\" &#125; 定义一个变量，插入数据库中 1234567&gt; document = &#123;title: 'is a var',description: 'use test'&#125;&#123; \"title\" : \"is a var\", \"description\" : \"use test\" &#125;&gt; db.col.insert(document)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.col.find()&#123; \"_id\" : ObjectId(\"597005c9c1f1597f764b41bb\"), \"title\" : \"MongDB master\", \"description\" : \"Mongo is s Nosql database\" &#125;&#123; \"_id\" : ObjectId(\"597006d5c1f1597f764b41bc\"), \"title\" : \"is a var\", \"description\" : \"use test\" &#125; 插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。 更新文档MongoDB 使用 update() 和 save() 方法来更新集合中的文档 update() 方法用于更新已经存在的文档 语法格式123456789db.collection.update( &lt;query&gt;, //查询条件，类似sql update查询内where后面的 &lt;update&gt;, //update对象和一些更新的操作符 &#123; upsert: &lt;boolean&gt;, //可选，如果不存在update记录，是否插入ObjNew？插入：不插入 multi: &lt;boolean&gt;, //可选，默认为false，只更新查找到的第一条记录，如果为true，则按条件查出来的记录全部更新 writeConcern: &lt;document&gt; //可选，抛出异常的级别 &#125;) 实例我们在集合 col 中插入如下数据： 1234567891011121314151617181920&gt; db.col.insert(&#123;title:'jiaocheng',class: 'yuwen'&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.col.update(&#123;title:'jiaocheng'&#125;,&#123;$set:&#123;title: 'peixun'&#125;&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)&gt; db.col.find().pretty()&#123; \"_id\" : ObjectId(\"597005c9c1f1597f764b41bb\"), \"title\" : \"MongDB master\", \"description\" : \"Mongo is s Nosql database\"&#125;&#123; \"_id\" : ObjectId(\"597006d5c1f1597f764b41bc\"), \"title\" : \"is a var\", \"description\" : \"use test\"&#125;&#123; \"_id\" : ObjectId(\"5970093bc1f1597f764b41bd\"), \"title\" : \"peixun\", \"class\" : \"yuwen\"&#125; 修改多条文档 12&gt; db.col.update(&#123;title:'jiaocheng'&#125;,&#123;$set:&#123;title:'MongoDB'&#125;&#125;,&#123;multi:true&#125;)WriteResult(&#123; \"nMatched\" : 2, \"nUpserted\" : 0, \"nModified\" : 2 &#125;) save()方法save()方法通过传入的文档来替换已有文档，语法格式如下 123456db.collection.save( &lt;document&gt;, //文档数据 &#123; writeConcern: &lt;document&gt; //可选，跑出异常级别 &#125;) 实例：以下实例中我们替换了 _id 为 597005c9c1f1597f764b41bb 的文档数据： 12345678&gt; db.col.save(&#123;_id: ObjectId('597005c9c1f1597f764b41bb'),title: 'changeById',by:'lyctea'&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)&gt; db.col.find().pretty()&#123; \"_id\" : ObjectId(\"597005c9c1f1597f764b41bb\"), \"title\" : \"changeById\", \"by\" : \"lyctea\"&#125; 更多实例123456789101112//只更新第一条记录：db.col.update( &#123; \"count\" : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125; );//全部更新：db.col.update( &#123; \"count\" : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125;,false,true );//只添加第一条：db.col.update( &#123; \"count\" : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,false );//全部添加加进去:db.col.update( &#123; \"count\" : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,true );//全部更新：db.col.update( &#123; \"count\" : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,true );//只更新第一条记录：db.col.update( &#123; \"count\" : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,false ); 删除文档MongoDB remove()函数是用来移除集合中的数据。MongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。 语法remove() 方法的基本语法格式如下所示： 1234567db.collection.remove( &lt;query&gt;, //可选，删除文档的条件 &#123; justOne: &lt;boolean&gt;, //可选，如果为true或1，则只删除一个文档 writeConcern: &lt;document&gt; //可选，抛出异常的级别 &#125;) 实例移除title 为 MongoDB的文档 123456789101112131415161718&gt; db.col.remove(&#123;title:'MongoDB'&#125;)WriteResult(&#123; \"nRemoved\" : 2 &#125;)&gt; db.col.find().pretty()&#123; \"_id\" : ObjectId(\"597005c9c1f1597f764b41bb\"), \"title\" : \"changeById\", \"by\" : \"lyctea\"&#125;&#123; \"_id\" : ObjectId(\"597006d5c1f1597f764b41bc\"), \"title\" : \"is a var\", \"description\" : \"use test\"&#125;&#123; \"_id\" : ObjectId(\"5970093bc1f1597f764b41bd\"), \"title\" : \"peixun\", \"class\" : \"yuwen\"&#125; 查询文档MongoDB 查询文档使用 find() 方法。find() 方法以非结构化的方式来显示所有文档 语法MongoDB 查询数据的语法格式如下： 12db.collection.find(query, //可选，使用查询操符制定查询条件；projection) ／／可选，使用投影操作符返回指定的健，默认省略 如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下： 1234567891011121314&gt;db.col.find().pretty() //pretty() 方法以格式化的方式来显示所有文档。&#123; \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100&#125; 除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。 MongoDB AND 条件MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。语法格式如下1&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() 实例：以下实例通过class和title健来查询数据12&gt; db.col.find(&#123;'class':'yuwen'&#125;,&#123;'title':'peixun'&#125;).pretty()&#123; \"_id\" : ObjectId(\"5970093bc1f1597f764b41bd\"), \"title\" : \"peixun\" &#125; MongoDB OR 条件MongoDB OR 条件语句使用了关键字 $or,语法格式如下：1234567&gt;db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 实例以下实例通过class或者title健来查询数据123456&gt; db.col.find(&#123;$or:[&#123;'class':'yuwen'&#125;,&#123;'title':'peixun'&#125;]&#125;).pretty()&#123; \"_id\" : ObjectId(\"5970093bc1f1597f764b41bd\"), \"title\" : \"peixun\", \"class\" : \"yuwen\"&#125; AND 和 OR 联合使用联合条件查询，查询likes大于50，并class为语文或者title为peixun的文档 (&gt;50&amp;&amp;(class==yuwen || title==peixun)) 1234567&gt; db.col.find(&#123;'likes':&#123;$gt:50&#125;,$or:[&#123;'class':'yuwen'&#125;,&#123;'title':'peixun'&#125;]&#125;).pretty()&#123; \"_id\" : ObjectId(\"5970093bc1f1597f764b41bd\"), \"title\" : \"peixun\", \"class\" : \"yuwen\", \"likes\" : 80&#125; MongoDB条件操作符描述条件操作符，用于比较两个表达式并从mongoDB集合中获取数据MongoDB中条件操作符有：1234&gt; -$gt 大于&lt; -$lt 小于&gt;= -$gte 大于等于&lt;= -$lte 小于等于 清空集合的数据12&gt; db.col.remove(&#123;&#125;)WriteResult(&#123; \"nRemoved\" : 3 &#125;) 插入以下数据1234567891011121314151617181920212223242526&gt; db.col.insert(&#123;... title: 'PHP 教程', ... description: 'PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。',... by: '菜鸟教程',... url: 'http://www.runoob.com',... tags: ['php'],... likes: 200... &#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.col.insert(&#123;title: 'Java 教程', ... description: 'Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。',... by: '菜鸟教程',... url: 'http://www.runoob.com',... tags: ['java'],... likes: 150... &#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.col.insert(&#123;title: 'MongoDB 教程', ... description: 'MongoDB 是一个 Nosql 数据库',... by: '菜鸟教程',... url: 'http://www.runoob.com',... tags: ['mongodb'],... likes: 100... &#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;) mongoBD (&gt;)操作符 -$gt获取col集合中，likes大于100的数据，你可以使用一下命令123&gt; db.col.find(&#123;likes: &#123;$gt: 100&#125;&#125;)&#123; \"_id\" : ObjectId(\"597197fa6d266472131059b0\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 &#125;&#123; \"_id\" : ObjectId(\"597198106d266472131059b1\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 &#125; mongoDB (&gt;=)操作符 -$gte获取col集合中，likes大于等于100的数据1&gt; db.col.find(&#123;likes: &#123;$gte: 100&#125;&#125;) mongoDB (&lt;)小于操作符 -$lt1&gt;db.col.find(&#123;likes: &#123;$lt: 100&#125;&#125;) mongoDB (&lt;=)小于等于操作符 -$lte1&gt; db.col.find(&#123;likes: &#123;$lte: 100&#125;&#125;) 同时使用大于和小于条件查询语句12&gt; db.col.find(&#123;likes: &#123;$lt: 200, $gt: 100&#125;&#125;)&#123; \"_id\" : ObjectId(\"597198106d266472131059b1\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 &#125; MongoDB $type操作符$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果MongoDB中可以是使用的类型如下： 实例获取col集合中title为String的数据，可以使用以下命令, type的健值对对照上图 1234 &gt; db.col.find(&#123;title: &#123;$type: 2&#125;&#125;)&#123; \"_id\" : ObjectId(\"59719c336d266472131059b3\"), \"title\" : \"PHP 教程\", \"description\" : \"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"php\" ], \"likes\" : 200 &#125;&#123; \"_id\" : ObjectId(\"59719c386d266472131059b4\"), \"title\" : \"Java 教程\", \"description\" : \"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"java\" ], \"likes\" : 150 &#125;&#123; \"_id\" : ObjectId(\"59719c416d266472131059b5\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 &#125; MongoDB Limit与Skip方法如果需要在MongoDB中，读取指定数量的数据记录，可以使用MongoDB的Limit方法，该方法接受一个参数，该参数指定从MongoDB中读取的记录条数 Limit语法1&gt;db.COLLECTION_NAME.find().limit(NUMBER) 实例1234567&gt; db.col.find(&#123;&#125;,&#123;title:1, _id:0&#125;).limit(2)&#123; \"title\" : \"PHP 教程\" &#125;&#123; \"title\" : \"Java 教程\" &#125;&gt; db.col.find(&#123;&#125;,&#123;title:1, _id:0&#125;)&#123; \"title\" : \"PHP 教程\" &#125;&#123; \"title\" : \"Java 教程\" &#125;&#123; \"title\" : \"MongoDB 教程\" &#125; Skip语法1&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 实例以下实例之后显示第二条文档数据12&gt; db.col.find(&#123;&#125;,&#123;title:1,_id:0&#125;).limit(1).skip(1)&#123; \"title\" : \"Java 教程\" &#125; MongoDB排序语法1&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) 实例col集合按照likes的降序排列 1234&gt; db.col.find(&#123;&#125;,&#123;title:1,_id:0&#125;).sort(&#123;likes: -1&#125;)&#123; \"title\" : \"PHP 教程\" &#125;&#123; \"title\" : \"Java 教程\" &#125;&#123; \"title\" : \"MongoDB 教程\" &#125; MongoDB 索引索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。 ensureIndex()方法创建索引MongoDB使用 ensureIndex() 方法来创建索引。 语法1&gt;db.COLLECTION_NAME.ensureIndex(&#123;KEY:1&#125;) 实例ensureIndex()title升序创建索引，降序则为-11234567&gt; db.col.ensureIndex(&#123;title:1&#125;)&#123; \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1&#125; 也可以使用多个字段来创建索引 12345678&gt; db.col.ensureIndex(&#123;title: 1, description: -1&#125;)&#123; \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 3, \"numIndexesAfter\" : 3, \"note\" : \"all indexes already exist\", \"ok\" : 1&#125; ensureIndex() 接收可选参数，可选参数列表如下： 实例： 1234567&gt; db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)&#123; \"createdCollectionAutomatically\" : true, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1&#125; MongoDB聚合MongoDB中聚合（aggregate）主要用于处理数据（统计平均值，求和），并返回计算后的数据结果。 aggregate()方法语法1&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 实例计算集合中，每个title的数量1234&gt; db.col.aggregate([&#123;$group: &#123;_id: '$title', total: &#123;$sum: 1&#125;&#125;&#125;])&#123; \"_id\" : \"MongoDB 教程\", \"total\" : 1 &#125;&#123; \"_id\" : \"Java 教程\", \"total\" : 1 &#125;&#123; \"_id\" : \"PHP 教程\", \"total\" : 1 &#125; 常用的聚合表达式 123456789表达式 描述 实例$sum 计算总和。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", num_tutorial : &#123;$sum : \"$likes\"&#125;&#125;&#125;])$avg 计算平均值 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", num_tutorial : &#123;$avg : \"$likes\"&#125;&#125;&#125;])$min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", num_tutorial : &#123;$min : \"$likes\"&#125;&#125;&#125;])$max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", num_tutorial : &#123;$max : \"$likes\"&#125;&#125;&#125;])$push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", url : &#123;$push: \"$url\"&#125;&#125;&#125;])$addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", url : &#123;$addToSet : \"$url\"&#125;&#125;&#125;])$first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", first_url : &#123;$first : \"$url\"&#125;&#125;&#125;])$last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([&#123;$group : &#123;_id : \"$by_user\", last_url : &#123;$last : \"$url\"&#125;&#125;&#125;]) 管道的概念管道在Unix和Linux中一般用于当前命令的输出结果作为下个命令的参数MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理，管道操作可以重复表达式：处理输入文档并输出，表达式是无状态的，只能用于计算当前聚合管道中的文档，不能处理其他文档聚合框架中常用的几个操作： 12345678$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。$limit：用来限制MongoDB聚合管道返回的文档数。$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。$group：将集合中的文档分组，可用于统计结果。$sort：将输入文档排序后输出。$geoNear：输出接近某一地理位置的有序文档。 管道操作实例查询结果，只包含title和rul字段，1 表示包含，0表示不包含1234&gt; db.col.aggregate(&#123;$project: &#123;title:1,url:1,_id: 0&#125;&#125;)&#123; \"title\" : \"PHP 教程\", \"url\" : \"http://www.runoob.com\" &#125;&#123; \"title\" : \"Java 教程\", \"url\" : \"http://www.runoob.com\" &#125;&#123; \"title\" : \"MongoDB 教程\", \"url\" : \"http://www.runoob.com\" &#125; $match用于获取likes大于100的记录，然后将符合条件的记录送到一下阶段$group管道操作进行处理12&gt; db.col.aggregate([&#123;$match: &#123;likes: &#123;$gt: 100&#125;&#125;&#125;,&#123;$group:&#123;_id: null,title: &#123;$sum: 1&#125;&#125;&#125;])&#123; \"_id\" : null, \"title\" : 2 &#125; 经过$skip管道符处理后，前两个文档被过滤掉了 12&gt; db.col.aggregate(&#123;$skip: 2&#125;)&#123; \"_id\" : ObjectId(\"59719c416d266472131059b5\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\" ], \"likes\" : 100 &#125; MongoDB复制（副本集）MongoDB复制是将数据同步在多个服务器的过程。复制提供了数据的冗余备份，并在多个服务器上存储副本，提高了数据的可用性，并可以保证数据安全。复制还可以允许从硬件故障和服务终端中恢复数据。 什么是复制 保障数据的安全性 提高数据可用性 灾难恢复 无需停机维护（如备份，重建索引，压缩） 分布式读取数据 MongoDB复制原理mongodb的复制至少需要两个节点。其中一个是主节点，复制处理客户端请求，其余的都是从节点，负责复制主节点上的数据。mongoDB个节点常见搭配方式为： 一主一从，一主多从。主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取的这些操作，然后对自己的数据副本执行这些操作，从而保证节点的数据与主节点一致MongoDB复制结构图如下： 以上结构图总，客户端总主节点读取数据，在客户端写入数据到主节点是， 主节点与从节点进行数据交互保障数据的一致性。 副本集特性 N 个节点的集群 任何节点可作为主节点 所有写入操作都在主节点上 自动故障转移 自动恢复 MongoDB副本设置在教程中使用同一个MongoDB来做MongoDB的主从实验，步骤： 关闭正在运行的Mongo服务器现在我们通过指定 –replSet 选项来启动mongoDB。–replSet 基本语法格式如下： 1mongod --port \"PORT\" --dbpath \"YOUR_DB_DATA_PATH\" --replSet \"REPLICA_SET_INSTANCE_NAME\" 实例1mongod --port 27017 --dbpath \"D:\\set up\\mongodb\\data\" --replSet rs0 以上实例会启动一个名为rs0的MongoDB实例，其端口号为27017。启动后打开命令提示框并连接上mongoDB服务。在Mongo客户端使用命令rs.initiate()来启动一个新的副本集。我们可以使用rs.conf()来查看副本集的配置查看副本集状态使用 rs.status() 命令 副本集添加成员添加副本集的成员，我们需要使用多条服务器来启动mongo服务。进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。语法rs.add() 命令基本语法格式如下： 1&gt;rs.add(HOST_NAME:PORT) 实例假设你已经启动了一个名为mongod1.net，端口号为27017的Mongo服务。 在客户端命令窗口使用rs.add() 命令将其添加到副本集中，命令如下所示： 1&gt;rs.add(\"mongod1.net:27017\") MongoDB中你只能通过主节点将Mongo服务添加到副本集中， 判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster() 。MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。","categories":[{"name":"mongodb","slug":"mongodb","permalink":"https://luoyec.cn/categories/mongodb/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://luoyec.cn/tags/mongodb/"},{"name":"命令行","slug":"命令行","permalink":"https://luoyec.cn/tags/命令行/"},{"name":"增删改查","slug":"增删改查","permalink":"https://luoyec.cn/tags/增删改查/"}]},{"title":"安卓App内嵌Egret","date":"2017-08-16T13:40:34.000Z","path":"2017/08/16/cjqoyqt0x006hhl6pjvcvhfjm/","text":"参考资源:webview与js交互 简书 安卓混合开发——原生Java和H5交互，保证你一看就懂！ webview与js交互什么是webview webview介绍的原文如下：A View that displays web pages. This class is the basis upon which you can roll your own web browser or simply display some online content within your Activity. It uses the WebKit rendering engine to display web pages and includes methods to navigate forward and backward through a history, zoom in and out, perform text searches and more. 一个用于显示web 页面的view容器, 你可以滚动web浏览器或者只是简单的显示网络上的内容. 他使用Webkit 引擎去渲染页面可以拥有前进后退的导航, 放大或者缩小. 可以实现和js的交互 webview能做什么 webView可以利用html做界面布局，虽然目前还比较少人这么使用，不过我相信当一些客户端需要复杂的图文（图文都是动态生成）混排的时候它肯定是个不错的选择。 直接显示网页，这功能当然也是它最基本的功能。 和js交互。（如果你的js基础比java基础好的话那么采用这种方式做一些复杂的处理是个不错的选择）。 如何使用 WebViewDemo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.google.android.webviewdemo;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.util.Log;import android.webkit.JsResult;import android.webkit.WebChromeClient;import android.webkit.WebSettings;import android.webkit.WebView;/*** Demonstrates how to embed a WebView in your activity. Also demonstrates how * to have javascript in the WebView call into the activity, and how the activity * can invoke javascript. * * In this example, clicking on the android in the WebView will result in a call into * the activities code in &#123;@link DemoJavaScriptInterface#clickOnAndroid()&#125;. This code * will turn around and invoke javascript using the &#123;@linkWebView#loadUrl(String)&#125; * method. * * Obviously all of this could have been accomplished without calling into the activity * and then back into javascript, but this code is intended to show how to set up the * code paths for this sort of communication. **/public class WebViewDemo extends Activity &#123; private static final String LOG_TAG = \"WebViewDemo\"; private WebView mWebView; private Handler mHandler = new Handler(); @Override public void onCreate(Bundle icicle) &#123; super.onCreate(icicle); setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); WebSettings webSettings = mWebView.getSettings(); webSettings.setSavePassword(false); webSettings.setSaveFormData(false); webSettings.setJavaScriptEnabled(true); webSettings.setSupportZoom(false); mWebView.setWebChromeClient(new MyWebChromeClient()); mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), \"demo\"); mWebView.loadUrl(\"file:///android_asset/demo.html\"); &#125; final class DemoJavaScriptInterface &#123; DemoJavaScriptInterface() &#123; &#125; /** * This is not called on the UI thread. Post a runnable to invoke * loadUrl on the UI thread. */ public void clickOnAndroid() &#123; mHandler.post(new Runnable() &#123; public void run() &#123; mWebView.loadUrl(\"javascript:wave()\"); &#125; &#125;); &#125; &#125; /** * Provides a hook for calling \"alert\" from javascript. Useful for * debugging your javascript. */ final class MyWebChromeClient extends WebChromeClient &#123; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; Log.d(LOG_TAG, message); result.confirm(); return true; &#125; &#125;&#125; demo.html 123456789101112131415161718192021&lt;html&gt; &lt;script language=\"javascript\"&gt; /* This function is invoked by the activity */ function wave() &#123; alert(\"1\"); document.getElementById(\"droid\").src=\"android_waving.png\"; alert(\"2\"); &#125; &lt;/script&gt; &lt;body&gt; &lt;!-- Calls into the javascript interface for the activity --&gt; &lt;a onClick=\"window.demo.clickOnAndroid()\"&gt;&lt;div style=\"width:80px; margin:0px auto; padding:10px; text-align:center; border:2px solid #202020;\" &gt; &lt;img id=\"droid\" src=\"android_normal.png\"/&gt;&lt;br&gt; Click me! &lt;/div&gt;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; main.xml 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" &gt; &lt;TextView android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/intro\" android:padding=\"4dip\" android:textSize=\"16sp\" /&gt; &lt;WebView android:id=\"@+id/webview\" android:layout_width=\"fill_parent\" android:layout_height=\"0dip\" android:layout_weight=\"1\" /&gt; &lt;/LinearLayout&gt; 如何交互android如果调用js 调用形式: 1mWebView.loadUrl(\"javascript:wave()\"); 其中wave（）是js中的一个方法，当然你可以把这个方法改成其他的方法，也就是android调用其他的方法。 js调用android调用形式: 1&lt;a onClick=\"window.demo.clickOnAndroid()\"&gt; 代码中的“demo”是在android中指定的调用名称，即 1mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), \"demo\") 代码中的clickOnAndroid()是“demo”对应的对象：new DemoJavaScriptInterface() 中的一个方法。 Demo现在你一定了解了android和js的交互了。是时候分析一些demo了，根据上面讲的你也应该比较清楚了。具体交互流程如下： ①点击图片，则在js端直接调用android上的方法clickOnAndroid()； ②clickOnAndroid()方法（利用线程）调用js的方法。 ③被②调用的js直接控制html。 个人总结：利用webView的这种方式在有些时候UI布局就可以转成相应的html代码编写了，而html布局样式之类有DW这样强大的工具，而且网上很多源码，很多代码片。在UI和视觉效果上就会节省很多时间，重复发明轮子没有任何意义。","categories":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/categories/Egret/"}],"tags":[{"name":"内嵌App","slug":"内嵌App","permalink":"https://luoyec.cn/tags/内嵌App/"},{"name":"webview","slug":"webview","permalink":"https://luoyec.cn/tags/webview/"},{"name":"js交互","slug":"js交互","permalink":"https://luoyec.cn/tags/js交互/"}]},{"title":"Egret HTTP简单请求","date":"2017-08-16T03:49:36.000Z","path":"2017/08/16/cjqoyqsxl000bhl6pile7d1fz/","text":"在游戏使用的网络请求，http协议，常用的get、post方法实例 参考官方文档 GET方法 新建请求对象，设置参数，请求方法，注册监听事件 1234567891011let params = `?gameId=$&#123;userAccountInfo.gameId&#125;&amp;accesstoken=$&#123;userAccountInfo.token&#125;&amp;userId=$&#123;userAccountInfo.userId&#125;`let request = new egret.HttpRequest()let url = `$&#123;SoloGame.baseURL&#125;gameRanking.do$&#123;params&#125;`request.open(`http://$&#123;SoloGame.baseURL&#125;userCenter.do$&#123;params&#125;`, egret.HttpMethod.GET)request.send()request.addEventListener(egret.Event.COMPLETE, this.onGetUserInfoComplete, this)request.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onGetUserInfoError, this)request.addEventListener(egret.ProgressEvent.PROGRESS, this.onGetUserInfoProgress, this) 监听请求状态，成功、失败、进度 123456789101112131415private onGetUserInfoComplete(event: egret.Event): void &#123; var request = &lt;egret.HttpRequest&gt;event.currentTarget let result = JSON.parse(request.response) if (result.status == 200) &#123; //TODO &#125;&#125;private onGetUserInfoError(event: egret.IOErrorEvent): void &#123; console.log(\"get error : \" + event);&#125;private onGetUserInfoProgress(event: egret.ProgressEvent): void &#123; console.log(\"get progress : \" + Math.floor(100 * event.bytesLoaded / event.bytesTotal) + \"%\");&#125; POST方法12345678910111213let params = `gameId=$&#123;userAccountInfo.gameId&#125;&amp;accesstoken=$&#123;userAccountInfo.token&#125;&amp;userId=$&#123;userAccountInfo.userId&#125;&amp;isSlot=1&amp;wealth=$&#123;spinCoins&#125;`let request = new egret.HttpRequest()let url = SoloGame.SPINREQUESTrequest.open(`http://$&#123;url&#125;`, egret.HttpMethod.POST)request.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")request.send(params)request.addEventListener(egret.Event.COMPLETE, this.onSpinGetComplete, this)request.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onSpinGetIOError, this)request.addEventListener(egret.ProgressEvent.PROGRESS, this.onSpinGetProgress, this) 1234567891011121314151617private onSpinGetComplete(event: egret.Event): void &#123; var request = &lt;egret.HttpRequest&gt;event.currentTarget let result = JSON.parse(request.response) if (result.status == 200) &#123; //TODO &#125; else &#123; SoloGame.SPINRESULT = '' &#125;&#125;private onSpinGetIOError(event: egret.IOErrorEvent): void &#123; console.log(\"get error : \" + event);&#125;private onSpinGetProgress(event: egret.ProgressEvent): void &#123; console.log(\"get progress : \" + Math.floor(100 * event.bytesLoaded / event.bytesTotal) + \"%\");&#125;","categories":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/categories/Egret/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://luoyec.cn/tags/HTTP/"},{"name":"网络请求","slug":"网络请求","permalink":"https://luoyec.cn/tags/网络请求/"},{"name":"GET","slug":"GET","permalink":"https://luoyec.cn/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://luoyec.cn/tags/POST/"}]},{"title":"Egret Loading 页面实现方法","date":"2017-08-16T03:29:48.000Z","path":"2017/08/16/cjqoyqsxn000ehl6p2x2avy47/","text":"实现Loading页面的方法有好多，这里的方法是，使用EUI皮肤的加载页，可配置型和可定制型程度更高，也更易用。但不是最好的方法。 资源的处理加载页的UI资源是限于preload组资源加载的，所以这两个资源组需要分开处理。加载完并处理相关动画之后才开始加载preload资源组。 资源分组将loading页面需要用到的资源分一个loading资源组出来。 修改main.js 调整资源加载顺序 main.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class Main extends eui.UILayer &#123; /** * 加载进度界面 * loading process interface */ private loadingView: LoadingUI; protected createChildren(): void &#123; super.createChildren(); //inject the custom material parser //注入自定义的素材解析器 let assetAdapter = new AssetAdapter(); egret.registerImplementation(\"eui.IAssetAdapter\", assetAdapter); egret.registerImplementation(\"eui.IThemeAdapter\", new ThemeAdapter()); //初始化Resource资源加载库 RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this); RES.loadConfig(\"resource/default.res.json\", \"resource/\"); &#125; /** * 配置文件加载完成,开始预加载皮肤主题资源和preload资源组。 * Loading of configuration file is complete, start to pre-load the theme configuration file and the preload resource group */ private onConfigComplete(event: RES.ResourceEvent): void &#123; RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this); // load skin theme configuration file, you can manually modify the file. And replace the default skin. //加载皮肤主题配置文件,可以手动修改这个文件。替换默认皮肤。 let theme = new eui.Theme(\"resource/default.thm.json\", this.stage); theme.addEventListener(eui.UIEvent.COMPLETE, this.onThemeLoadComplete, this); RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this); RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, this.onResourceLoadError, this); RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this); RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, this.onItemLoadError, this); RES.loadGroup(\"loading\"); &#125; private isThemeLoadEnd: boolean = false; /** * 主题文件加载完成,开始预加载 * Loading of theme configuration file is complete, start to pre-load the */ private onThemeLoadComplete(): void &#123; this.isThemeLoadEnd = true; this.createScene(); &#125; private isResourceLoadEnd: boolean = false; /** * preload资源组加载完成 * preload resource group is loaded */ private onResourceLoadComplete(event: RES.ResourceEvent): void &#123; if (event.groupName == 'loading') &#123; //设置加载进度界面 this.loadingView = new LoadingUI(); this.stage.addChild(this.loadingView); &#125; if (event.groupName == \"preload\") &#123; this.stage.removeChild(this.loadingView); RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this); RES.removeEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, this.onResourceLoadError, this); RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this); RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, this.onItemLoadError, this); this.isResourceLoadEnd = true; this.createScene(); //调用安卓接口，获取用户信息 let userInfo = window.JsAndroidWebView.sendInfoToJs() sessionStorage.setItem('androidUserInfo', userInfo) &#125; &#125; private createScene() &#123; if (this.isThemeLoadEnd &amp;&amp; this.isResourceLoadEnd) &#123; this.startCreateScene(); &#125; &#125; /** * 资源组加载出错 * The resource group loading failed */ private onItemLoadError(event: RES.ResourceEvent): void &#123; console.warn(\"Url:\" + event.resItem.url + \" has failed to load\"); &#125; /** * 资源组加载出错 * Resource group loading failed */ private onResourceLoadError(event: RES.ResourceEvent): void &#123; //TODO console.warn(\"Group:\" + event.groupName + \" has failed to load\"); //忽略加载失败的项目 //ignore loading failed projects this.onResourceLoadComplete(event); &#125; /** * preload资源组加载进度 * loading process of preload resource */ private onResourceProgress(event: RES.ResourceEvent): void &#123; if (event.groupName == \"preload\") &#123; this.loadingView.setProgress(event.itemsLoaded, event.itemsTotal); &#125; &#125; private textfield: egret.TextField; /** * 创建场景界面 * Create scene interface */ protected startCreateScene(): void &#123; this.addChild(new GameScene()) &#125;&#125; Loading页LoadingUISkin.exml 皮肤给一个蓝色的矩形背景。 包含用于显示进度条的外框以及一小段进度条。 并且在代码中，添加一个序列帧动画到当前皮肤中。 LoadingUI.ts添加到动画帧到舞台中，在每一次的资源数回调函数中，播放动画，实现每次加载一个资源，人物的脚步开始运动。 1234567891011121314151617181920212223242526272829303132333435class LoadingUI extends eui.Component &#123; private solomc: egret.MovieClip public constructor() &#123; super(); this.once(eui.UIEvent.COMPLETE, this.uiComplete,this) this.skinName = 'src/LoadingUISkin.exml' &#125; private uiComplete(e:eui.UIEvent)&#123; this.initMC() RES.loadGroup(\"preload\") &#125; private initMC(): void &#123; let data = RES.getRes('solo_loading_json') let txtr = RES.getRes('solo_loading_png') let mcFactory: egret.MovieClipDataFactory = new egret.MovieClipDataFactory(data, txtr) this.solomc = new egret.MovieClip(mcFactory.generateMovieClipData('loading')) this.solomc.x = 220 this.solomc.y = 500 this.addChild(this.solomc) &#125; private loadingLabel: eui.Label private loadingBorder: eui.Image private loadingPer: eui.Image public setProgress(current: number, total: number): void &#123; this.solomc.gotoAndPlay('moving', 1) let percentage: string = (current / total * 100).toFixed(0).toString() this.loadingLabel.text = `$&#123;percentage&#125;` this.loadingPer.width = (this.loadingBorder.width - 6) * parseFloat(percentage) / 100 &#125;&#125; 最后效果","categories":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/categories/Egret/"}],"tags":[{"name":"Egret","slug":"Egret","permalink":"https://luoyec.cn/tags/Egret/"},{"name":"加载页","slug":"加载页","permalink":"https://luoyec.cn/tags/加载页/"},{"name":"序列帧动画","slug":"序列帧动画","permalink":"https://luoyec.cn/tags/序列帧动画/"}]},{"title":"数组、栈、队列","date":"2017-08-12T09:48:42.000Z","path":"2017/08/12/cjqoyqt170071hl6piiyfd5uv/","text":"数组数组的创建与初始化 new关键字 12var color = new Array()var colors = new Array('red','yellow','blue') 数组字面量 12var color = []var colors = ['red','yellow','blue'] 检测数组检测某个对象是不是数组 ES3中的方法123if（value instanceof Array）&#123; //如果是数组，执行某些操作&#125; 如果页面中包含多个框架，那实际上就存在两个以上的不同全局执行环境，从而存在两个以上的不同版本的Array构造函数。 ES5中的方法，也是现在使用的方法兼容性： IE9+ 123if (Array.isArray(value) &#123; //对数组执行某些操作&#125;) 转换方法12345toString(): 返回数组中每个值的字符串形式拼接而成的一个以逗号隔开的字符串。valueOf()：返回的仍然是数组toLocaleString(): 在大多数情况与前两者相同，不同之初是调用数组中每一项的toLocaleString（），而不是toString（）方法。 添加和删除元素通过下标直接赋值:12var numbers = [1,2,3,4,5]numbers[5] = 6 栈方法123push() //可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度pop() //从数组 末尾移除最后一项 队列方法12345shift() //移除数组中的第一个项并返回，同时数组长度减一push() //向数组末端添加元素unshift() //在数组前端任意项并返回新数组的长度 操作方法concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 12var hello = \"Hello, \";console.log(hello.concat(\"Kevin\", \" have a nice day.\")); /* Hello, Kevin have a nice day. */ slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。 splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容 返回值: 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组 123456789var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];myFish.splice(2, 0, 'drum'); // 在索引为2的位置插入'drum'// myFish 变为 [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"]myFish.splice(2, 1); // 从索引为2的位置删除一项（也就是'drum'这一项）// myFish 变为 [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"] 位置方法indexOf() 方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 12345678910let a = [2, 9, 7, 8, 9]; a.indexOf(2); // 0 a.indexOf(6); // -1a.indexOf(7); // 2a.indexOf(8); // 3a.indexOf(9); // 1if (a.indexOf(3) === -1) &#123; // element doesn't exist in array&#125; lastIndexOf() 方法lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 参数 描述searchvalue 必需。规定需检索的字符串值。fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。 123var numbers = [2, 5, 9, 2];numbers.lastIndexOf(2); // 3numbers.lastIndexOf(7); // -1 迭代方法every()对数组中的每一项运行给定函数，如果函数对每一项都返回true，则返回true filter()对数组中的每一项运行给定函数，返回给函数会返回true的数组 forEach()对数组中的每一项运行给定函数。这个方法没有返回值 map()对数组中的每一项运行给定函数，返回每次函数调用返回结果组成的数组。 some()对数组中的每一项运行给定函数，如果任一个函数返回true，则返回true 归并方法reduce从数组第一项开始，逐个遍历到最后。 123456789var total = [0, 1, 2, 3].reduce(function(sum, value) &#123; return sum + value;&#125;, 0);// total is 6var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;, []);// flattened is [0, 1, 2, 3, 4, 5] reduceRight（）则从数组的最后一项开始，向前遍历到第一项。 栈栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待添加的元素都保存在栈的末尾，称作栈顶，另一端叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Stack() &#123; var items = [] this.push = function (element) &#123; items.push(element) &#125; this.pop = function () &#123; items.pop() &#125; this.peek = function () &#123; return items[items.length - 1] &#125; this.isEmpty = function () &#123; return items.length == 0 &#125; this.size = function () &#123; return items.length &#125; this.print = function () &#123; console.log(items.toString()) &#125;&#125;var stack = new Stack()console.log(stack.isEmpty())stack.push(3)stack.push(6)stack.push(8)stack.print()console.log(stack.peek())/*luoyecs-iMac:js数据结构与算法 LW-luoyec$ node stack.jstrue3,6,88*/ 队列队列是遵循FIFO（先进先出，也成为先来先服务）原则的一组有序的项。队列的尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function Queue () &#123; var items = [] this.enqueue = function (element) &#123; items.push(element) &#125; this.dequeue = function () &#123; items.shift() &#125; this.front = function () &#123; return items[0] &#125; this.isEmpty = function () &#123; return items.length == 0 &#125; this.clear = function() &#123; items = [] &#125; this.size = function () &#123; return items.length &#125; this.print = function () &#123; console.log(items.toString()) &#125;&#125;var queue = new Queue()console.log(queue.isEmpty())queue.enqueue(1)queue.enqueue(2)queue.enqueue(3)queue.print()queue.dequeue()queue.print()","categories":[{"name":"JS数据结构与算法","slug":"JS数据结构与算法","permalink":"https://luoyec.cn/categories/JS数据结构与算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyec.cn/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyec.cn/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://luoyec.cn/tags/算法/"}]},{"title":"代码整洁之道四:注释","date":"2017-08-11T17:06:29.000Z","path":"2017/08/12/cjqoyqt0o005shl6piig9xmv7/","text":"对注释的态度注释的恰当用法是弥补我们在用代码表达意图是遭遇的失败。 程序员应当复杂将注释保持咋可维护、有关联、精确的高度。我同意这种说法，但我更主张把力气用在写清楚代码上，直接保证无须编写注释。 只是只在移除地方有：代码。只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。所以，尽管有时也需要注释，我们也应该花心思尽量减少注释量。 注释不能美化糟糕的代码与其花时间编写糟糕代码的注释，不如花时间清洁那堆糟糕的代码。 用代码来阐述很多时间，简单到只需要创建一个描述与注释所表达的同一意思的函数即可。 用更好的函数名代替注释 好注释 唯一真正好的注释是你想办法不去写的注释。 法律信息 每隔源文件开头放置的标准注释 这类注释不应是合同或法典，如有可能，就指向一份标准许可或外部文件。 提供信息的注释 有时，利用注释来提供基本信息，例如解释在某个抽象方法中返回值 但是把函数重新命名为responderBeingTested, 注释就是多余的了。 对意图的解释 注释不仅提供有关实现的有用信息，而且还可以提供某个决定后面的意图。即在注释中告诉别人你的想法。 阐释 用注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读形式，会是有用的。不过，通常更好的方法是尽量让参数或返回值自身就足够清除。 当然要注意的是，要确认注释的正确性。 警示 用于警告其他程序员会出现某种后果的注释。 TODO注释 TODO是一种程序员认为应该做，但由于某些原因还没做的工作。他可能是要提醒删除某个不必要的特性，或者要求他人注意某个问题。 IDE都提供了TODO注释的定位及高亮功能，定期查看，删除不在需要的注释。 放大 用注释强调某件事的重要性 公共API中的文档注释 如果在编写公共API，就应该编写良好的文档 坏注释 大多数注释都属于此类，通常坏注释都是糟糕代码的支撑或接口，或者对错误决策的修正。基本上等于程序员自说自话。 喃喃自语如果只是因为你觉得应该或者因为过程需要添加注释，那就是无谓之举。如果你决定写注释，就必须花时间写好注释。 多余的注释这种注释并不能比代码本身提供更多信息，它没能证明代码的意义，也没能给出代码的意图或逻辑。 多余的注释： 误导性注释 避免描述不够准确、歧义、误导性的注释，如果连你自己都没搞懂注释的意义，为什么期待别人能懂呢？ 循规式注释 每隔函数都要有说明或者每个变量都要有注释。这类注释徒然让代码变得散乱，满口胡言，令人迷糊不解。 日志式注释废话注释 用整理代码的决心替代创造废话的冲动吧。你会发现自己成为更优秀、更快乐的程序员。 可怕的废话能用函数或者变量就别用注释 括号后的注释 尽管这对于含有深度嵌套结构函数可能有意义，但只会给我们更愿意编写短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的事缩短函数。 注释掉的代码 别这么干，直接注释代码，会让你的同事怀疑这代码到底有什么用，造成混乱。 非本地信息 假如你一定要写注释，请确保描述了离它最近的代码。 信息过多 别在注释中添加历史性话题、或者无关的细节描述。 不明显的联系 注释及其描述代码之间的联系应该显而易见。 范例 作者的另一本书《敏捷软件开发：原则、模式与实践》","categories":[{"name":"代码整洁之道","slug":"代码整洁之道","permalink":"https://luoyec.cn/categories/代码整洁之道/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://luoyec.cn/tags/代码整洁/"},{"name":"提高","slug":"提高","permalink":"https://luoyec.cn/tags/提高/"}]},{"title":"Git 工作流指南（总结&&实践）","date":"2017-08-10T15:18:21.000Z","path":"2017/08/10/cjqoyqt6g00kphl6pdtoiqtyr/","text":"译序 操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。 工作流其实不是一个初级主题，背后的本质问题其实是 有效的项目流程管理 和高效的开发协同约定，而不仅是Git或SVN等VCS或SCM工具的使用。 关于Git工作流主题，网上体系的中文资料不多，主要是零散的操作说明，希望这篇文章能让你更深入理解并在工作中灵活有效地使用起来。 Gitflow工作流是经典模型，处于核心位置，体现了工作流的经验和精髓。随着项目过程复杂化，你会感受到这个工作流中的深思熟虑和威力！ 工作流指南 工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览公司团队中最常用的几种Git工作流让大家可以上手使用。 集中式工作流 但使用Git加强开发的工作流，Git有相比SVN的几个优势。 首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分修改独立开来 —— 即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。 其次，Git提供了强壮的分支和合并模型。不像SVN，Git的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。 工作方式 本工作流只用到master这一个分支。 开发者开始先克隆中央仓库。在自己的项目拷贝中像SVN一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。 要发布修改到正式项目中，开发者要把本地master分支的修改『推』到中央仓库中。这相当于svn commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。 冲突解决 如果开发者本地的提交历史和中央仓库有分歧，Git会拒绝push提交，防止覆盖中央仓库的正式提交 在开发者提交自己功能修改到中央库前，需要先fetch在中央库的新增提交，rebase自己提交到中央库提交历史之上。 这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的SVN的工作流中一样。 如果本地修改和上游提交有冲突，Git会暂停rebase过程，给你手动解决冲突的机会。Git解决合并冲突，用和生成提交一样的git status和git add命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，Git可以很简单中止整个rebase操作，重来一次（或者让别人来帮助解决）。 示例 有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。 初始化好中央仓库 所有人克隆中央仓库 大家好，我是小明 小明克隆中央仓库，并且add commit， 不断开发，直至完成12345$git clone ssh://user@host/path/to/repo.git3273ecf (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: 完成开发f2faa43 HEAD@&#123;1&#125;: commit: 正在开发335a4b4 HEAD@&#123;2&#125;: commit (initial): 准备阶段 小明发布功能，因此此时中央仓库是空，小明可以直接提价到中央仓库 1$git push origin master 注意，origin是在小明克隆仓库时Git创建的远程中央仓库别名。master参数告诉Git推送的分支。 由于中央仓库自从小明克隆以来还没有被更新过，所以push操作不会有冲突，成功完成。 大家好，我是小红 小红也clone了中央仓库，并且进行了歼星舰项目开发，也不断到add commit，直至开发完成 12345$git clone http://luoyec@103.224.81.114:6605/luoyec/git_practise.gitddc6c37 HEAD@&#123;5&#125;: commit: 舰艇开发完成2899f26 HEAD@&#123;6&#125;: commit: 引擎装载完成29b95cc HEAD@&#123;7&#125;: commit (initial): 材料准备中 小红也想发布自己功能，但此时，中央仓库也有小明提交但代码，本地历史已经和中央仓库有分岐了，Git不想理你，并扔给你一堆提示信息： 123456789luoyecs-iMac:git_practise LW-luoyec$ git pushTo http://103.224.81.114:6605/luoyec/git_practise.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'http://luoyec@103.224.81.114:6605/luoyec/git_practise.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 这避免了小红覆写正式的提交。她要先pull小明的更新到她的本地仓库合并上她的本地修改后，再重试。 小红用git pull合并上游的修改到自己的仓库中。 这条命令类似svn update——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并： 1$git pull --rebase origin master ==–rebase==选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部，如下图所示： 如果你忘加了这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用rebase而不是生成一个合并提交。 小红解决合并冲突 冲突解决工具diffmerge下载地址DMG版全局配置 123456git config --global merge.tool diffmergegit config --global mergetool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge --merge --result=\\$MERGED \\$LOCAL \\$BASE \\$REMOTE\"git config --global mergetool.keepBackup false git config --global diff.tool diffmergegit config --global difftool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge \\$LOCAL \\$REMOTE\" 当出现冲突时，执行命令，弹出窗口手动解决冲突 1$git mergetool 完成合并，保存退出图形化工具已经手动解决了冲突，这是让rebase继续工作，执行命令 123git add &lt;冲突文件/. 表示所有修改文件&gt;git rebase --continue //rebase继续工作git push //代码成功提交 ps: 如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子： ==git rebase –abort 是无风险的操作，会回到rebase操作之前的状态，2个分支的commits毫发无损。git rebase –skip 是高风险的操作，引起冲突的commits会被丢弃（这部分代码修改会丢失）。== 1234//解决冲突失败，或者向重新解决冲突$git rebase --abort//Skip是跳过这个错误，继续本次操作git rebase --skip 功能分支工作流 功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。 工作方式 开发者每次在开始新功能前先创建一个新分支。功能分支应该有个有描述性的名字，比如animated-menu-items或issue-#1061 在master分支和功能分支之间，Git是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。 功能分支也可以（且应该）push到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。由于master是仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题 Pull Requests一旦完成某个功能的开发，不是立即合并到master，而是push到中央仓库到功能分之，并且在分支上发起一个push requests请求合并到master。在修改成为主干代码前，这让其他的开发者有机会去review变更。 一个开发者开发功能需要帮助时，要做的就是发起一个PullRequest，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。 一旦Pull Request被接受了，发布功能要做的就和集中式工作流就很像了。 首先，确定本地的master分支和上游的master分支是同步的。然后合并功能分支到本地master分支并push已经更新的本地master分支到中央仓库。 示例小红开始开发一个新功能在开始开发功能钱，小红需要一个独立到分支，这里新建一个分支 12//-b 不存在则创建， 基于master但new-feature分支git checkout -b new-feature master 小红按老套路编辑、暂存和提交修改，按需要提交以实现功能： 123git statusgit add &lt;some-file&gt;git commit 小红完成开发，push功能分支到中央仓库 12//-u选项设置本地分支去跟踪远程对应的分支, 之后到开发可以省略-ugit push -u origin new-feature 这样功能分支就被提交到中央仓库，这里可以看到有两个分支 小红在她的Git GUI客户端中发起Pull Request，请求合并marys-feature到master，团队成员会自动收到通知。这时候小黑，对新功能有自己对想法，决定拉取new-feature到本地，进行修改。 小黑对新功能的开发 12345678//确保当前最新的git pull//查看当前所有对分支，可以看到小红提交的分支git branch -aaddcommitpush 小黑完成了开发，准备将新功能合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作） 发布流程12345678//检出到master分支git checkout master//拉取最新仓库git pull//new-feature分支到和已经和远程一致的本地master分支git pull origin new-feature//更新远程master分支git push 无论谁来做合并，首先要检出master分支并确认是它是最新的。然后执行git pull originmarys-feature合并marys-feature分支到和已经和远程一致的本地master分支。 你可以使用简单git mergemarys-feature命令，但前面的命令可以保证总是最新的新功能分支。 最后更新的master分支要重新push回到origin。 Gitflow工作流Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。 Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。 Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。 除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。 当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。 工作方式Gitflow工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并push分支到要中央仓库中。 历史分支相对使用仅有的一个master分支，Gitflow工作流使用2个分支来记录项目的历史。master分支存储了正式发布的历史，而develop分支作为功能的集成分支。 这样也方便master分支上的所有提交分配一个版本号。 功能分支每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。 但功能分支不是从master分支上拉出新分支，==而是使用develop分支作为父分支==。当新功能完成时，合并回develop分支。 新功能提交应该从不直接与master分支交互。 发布分支一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上checkout一个发布分支。 新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上—— ==这个分支只应该做Bug修复、文档生成和其它面向发布任务==。 一旦对外发布的工作都完成了，发布分支合并到master分支并分配一个版本号打好Tag。 另外，这些从新建发布分支以来的做的修改要合并回develop分支。 使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。 常用的分支约定： 123用于新建发布分支的分支: develop用于合并的分支: master分支命名: release-* 或 release/* 维护分支维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从master分支fork出来的分支。 修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。 为Bug修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。 你可以把维护分支想成是一个直接在master分支上处理的临时发布。 示例 创建开发分支第一步为master分支配套一个develop分支。简单来做可以本地创建一个空的develop分支，push到服务器上 12git branch developgit push -u origin develop 以后这个分支将会包含了项目的全部历史，而master分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好develop分支的跟踪分支： 12git clone ssh://user@host/path/to/repo.gitgit checkout -b develop origin/develop 现在每个开发都有了这些历史分支的本地拷贝。 小红和小明开始开发新功能 这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于master分支，而是应该基于develop分支： 1git checkout -b some-feature develop 他们用老套路添加提交到各自功能分支上：编辑、暂存、提交： 123git statusgit add &lt;some-file&gt;git commit 小红完成功能开发添加了提交后，小红觉得她的功能OK了。如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。 否则她可以直接合并到她本地的develop分支后push到中央仓库： 12345git pull origin developgit checkout developgit merge some-featuregit pushgit branch -d some-feature 第一条命令在合并功能前确保develop分支是最新的。注意，功能决不应该直接合并到master分支。 冲突解决方法和集中式工作流一样。 小红开始准备发布这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。 像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号： 12//新建一个基于develop对分支用于版本发布，此时并不会影响其他开发者git checkout -b release-0.1 develop 这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。 只要小红创建这个分支并push到中央仓库，这个发布就是功能冻结的。任何不在develop分支中的新功能都推到下个发布循环中。 小红完成发布一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。 另外，如果小红的团队要求Code Review，这是一个发起Pull Request的理想时机。 12345678910/* 两次检出，两次合并，为的是合并到master和develop*/git checkout mastergit merge release-0.1git pushgit checkout developgit merge release-0.1git pushgit branch -d release-0.1 发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。只要有合并到master分支，就应该打好Tag以方便跟踪。 12git tag -a 0.1 -m \"Initial public release\" mastergit push --tags Git有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。 可以配置一个勾子，在你push中央仓库的master分支时，==自动构建==好对外发布。 最终用户发现Bug对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。 为了处理Bug，小红（或小明）从master分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回master分支： 123456//从master分支中拉出一个bug分支，解决完后合并到mastergit checkout -b issue-#001 master# Fix the buggit checkout mastergit merge issue-#001git push 就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了： 1234git checkout developgit merge issue-#001git pushgit branch -d issue-#001 到了这里，但愿你对集中式工作流、功能分支工作流和Gitflow工作流已经感觉很舒适了。 你应该也牢固的掌握了本地仓库的潜能，push/pull模式和Git健壮的分支和合并模型。 Forking工作流Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能==接受不信任==贡献者（contributor）的提交。 Forking工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。 Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。 开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。 这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。 效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。 也让这个工作流成为开源项目的理想工作流。 工作方式和其它的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上。 但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。 这个仓库拷贝作为他个人公开仓库 —— 其它开发者不允许push到这个仓库，但可以pull到修改（后面我们很快就会看这点很重要）。 在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。 要提交本地修改时，push提交到自己公开仓库中 —— 而不是正式仓库中。 然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。 对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。 为了集成功能到正式代码库，==维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错， 合并变更到自己本地的master分支， 然后pushmaster分支到服务器的正式仓库中==。 到此，贡献的提交成为了项目的一部分，其它的开发者应该执行pull操作与正式仓库同步自己本地仓库。 正式仓库在Forking工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。 从技术上来看，各个开发者仓库和正式仓库在Git看来没有任何区别。 事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。 Forking工作流的分支使用方式所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。 各个开发者应该用分支隔离各个功能，就像在功能分支工作流和Gitflow工作流一样。 唯一的区别是这些分支被共享了。在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和Gitflow工作流中是直接被push到正式仓库中。 示例 项目维护者初始化正式仓库和任何使用Git项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。 通常这个仓库也会作为项目维护者的公开仓库。 公开仓库应该是裸仓库，不管是不是正式代码库。 所以项目维护者会运行像下面的命令来搭建正式仓库： 12ssh user@hostgit init --bare /path/to/repo.git Bitbucket和Stash提供了一个方便的GUI客户端以完成上面命令行做的事。 这个搭建中央仓库的过程和前面提到的工作流完全一样。 如果有现存的代码库，维护者也要push到这个仓库中。 开发者fork正式仓库 其它所有的开发需要fork正式仓库。 可以用git clone命令用SSH协议连通到服务器， 拷贝仓库到服务器另一个位置 —— 是的，fork操作基本上就只是一个服务端的克隆。 Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。 这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。 开发者克隆自己fork出来的仓库 下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。 在这个示例中，假定用Bitbucket托管了仓库。记住，如果这样的话各个开发者需要有各自的Bitbucket账号， 使用下面命令克隆服务端自己的仓库： 1git clone https://user@bitbucket.org/user/repo.git 相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名 （这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。 1git remote add upstream https://bitbucket.org/maintainer/repo 需要自己用上面的命令创建upstream别名。这样可以简单地保持本地仓库和正式仓库的同步更新。 注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户： 1git remote add upstream https://user@bitbucket.org/maintainer/repo.git 这时在克隆和pull正式仓库时，需要提供用户的密码。 开发者开发自己的功能在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、提交修改和新建分支： 123git checkout -b some-feature# Edit some codegit commit -a -m \"Add first draft of some feature\" 所有的修改都是私有的直到push到自己公开仓库中。如果正式项目已经往前走了，可以用git pull命令获得新的提交： 1git pull upstream master 开发者发布自己的功能由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。 一旦开发者准备好了分享新功能，需要做二件事。 首先，通过push他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。 他的origin远程别名应该已经有了，所以要做的就是： 1git push origin feature-branch 这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。 第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。 Bitbucket和Stash提供了Pull Request按钮，弹出表单让你指定哪个分支要合并到正式仓库。 一般你会想集成你的功能分支到上游远程仓库的master分支中。 项目维护者集成开发者的功能 当项目维护者收到pull request，他要做的是决定是否集成它到正式代码库中。有二种方式来做： 直接在pull request中查看代码pull代码到他自己的本地仓库，再手动合并第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。 但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支， 合并到他本地的master分支，解决冲突： 1234git fetch https://bitbucket.org/user/repo feature-branch# 查看变更git checkout mastergit merge FETCH_HEAD 变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其它的开发者都能访问到： 1git push origin master 注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。 开发者和正式仓库做同步由于正式代码库往前走了，其它的开发需要和正式仓库做同步： 1git pull upstream master 如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。 但不要害怕，这个工作流实际上就是在功能分支工作流之上引入另一个抽象层。 不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。 示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但同样的方法可以把贡献集成到任一个仓库中。 比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。 这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。 参考链接：xirongGit仓库","categories":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/tags/Git/"},{"name":"多人合作","slug":"多人合作","permalink":"https://luoyec.cn/tags/多人合作/"},{"name":"SVN","slug":"SVN","permalink":"https://luoyec.cn/tags/SVN/"}]},{"title":"Git基础入门","date":"2017-08-10T15:13:02.000Z","path":"2017/08/10/cjqoyqt4600i7hl6pz7ldvfu3/","text":"Git分支管理多人合作 创建版本库1$ git init //不可以手动修改.git目录$ vim readme //新建一个readme文件$ git add readme.md //把文件添加到暂缓区$ git commit -m &quot;wrote a readme file&quot; //把文件提交到仓库 在github仓库，第一次创建123456echo &quot;# React-Node&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/lyctea/React-Node.gitgit push -u origin master 查看仓库状态1$ git status //查看仓库的当前状态$ git diff //查看difference, 没问题则 add--&gt;commit$ git log //最近到最远的提交日志 信息太多可以加--pretty=oneline 回退机制1$ git reflog //历史日志,可以查看所有操作,如果在回退以后又想再次回到之前的版本$ git reset --hard d020e0c //跳转到指定的commit 工作区 暂缓区 分支1$ git add //从工作区添加到暂缓区$ git commit //从暂缓区添加到分支 撤销修改1$ git checkout -- resetTest.txt //让工作区恢复到最近一次commit或者add时的状态$ git reset HEAD resetTest.txt //当已经add的文件, 回退到工作区, 然后使用checkout可以撤销修改 删除文件1$ rm resetTest.txt //删除本地文件$ git checkout -- resetTest.txt //不想删除, 检出 保持工作区和仓库一致$ git rm resetTest.txt //从仓库中删除$ git commit -m &quot;rm test&quot; //并且commit 远程仓库 SSH创建SSH Key1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 登陆GitHub 点“Add SSH Key” 填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容在github上创建仓库1$ git remote add origin git@github.com:michaelliao/learngit.git //连接远程仓库 origin是远程仓库名字$ git push -u origin master //把本地仓库内容推送到远程库上/*推送报错, 以下解决方法 :可以通过如下命令进行代码合并【注：pull=fetch+merge]git pull --rebase origin master此时再执行语句 git push -u origin master即可完成代码上传到github*/ SSH警告第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告, 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。从远程库克隆1$ git clone git@github.com:michaelliao/gitskills.git 分支管理创建分支1$ git branch dev$ git checkout dev/* 也可以一条命令 git checkout -b dev //创建并切换*/ $ git branch //列出所有分支，当前分支前面会标一个*号 合并分支1$ git merge dev //合并指定分支到当前分支 删除分支1$ git branch -d dev //Git鼓励大量使用分支 合并后删除 解决冲突新建一个分支, 并且commit , 当新建分支内容和master分支没有冲突的时候, 可以用自动合并分支处理.当出现冲突时, 自动合并失效, 需要手动处理冲突 . 解决完之后, commit版本 删除新建分支 1/*Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容*/$ git log --graph --pretty=oneline --abbrev-commit //查看合并分支的情况$ git log --graph //查看分支合并图 分支管理策略1/* 强制禁用Fast forward模式，Git就会在merge时生成一个新的commit*/$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 建议使用的分支管理策略1在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 BUG分支1软件开发中，BUG 就像家常便饭一样。BUG 就需要修复，在Git中，由于分支是如此的强大，所以，BUG 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除 1/* 概览：master合并merge解决好的bug后，不要先把dev解印，先合并master，获取里面的bug方案后，在解印。解印时会有提示冲突，需手动改一次文件。 1：在 dev 下正常开发中，说有1个bug要解决，首先我需要把dev分支封存stash 2：在master下新建一个issue-101分支，解决bug，成功后 3：在master下合并issue-101 4：在 dev 下合并master， 这样才同步了里面的bug解决方案 5：解开dev封印stash pop，系统自动合并 &amp; 提示有冲突，因为封存前dev写了东西，此时去文件里手动改冲突 6：继续开发dev，最后add，commit 7：在master下合并最后完成的dev 代码过程如下：*/1： $ git stash2： $ git checkout master $ git checkout -b issue-101 //去文件里修bug $ git add README.md $ git commit -m &quot;fix-issue-101&quot;3： $ git checkout master $ git merge --no-ff -m &quot;m-merge-issue-101&quot; issue-101 $ git branch -d issue-1014： $ git checkout dev $ git merge --no-ff -m &quot;dev-merge-m&quot; master5： $ git stash list //查看冻结列表,以便恢复 $ git stash pop //提示冲突，去文件手动改正 Auto-merging README.md CONFLICT (content): Merge conflict in README.md6： //继续开发 ... ... ，完成后一并提交 $ git add README.md $ git commit -m &quot;fixconflict &amp; append something&quot;7： $ git checkout master $ git merge --no-ff -m &quot;m-merge-dev&quot; dev $ git branch -d dev 冻结与解冻1$ git stash //冻结当前为提交,但是已经add的工作状态$ git stash pop //解冻, 并在状态列表中删除$ git stash list //列出所有的状态$ git stash apply //解冻, 但并不删除状态$ git stash drop //删除状态 Feature分支1开发新功能也是在dev的基础上, 新建一个Feature分支, 完成之后, 切换回dev分支, 进行合并,解决冲突等, 如果开发完的Feature分支buxuyaole, 可以使用 git branch -D 去删除没有合并的分支 多人合作推送分支1并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug 分支只用于在本地修复bug ，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支1$ git push origin --delete remote_branch //删除远程分支$ git remote -v //查看远程仓库信息$ git checkout -b dev origin/dev //创建远程origin的dev分支到本地 1/*多人协作的工作模式通常是这样：首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。*/ 标签1发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来 创建标签1/*切换到需要发布版本的分支*/$ git tag v1.0 //创建标签$ git tag //显示标签$ git log --pretty=oneline --abbrev-commit //定位到历史commit 然后打标签$ git tag v0.9 60f96c3 $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 //-a指定标签名，-m指定说明文字$ git tag -d v0.1 //删除标签$ git push origin v1.0 //推送标签到远程$ git push origin --tags //一次性推送所有标签 /*如果标签已经推送到远程那么*/$ git tag -d v0.9 //先删除本地$ git push origin :refs/tags/v0.9 //在删除远程","categories":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/tags/Git/"},{"name":"基础","slug":"基础","permalink":"https://luoyec.cn/tags/基础/"},{"name":"廖雪峰","slug":"廖雪峰","permalink":"https://luoyec.cn/tags/廖雪峰/"}]},{"title":"Git常见问题","date":"2017-08-10T15:09:05.000Z","path":"2017/08/10/cjqoyqsxv000phl6p0mny1tuz/","text":"引子：git和svn的区别（集中式vs分布式），谈谈优劣？廖雪峰 git集中式vs分布式阮一峰 git分支管理策略 其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。 工作区、暂存区、版本库的概念？参考 分支的概念？阮一峰 git分支管理策略 git status 、git add 、git commit 三个命令的作用及区别，详细谈谈？ git status命令能展示工作目录和stage区的状态. 使用他你能看到那些修改被staged到， git status不显示已经commit到项目历史中去的信息. 看项目历史的信息要使用git log.参考 git add 文件welcome.txt从工作区被提交到暂存区，但此时文件并没有真正进入到版本库当中，文件目前只处于一个中间状态。 git commit(将暂存区文件提交到版本库中) 这个命令将处于中间状态的文件（暂存区的文件)提交到版本库中,这时才算真正完成了一次提交过程。 HEAD的概念参考 HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： git中最常用的命令(12个)常用Git命令清单by阮一峰12345678910111213git statusgit addgit commitgit checkout //切换到指定分支，并更新工作区git reset //重制文件 重置暂缓区 工作区git rm //删除工作区文件git push //推送到远程仓库git pull //拉取远程仓库git clone //下载一个项目和它的整个代码历史git branch //分支管理git merge //合并冲突git tag //标签管理 如何初始化项目，如何连接远程仓库？ 初始化一个空项目，所有的开发者clone到本地，这种方式自动连接到远程仓库 本地目录下git init一个空项目，配置开发环境后 add–&gt;commit； 新建一个远程仓库，使用git remote add ,连接到远程仓库，第一次推送 git push -u origin master .gitignore文件的作用写法？ 在已忽略文件夹中不忽略指定文件夹 12/node_modules/*!/node_modules/layer/ 在已忽略文件夹中不忽略指定文件 12/node_modules/*!/node_modules/layer/layer.js 【注意项】注意写法 要忽略的文件夹一定要结尾 /* ，否则不忽略规则将无法生效 其他规则写法 (附) 123456789101112 以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录； Git冲突及如何解决冲突Gti下游的概念当dev分支是基于master分支，dev分支不断的commit，但是master分支没有修改，这时候可以直接合并分支，不会产生冲突。 即dev上的节点是master的下游时可以直接合并 当master也进行了commit， 这时候可能会产生冲突 merge的几种方式 fast-forword 快速合并， 改变HEAD指针指向 no-ff 新创建一个commit，再改变HEAD指针指向 git pull拆分成两个操作： git fetch（拉取更新，新建一个分支） git merge（合并“远程分支”到本地master分支） 冲突发生的场景 当需要合并分支的时候，另一个分支上的同一份代码已经被修改过 执行git push， 提交代码时，最新仓库中的代码与本地工作区代码存在冲突 如何解决冲突不借助第三方工具廖雪峰git教程，分支合并解决冲突（场景一） 1234567891011121314151617181920212223242526272829//新建并切换到新分支git checkout -v dev//修改data.js 并且add commitgit add data.jsgit commit -m 'edit data'//dev分支完成开发，此时检出到master分支git checkout master//修改master分支同一个文件，也add commitgit add data.jsgit commit -m 'add something'//尝试合并dev分支到master分支git merge dev//提示需要手动解决冲突，解决完成后，将修改到冲突文件add commitgit add data.jsgit commit -m 'fixed merge'//冲突解决之后，推送到远程仓库git push //当不在需要dev分支，则可以删除之git branch -d dev//如果仍然需要dev分支继续开发，则需要同步远程仓库到dev分支上git pull orign master 借助第三方工具（场景二）拉取远程仓库中最新的代码，提示冲突，查看冲突123git pull --rebase origin mastergit status //查看当前冲突文件git mergetool //打开diffmerge工具合并解决冲突 图形化工具diffmerge下载地址DMG版全局配置 123456git config --global merge.tool diffmergegit config --global mergetool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge --merge --result=\\$MERGED \\$LOCAL \\$BASE \\$REMOTE\"git config --global mergetool.keepBackup false git config --global diff.tool diffmergegit config --global difftool.diffmerge.cmd \"/Applications/DiffMerge.app/Contents/MacOS/diffmerge \\$LOCAL \\$REMOTE\" 当出现冲突时，执行命令，弹出窗口手动解决冲突 1$git mergetool 完成合并，保存退出图形化工具已经手动解决了冲突，这是让rebase继续工作，执行命令 123git add &lt;冲突文件/. 表示所有修改文件&gt;git rebase --continue //rebase继续工作git push //代码成功提交 解决冲突中的异常处理 如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子： 1234//解决冲突失败，或者向重新解决冲突$git rebase --abort//Skip是跳过这个错误，继续本次操作$git rebase --skip ==git rebase –abort 是无风险的操作，会回到rebase操作之前的状态，2个分支的commits毫发无损。git rebase –skip 是高风险的操作，引起冲突的commits会被丢弃（这部分代码修改会丢失）。==","categories":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://luoyec.cn/tags/Git/"},{"name":"基础","slug":"基础","permalink":"https://luoyec.cn/tags/基础/"},{"name":"命令","slug":"命令","permalink":"https://luoyec.cn/tags/命令/"}]},{"title":"代码整洁之道三:函数","date":"2017-08-09T15:40:05.000Z","path":"2017/08/09/cjqoyqt0l005mhl6pbw9tohhg/","text":"如何写好函数？ 短小函数到底要多长每个程序每个函数只有两行、三行或者四行。每个函数都一目了然。每个函数都只说明一件事。而且，每隔函数都依序把你带到下一个函数。这就是函数应该达到的短小程度。 代码块和缩进 if语句、else语句、while语句等，其中的代码块应该只有一行。该行应该是一个函数调用。这样不能保持函数短小，而且，因为块内调用的函数拥有较具有说明性的名称，从而增加了文档上的价值。 这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不应该多于一层或两层。当然这也的函数易于阅读和理解。 只做一件事 函数应该做一件事。做好这件事。只做这件事。 如果函数只是做了该函数名下统一抽象层上的步骤，则函数还是只做了一件事。所以判断函数是否不止做了一件事，还有一个方法，==就是看是否能再拆除一个函数，该函数不仅只是单纯地重新诠释其实现==。 只做一件事的函数无法合理的切分为多个区段。 每个函数一个抽象层级 ==要确保函数只做一件事，函数中的语句都要在同一抽象层级上。== 函数中混杂不同的抽象层级，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。 自顶向下读代码： 向下原则 每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能根据抽象层级向下阅读，这就叫向下规则。 switch 语句 switch的几个问题。太长，当类型复杂起来时，会更长。其次，不止做了一件事。第三，违反了单一权责原则，因为有好几个修改它的理由。第四，违反了开放闭合原则，因为每次添加新类型时，就必须修改之。 解决方法，对于switch语句，如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其它部分看不到。 使用描述性的名称 testableHtml改为SetupTeardownIncluderender; isTestable或includeSetupAndTeardownPages， 长的函数名具有描述性，要比描述性的长注释好。可以使用眸中约定，让函数名称中的多个单词更容易阅读，然后使用这些单词给函数取个能说清其功能的名称。 模块名用名词，而函数名用动词描述。 函数参数 最理想的参数数量是零，其次是一个，再次是两个。除非有足够的理由才能用三个以上参数。 一元函数的普遍形式 一元函数即单个参数的函数，大体上分为两种： 操作该参数，将其输出 事件，有输入参数而无输出参数，程序将函数看作是一个事件，使用参数修改系统状态 标识参数将布尔值作为参数用于标识是不值得推荐的做法，如果真要这么做， 应当把函数拆分成两个不带标识参数的函数。 二元函数拥有两个参数比拥有一个参数的函数更复杂难懂，可以利用一些机制转换成一元函数。 三元函数三个参数的函数，排序、琢磨、忽略的问题都会成倍体现。 无副作用函数承诺只做一件事，但有时，会对自己类中的变量做出未能预期的改动，或是对全局变量造成了影响。 这种函数不能以简单的命名让人误解，并且也违法了一个函数只做一件事的规则。 输出参数应该避免使用输出参数，如果函数必须修改某种状态，就修改所属对象的状态吧 分隔指令与询问函数要么做什么事，要么回答什么事，但两者不可兼得。函数应该修改某对象状态或是返回该对象的有关信息。两样都干会导致混乱。 把指令和询问拆分成两个函数 如何在实践中写好函数 一开始都冗长而复杂，有太多的缩进和嵌套循环。有过长的参数列表，名称随意取的，也会有重复代码。 然后打磨这些代码，分解函数、修改名称、消除重复。缩短和安置方法，有时候还拆散类。同时保持测试通过。 最后，遵循本章的规则，组装好这些函数。 小结 ==大师级程序员把系统当做故事来讲，而不是当做程序来写==。 SetupTeardownIncluder程序","categories":[{"name":"代码整洁之道","slug":"代码整洁之道","permalink":"https://luoyec.cn/categories/代码整洁之道/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://luoyec.cn/tags/代码整洁/"},{"name":"提高","slug":"提高","permalink":"https://luoyec.cn/tags/提高/"}]},{"title":"Express Getting Started实践","date":"2017-08-08T22:43:10.000Z","path":"2017/08/09/cjqoyqsxu000lhl6p3iy1zucm/","text":"Getting started安装新建一个目录, 初始化项目 123mkdir myappcd myappnpm init //可以手动输入入口文件,如entry point: (index.js) 安装express依赖 12npm install express --savenpm install express --no-save //也可以不将express添加到依赖中 新建一个Hello World 示例修改目录下index.js文件如下: 12345678910const express = require('express')const app = express()app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;)app.listen(3000, function () &#123; console.log('Example app listening on port 3000!')&#125;) 运行这个应用用一下命令: 1node index.js 打开浏览器 http://localhost:3000/ , 就能看到输入 ‘Hello World!’ 使用Express 的脚手架构建项目使用脚手架工具, 可以快速的创建项目骨架,全局安装express-generator 1npm install express-generator -g -h命令参数 可以看到打印的信息 123456789101112131415$express -hUsage: express [options] [dir] Options: -h, --help output usage information --version output the version number -e, --ejs add ejs engine support --pug add pug engine support --hbs add handlebars engine support -H, --hogan add hogan.js engine support -v, --view &lt;engine&gt; add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 使用一下命令可以快速构建指定项目名的应用, 并且可以同时指定模板引擎 12345678910111213141516171819express --view=pug myapp create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.pug create : myapp/views/layout.pug create : myapp/views/error.pug create : myapp/bin create : myapp/bin/www 进到工作目录中,安装依赖, 并运行项目 12cd myappnpm install On MacOS or Linux系统,执行以下命令: 1$ DEBUG=myapp:* npm start On Windows系统, 执行以下命令: 1&gt; set DEBUG=myapp:* &amp; npm start 同样打开浏览器 http://localhost:3000/ 通过脚手架创建的项目, 目录结构如下 12345678910111213141516171819.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.pug ├── index.pug └── layout.pug7 directories, 9 files 基础路由应用的路由处理客户端通过URL或路径等特定的http请求方法(GET POST …)的请求每一个路由当被匹配的时候, 都由一个或者多个的处理函数定义路由的方法 1app.METHOD(PATH, HANDLER) 这里需要注意的几个点 app是express的实例 METHOD是HTTP请求方方法, 小写 PATH是服务器路径 HANDLER是当路由匹配的时候执行的方法 路由简单实例相应’Hello World!’字符串在主页上 123app.get('/', function(req,res)&#123; res.send('Hello World!')&#125;) 相应一个post方法的请求 123app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125; 相应PUT方法的请求, 匹配/user 路由 123app.put('/user', function(req, res)&#123; res.send('Got a PUT request a /user')&#125;) 相应DELETE方法的请求, 匹配/user 路由 123app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user')&#125;) 在express中的静态文件静态文件, 图片 css javascript等, 使用express内置的中间件express.static处理. 通过命名的目录包含这些静态资源文件, express.static中间件函数开始直接为这些文件提供支持.例如: 1app.user(express.static('public')) 现在可以加载这些文件了 ps:使用的是相对路径 12345http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html 如果有多个静态资源目录, 调用express.static中间件多次即可 12app.use(express.static('public'))app.use(express.static('files')) express会按顺序设置这些静态文件 虚拟前缀创建一个虚拟的前缀(这个前缀并不存在与服务器的文件系统中) 1app.use('/static', express.static('public')) 现在可以通过这个虚拟的前缀访问到静态资源文件 12345http://localhost:3000/static/images/kitten.jpghttp://localhost:3000/static/css/style.csshttp://localhost:3000/static/js/app.jshttp://localhost:3000/static/images/bg.pnghttp://localhost:3000/static/hello.html 小结express.static使用相对路径加载静态文件当你加载你的node程序, 如果你从其他路径运行的express 应用,一个更安全的策略是使用绝对路径 1app.use('/static', express.static(path.join(__dirname, 'public')))","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://luoyec.cn/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://luoyec.cn/tags/Nodejs/"},{"name":"Express","slug":"Express","permalink":"https://luoyec.cn/tags/Express/"}]},{"title":"socket.io入门实践","date":"2017-08-08T22:39:08.000Z","path":"2017/08/09/cjqoyqszv004lhl6prw0df8xa/","text":"相关链接：socket.io官网零基础搭建网页聊天室（socket.io使用教程） 开始 创建一个基础的聊天应用, 这不需要Node.js和Scocket.io基础 web框架 首先是package.json文件, 用于配置依赖并且安装express框架 1cnpm install --save express@4.15.2 12345678&#123; \"name\": \"socket-chat-example\", \"version\": \"0.0.1\", \"description\": \"my first socket.io app\", \"dependencies\": &#123; \"express\": \"^4.15.2\" &#125;&#125; 新建一个index.js文件作为node服务器入口文件 12345678910let app = require('express')()let http = require('http').Server(app)app.get('/', (req, res) =&gt; &#123; res.send(`&lt;h1&gt;Hello World!&lt;/h1&gt;`)&#125;)http.listen(3000, ()=&gt;&#123; console.log('listening on *.3000')&#125;) 执行命令, 开启http服务, 在浏览器打开3000端口 1node index.js 提供HTML直接返回标签容易让人混乱, 这里重构代码, 新建一个index.html文件 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;form action=\"\"&gt; &lt;input id=\"m\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 并修改服务器路由, 发送一个html文件而不是标签 123app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.sendFile(__dirname + &apos;/index.html&apos;)&#125;) 重新运行 整合Socket .io 整合Socket .io 分为客户端和服务器端两部分,其中客户端不需要而外加载, 只需要作为全局变量使用即可 客户端配置,修改index.html文件, 在前加入js代码 123456 &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script&gt; let socket = io() &lt;/script&gt;&lt;/body&gt; 修改index.js文件, 监听l连接与连接断开事件 123456io.on('connection', (socket)=&gt;&#123; console.log('a user connected') socket.on('disconnect', ()=&gt;&#123; console.log('user disconnect') &#125;)&#125;) 在控制台中可以查看用户连接事件 触发事件 socket .io最主要的作用就是你可以触发和监听任何你想要的事件，任何对象都可以编码成json，并且二进制数据也是支持的 修改index.html 将输入框内容，通过‘chat message’事件发送给服务器 123456789101112&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function ()&#123; var socket = io() $('form').submit(function()&#123; socket.emit('chat message', $('#m').val()) $('#m'.val('')) return false &#125;) &#125;) &lt;/script&gt; 修改服务器index.js文件, 监听客户端的发送消息事件, 并将消息打印在控制台 123456789io.on('connection', (socket)=&gt;&#123; console.log('a user connected') socket.on('disconnect', ()=&gt;&#123; console.log('user disconnect') &#125;) socket.on('chat message', (msg)=&gt;&#123; console.log('message: ' + msg) &#125;)&#125;) 在客户端输入信息, 服务器就能监听到了 广播 如果向每个连接的客户端都发送事件, 可以使用io.emit()方法 1io.emit('some event', &#123; for: 'everyone' &#125;); 如果是想某个特定的sokect连接发送事件,可以使用broadcast标志 123io.on('connection', function(socket)&#123; socket.broadcast.emit('hi');&#125;); 这里将事件发送给每一个连接的客户端, 修改index.js文件 12345678910111213io.on('connection', (socket)=&gt;&#123; console.log('a user connected') //监听连接断开事件 socket.on('disconnect', ()=&gt;&#123; console.log('user disconnect') &#125;) //监听客户端发送消息事件 socket.on('chat message', (msg)=&gt;&#123; console.log('message: ' + msg) //向所有客户端广播事件 io.emit('chat message', msg) &#125;) &#125;) 修改index.html文件, 监听事件, 将消息动态插入到ui列表中 12345678910111213&lt;script&gt; $(function () &#123; var socket = io() $('form').submit(function () &#123; socket.emit('chat message', $('#m').val()) $('#m').val('') return false &#125;) socket.on('chat message', function (msg) &#123; $('#messages').append($('&lt;li&gt;').text(msg)) &#125;) &#125;)&lt;/script&gt; 打开两个客户端, 实现了简单的聊天室功能 功能更完善的聊天室应用1$ git clone https://github.com/socketio/chat-example.git","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://luoyec.cn/categories/Nodejs/"}],"tags":[{"name":"node","slug":"node","permalink":"https://luoyec.cn/tags/node/"},{"name":"socket","slug":"socket","permalink":"https://luoyec.cn/tags/socket/"},{"name":"聊天室","slug":"聊天室","permalink":"https://luoyec.cn/tags/聊天室/"}]},{"title":"代码整洁之道二：有意义的命名","date":"2017-08-08T15:21:20.000Z","path":"2017/08/08/cjqoyqt0m005nhl6p1206of4f/","text":"命名的几条简单规则名副其实变量、函数和类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。 虽然一些代码没有复杂的表达式，问题不在于代码的简洁度，而在于代码的模糊度：即上下文在代码中未被明确的体现的程度。所以简介的代码需要了解例如数组下标的意义，一些值和变量的意义，这是什么类型，返回会返回这数据类型的值等 优化方案： 比如，我们在开发一种扫雷游戏，我们发现盘面是名为theList的单元格列表，那就将其名称改为gameBoard， 我们还发现，下表其实是一种状态值，而状态值为4标识“已标记”。只要改为由意义的名称，代码就会得到相当程度的改进 更进一步，不用个int数组标识单元格，而是另外写一个类。该类包括一个名副其实的函数（成为isFlagged），从而掩盖那个魔术数 避免误导 一些专有名词不应该用作变量名，如 “hp”，“aix”，“sco”等；避免使用在不同的地方但是区别较小的名称，想区分模块某处的XYZControllerForEffcientHandilingOfStrings和另一处的XYZControllerForEfficienStoorageOfStrings，会话很长时间。 以同样的方式拼写出相同概念才是信息，拼写前后不一致就是误导。极端的例子， 使用消息字符l和大写字母O作为变量名。 做有意义的区分 不要为了满足编译器而写代码，光是添加数字或是废话是远远不够的，即便这足以让编译器满意。如果名称必须相异，那其意思也应该不同才对。 以数字系列命名（a1、a2）是依义命名的反面，容易误导，完全没有提供正确信息。 变量名无意义的废话是不必要的，也无助于区分。假如你有一个Product类，还有一个ProductInfo或者是ProductData类，虽然名称不同，但却无区别。 使用读得出来的名称 命名的变量应该具有良好的可读性 使用可搜索的名称 查找MAX_CLASSES_FER_STUDENT很容易，而查找e很困难。单字母名称仅用于短方法中的本地变量。名称的长短应与其作用域大小相对应。若常量或者变量可能在多处使用，则应赋予其便于搜索的名称。 避免使用编码 把类型或者作用域编进名称里，突然增加了了解码的负担。没有理由要求每位新人都在弄清应付的代码之外，还要再搞懂另一种编码“语言” 成员前缀 也不必使m_ 前缀来表明成员变量。应当把类和函数做得足够小，消除对成员前缀的需求。 类名及方法名 类名对象应该是名字或名词短语，如Customer、WikiPage、Account等，并且类名不应该是动词。 方法名应当是动词或动词短语，如postPayment、deletePage或save等。属性访问器、修改器和判断应该根据其值命名，并依据==Javabean标准加上get、set或is前缀==。 别扮可爱 如果名称太耍宝，那就只有同作者一般有幽默感的人才能记住。 每个概念对应一个词 给每个抽象概念选一个词，避免在多个类中使用相同名称的方法名，这不便于区分方法所属的类。 别用双关语 避免将同一个单词用于不同目的。同一术语用于不同概念，基本就是双关了。 使用解决方案领域名称 只有程序员才会读你的代码，所以，尽量使用计算机科学术语、算法名、模式名、数学名。 添加有意义的语境不添加无意义的语境小结 多数时候我们并不记忆类名和方法名，我们使用现代工具对付这些细节，好让自己集中精力把代码写得更好。 可以试试以上的规则，看看代码可读性是否还可以提高","categories":[{"name":"代码整洁之道","slug":"代码整洁之道","permalink":"https://luoyec.cn/categories/代码整洁之道/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://luoyec.cn/tags/代码整洁/"},{"name":"提高","slug":"提高","permalink":"https://luoyec.cn/tags/提高/"}]},{"title":"代码整洁之道一:代码整洁","date":"2017-08-08T06:23:46.000Z","path":"2017/08/08/cjqoyqt0i005ihl6pkht4598p/","text":"代码整洁这是本有关编写好程序的书，它充斥着代码。我们需要从各个方面来考察这些代码。从顶向下，从里而外。读完之后就知道许多关于代码的事了。 而且，我们还能说出好代码和糟糕代码之间的差异。我们将知道如何写出好代码，我们也会知道，如何将糟糕代码改成好代码。 要有代码有一种观点， 随着自动化发展，人工智能技术的进步， 代码是可以自动生成，而不再需要人工编写。 而问题在于，代码呈现了需求的细节，在某些层面上，这些细节无法被忽略和抽象，并且将需求明确到机器可以执行的细节程度，这就是编程所做的工作。 即使是人类，也造不出满足客户模糊感觉的成功系统。我们永远无法抛弃必要的精确性–所以代码永存。 糟糕的代码及混乱的代价随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降的时，管理层只能增加更多的人手到项目中，期望提高生产力，可是新人并不熟悉系统的设计，也搞不清楚什么样的修改更符合设计的意图，什么样的修改违背设计意图。于是制造了更多的混乱。 作为程序员应有态度很多时候讲问题归咎于经理， 客户，其实他们期望从我们这里得到必要的信息，然后才能做出程度和保证，即便他们没有开口问，我们也不应该羞于告知自己的想法。对于项目的规划我们脱不了干系，并对失败负有责任，特别是当失败与糟糕的代码有关时！ 另一方面，程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。 还需要注意的是，在项目开发中，制造混乱无助于赶上工期，混乱只会拖慢你，叫你错过期限。赶上期限的唯一方法–做得更快的方法–就是始终极可能的保持代码的整洁。 代码整洁的艺术写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”。这种“代码感”就是关键所在。简而言之，==编写整洁代码的程序员就像是艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统==。 什么是整洁代码 我喜欢优雅和搞笑的代码，代码逻辑应当直截了当，叫缺陷难以隐蔽，尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省的引诱别人做没规矩的优化，搞出一堆混乱来，整洁代码只做好一件事情。Bjarne Stroustrup C++语言发明者 优雅的定义：外表或举止令人愉悦的优美和雅观；令人愉悦的精致和简单。 破窗理论：窗户破损的建筑让人觉得似乎无人照管，于是别人也不再关心，放任窗户继续破损。最终自己也参与破坏活动，在外墙上涂鸦，任垃圾堆积，一扇破损的窗户开辟了大厦走向倾颓的道路。 整洁的代码力求集中，每个函数、每隔类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。 整洁的代码简单直接，整洁代码如同优雅的散文，整洁的代码从不隐藏设计者 的意图，充满干净利落的抽象和直截了当的控制语句。Grady Booch 《面向对象分析与设计》作者 简单代码，以其重要顺序： 能通过所有测试 没有重复代码 体现系统中全部的设计理念 包括尽量少的实体，比如类，方法，函数等在以上诸项中，我最在意代码重复，如果同一段代码反复出现，就表示某种想法未在代码中得到良好表现，我尽力去找出到底那是什么，然后再尽力清晰地表达出来。在我看来，有意义的命名是体现表达力的一种方式；如果对象功能太多，最好是切分为两个或多个对象；如果方法功能太多，我总是使用抽象手段重构之，从而得到一个较为清晰地说明自身功能的方法。以及另外数个说明如何实现这些功能的方法。这么多年下来，我发现所有的程序都由极为相似的元素构成，例如“在集中中查找某元素”，不管是员工记录数据库，还是哈希表，或者是数组。我们都会发现自己想要从集合中查找某一特定条目，一旦出现这种情况，我通常会把实现手段封装到更抽象的方法或者类中Ron Jeffries 《C#极限编程探险》作者 小结艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书同样也不担保你成为好程序员。它不担保能给你“代码感觉”。它能做的，只是展示好程序员的思维过程，还有他们使用的技巧、技术、工具。 和艺术书一样，本书也充满细节。代码会很多，你会看到好代码，也会看到糟糕的代码。你会看到糟糕的代码如何装换成好代码。你会看到启发、规则和技巧的列表。你会看到一个又一个例子。但这始终取决于你。","categories":[{"name":"代码整洁之道","slug":"代码整洁之道","permalink":"https://luoyec.cn/categories/代码整洁之道/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://luoyec.cn/tags/读书笔记/"},{"name":"代码整洁","slug":"代码整洁","permalink":"https://luoyec.cn/tags/代码整洁/"},{"name":"提高","slug":"提高","permalink":"https://luoyec.cn/tags/提高/"}]},{"title":"MongoDB及Robo工具安装","date":"2017-08-05T02:08:28.000Z","path":"2017/08/05/cjqoyqsyy002qhl6p60m9z4x5/","text":"参考资源: Install MongoDB Community Edition with Homebrew mongodb安装：安装 mongodb 1$ brew install mongodb 安装 TLS/SSL Support 1$ brew install mongodb --with-openssl 安装 Release of MongoDB 最新开发版，不是必须 1$ brew install mongodb —devel 新建目录数据库 1$ mkdir -p /data/db 目录权限不足时 xxx是用户名luoyec 1$ sudo chown xxx /data/db 启动mongoldb 服务 1$ mongod 启动query database 新建终端. 可以开始各种数据库指令 1$ mongo 命令： 123$ show dab //显示已经存在的数据库 $ use somedbname //创建（使用）某个数据库 $ exit //退出 把mongodb/bin加入$PATH 12$ export MONGO_PATH=/usr/local/mongodb $ export PATH=$PATH:$MONGO_PATH/bin 安装Robo可视化工具直接官网下载安装即可 使用方法新建 /data/db 目录 ， 用于存放各个数据库1$ mkdir -p /data/db 启动服务1$ mongod 启动命令行工具，另起一个终端1$ mongo 用可视化工具连接数据库","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://luoyec.cn/categories/Nodejs/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://luoyec.cn/tags/mongodb/"},{"name":"robo","slug":"robo","permalink":"https://luoyec.cn/tags/robo/"},{"name":"工具使用","slug":"工具使用","permalink":"https://luoyec.cn/tags/工具使用/"}]}]